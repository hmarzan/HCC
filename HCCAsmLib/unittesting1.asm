TITLE	 c:\hcc\hcc\TestSource\unittesting1.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{327}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000407
;}
$L000407:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{390}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000424
;}
$L000424:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{402}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000430
;}
$L000430:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{406}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000432
;}
$L000432:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{398}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000428
;}
$L000428:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{386}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000421
;}
$L000421:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{394}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000426
;}
$L000426:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{417}:return Math::log10(X + Math::Sqrt(X * X - 1))

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]

	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_log10
	jmp	OFFSET $L000438
;}
$L000438:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{429}:return Math::log10((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_log10
	jmp	OFFSET $L000444
;}
$L000444:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{433}:return Math::log10((X + 1) / (X - 1)) / 2

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_log10
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000446
;}
$L000446:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{425}:return Math::log10((Math::Sqrt(-X * X + 1) + 1) / X)


	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_log10
	jmp	OFFSET $L000442
;}
$L000442:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{413}:return Math::log10(X + Math::Sqrt(X * X + 1))

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_log10
	jmp	OFFSET $L000435
;}
$L000435:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{421}:return Math::log10((1 + X) / (1 - X)) / 2

	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_log10
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000440
;}
$L000440:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{322}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000404
;}
$L000404:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_RadiansToDegrees ENDP

UnitTesting_Circle_Circumference PROC NEAR 
;double Circumference(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{72}:return Math::pi() * Radius
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Circle_get_Radius
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000590
;}
$L000590:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Circumference ENDP

UnitTesting_Circle_ComputeArea PROC NEAR 
;double ComputeArea(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{91}:return 2 * Circumference()
	mov	EAX,000000002h
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Circle_Circumference
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000596
;}
$L000596:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_ComputeArea ENDP

UnitTesting_Circle_Draw PROC NEAR 
;void Draw(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{86}:Console::WriteLn("Drawing a Circle!");
	lea	EAX,OFFSET $S000595
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000594:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Draw ENDP

UnitTesting_Circle_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{81}:return "Circle"
	lea	EAX,OFFSET $S000593
	jmp	OFFSET $L000592
;}
$L000592:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Name ENDP

UnitTesting_Circle_get_Radius PROC NEAR 
;double get::Radius(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{62}:return radius
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000587
;}
$L000587:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_get_Radius ENDP

UnitTesting_Circle_put_Radius PROC NEAR 
;void put::Radius(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{67}:radius= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	fstp	qword ptr [EBX]
;}
$L000588:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Circle_put_Radius ENDP

UnitTesting_Circle_Type PROC NEAR 
;UnitTesting::ShapeType Type(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{77}:return UnitTesting::stCircle
	mov	EAX,000000001h
	xor	EDX,EDX
	jmp	OFFSET $L000591
;}
$L000591:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Type ENDP

UnitTesting_Circle PROC NEAR 
;void UnitTesting::Circle(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Shape ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Circle 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_Circle 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle ENDP

UnitTesting_HelloWorld_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{39}:Console::WriteLn("The HelloWorld destructor");
	lea	EAX,OFFSET $S000644
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000643:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_HelloWorld_Destructor ENDP

UnitTesting_HelloWorld_SayHello PROC NEAR 
;void SayHello(string text);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{29}:Console::WriteLn("this is what I have to say for the first time in H++ :", text);
	lea	EAX,OFFSET $S000639
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP+0008h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 
;}
$L000637:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_HelloWorld_SayHello ENDP

UnitTesting_HelloWorld_ShowHello PROC NEAR 
;void ShowHello(string text);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{34}:System::ShowMessage(text, "H++ First program", System::IconInformation);
	mov	EAX,000000040h
	xor	EDX,EDX
	push	EAX 
	lea	EAX,OFFSET $S000642
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	call	 System_ShowMessage
;}
$L000640:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_HelloWorld_ShowHello ENDP

UnitTesting_HelloWorld PROC NEAR 
;void UnitTesting::HelloWorld(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{24}:Console::WriteLn("The HelloWorld constructor");
	lea	EAX,OFFSET $S000636
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_HelloWorld ENDP

UnitTesting_Integers_Inline_Test PROC NEAR 
;void UnitTesting::Integers_Inline::Test(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0010h]
	mov	ECX,000000004h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{90}:a= 5, b= 4;
	mov	EAX,000000005h
	mov	dword ptr [EBP-0004h],EAX
	mov	EAX,000000004h
	mov	dword ptr [EBP-0008h],EAX

;{92}:Console::WriteLn("The values: a = ", a, ", and b = ", b);
	lea	EAX,OFFSET $S000551
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000552
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{94}:c= max(a, b);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EBX
	xor	ECX,ECX
	cmp	EBX,EAX
	setle	CL
	sub	ECX,000000001h
	sub	EBX,EAX 
	and	ECX,EBX
	add	EAX,ECX
	mov	dword ptr [EBP-000Ch],EAX

;{96}:Console::WriteLn("The max value is = ", c);
	lea	EAX,OFFSET $S000554
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{98}:d= min(a, b);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EBX
	sub	EBX,EAX
	sbb	ECX,ECX
	and	ECX,EBX
	add	EAX,ECX
	mov	dword ptr [EBP-0010h],EAX

;{100}:Console::WriteLn("The min value is = ", d);
	lea	EAX,OFFSET $S000556
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000546:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Integers_Inline_Test ENDP

UnitTesting_Rnd_NextDbl PROC NEAR 
;double NextDbl(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{45}:return UnitTesting::Rnd::NextDblEx()
	call	 UnitTesting_Rnd_NextDblEx
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Rnd_NextDbl ENDP

UnitTesting_Rnd_NextInt PROC NEAR 
;double NextInt(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{50}:return UnitTesting::Rnd::NextIntEx()
	call	 UnitTesting_Rnd_NextIntEx
	jmp	OFFSET $L000467
;}
$L000467:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Rnd_NextInt ENDP

UnitTesting_Rnd PROC NEAR 
;void UnitTesting::Rnd(int seedx);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{15}:UnitTesting::Rnd::seed= seedx;
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	dword ptr [EBX],EAX
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_Rnd ENDP

UnitTesting_Rnd_setSeed PROC NEAR 
;void setSeed(long s);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{21}:UnitTesting::Rnd::seed= s;
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	dword ptr [EBX],EAX
;}
$L000461:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_Rnd_setSeed ENDP

UnitTesting_Rnd_NextDblEx PROC NEAR 
;double UnitTesting::Rnd::NextDblEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{26}:UnitTesting::Rnd::seed= Math::Round(UnitTesting::Rnd::a * (UnitTesting::Rnd::seed % UnitTesting::Rnd::q) - UnitTesting::Rnd::r * (UnitTesting::Rnd::seed * UnitTesting::Rnd::q));

	lea	EBX,OFFSET UnitTesting_Rnd_a
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_q
	mov	EAX,dword ptr [EBX]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	push	EDX 
	lea	EBX,OFFSET UnitTesting_Rnd_r
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_q
	mov	EAX,dword ptr [EBX]
	pop	ECX
	cdq	
	imul	EAX,ECX
	fclex
	push	EAX
	push	EDX 
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fistp	qword ptr [ESP]
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fistp	qword ptr [ESP]
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 

	call	 Math_Round
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	dword ptr [EBX],EAX

;{28}:UnitTesting::Rnd::seed+= (UnitTesting::Rnd::seed < 0 ? UnitTesting::Rnd::m : 0);
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	 $L000972
	lea	EBX,OFFSET UnitTesting_Rnd_m
	mov	EAX,dword ptr [EBX]
	jmp	 $L000973
$L000972:
	xor	EAX,EAX
$L000973:
	clc	
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	add	dword ptr [EBX],EAX

;{30}:return UnitTesting::Rnd::seed / UnitTesting::Rnd::m
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_m
	mov	EAX,dword ptr [EBX]
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000463
;}
$L000463:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Rnd_NextDblEx ENDP

UnitTesting_Rnd_NextIntEx PROC NEAR 
;double UnitTesting::Rnd::NextIntEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{36}:UnitTesting::Rnd::seed= UnitTesting::Rnd::a * (UnitTesting::Rnd::seed % UnitTesting::Rnd::q) - UnitTesting::Rnd::r * (UnitTesting::Rnd::seed * UnitTesting::Rnd::q);
	lea	EBX,OFFSET UnitTesting_Rnd_a
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_q
	mov	EAX,dword ptr [EBX]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	push	EDX 
	lea	EBX,OFFSET UnitTesting_Rnd_r
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_q
	mov	EAX,dword ptr [EBX]
	pop	ECX
	cdq	
	imul	EAX,ECX
	fclex
	push	EAX
	push	EDX 
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fistp	qword ptr [ESP]
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fistp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	dword ptr [EBX],EAX

;{38}:UnitTesting::Rnd::seed+= (UnitTesting::Rnd::seed < 0 ? UnitTesting::Rnd::m : 0);
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	 $L000974
	lea	EBX,OFFSET UnitTesting_Rnd_m
	mov	EAX,dword ptr [EBX]
	jmp	 $L000975
$L000974:
	xor	EAX,EAX
$L000975:
	clc	
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	add	dword ptr [EBX],EAX

;{40}:return UnitTesting::Rnd::seed % UnitTesting::Rnd::m
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_m
	mov	EAX,dword ptr [EBX]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	jmp	OFFSET $L000465
;}
$L000465:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Rnd_NextIntEx ENDP

UnitTesting_Shape PROC NEAR 
;void UnitTesting::Shape(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Shape 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Shape ENDP

UnitTesting_Square_ComputeArea PROC NEAR 
;double ComputeArea(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{122}:return Width * Height
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Square_get_Width
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Square_get_Height
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000609
;}
$L000609:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_ComputeArea ENDP

UnitTesting_Square_Draw PROC NEAR 
;void Draw(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{135}:Console::WriteLn("Drawing a Square!");
	lea	EAX,OFFSET $S000614
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000613:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_Draw ENDP

UnitTesting_Square_get_Height PROC NEAR 
;double get::Height(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{112}:return dHeight
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0010h]
	mov	EDX,dword ptr [ECX+000Ch] 
	jmp	OFFSET $L000606
;}
$L000606:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_get_Height ENDP

UnitTesting_Square_put_Height PROC NEAR 
;void put::Height(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{117}:dHeight= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+000Ch]
	fstp	qword ptr [EBX]
;}
$L000607:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Square_put_Height ENDP

UnitTesting_Square_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{130}:return "Square"
	lea	EAX,OFFSET $S000612
	jmp	OFFSET $L000611
;}
$L000611:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_Name ENDP

UnitTesting_Square_Type PROC NEAR 
;UnitTesting::ShapeType Type(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{126}:return UnitTesting::stSquare
	mov	EAX,000000002h
	xor	EDX,EDX
	jmp	OFFSET $L000610
;}
$L000610:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_Type ENDP

UnitTesting_Square_get_Width PROC NEAR 
;double get::Width(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{102}:return dWidth
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000602
;}
$L000602:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_get_Width ENDP

UnitTesting_Square_put_Width PROC NEAR 
;void put::Width(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{107}:dWidth= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	fstp	qword ptr [EBX]
;}
$L000603:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Square_put_Width ENDP

UnitTesting_Square PROC NEAR 
;void UnitTesting::Square(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Shape ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Square 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_Square 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square ENDP

UnitTesting_SummationSeries_Ackermman PROC NEAR 
;int UnitTesting::SummationSeries::Ackermman(int m, int n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{77}:if(m == 0 && n >= 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	pop	EDX
	and	EAX,EDX
	test	AL,AL
	jz	OFFSET $L000978

;{78}:return n + 1
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	jmp	OFFSET $L000542

; else {
$L000978:

;{79}:if(m >= 1 && n == 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	pop	EDX
	and	EAX,EDX
	test	AL,AL
	jz	OFFSET $L000980

;{80}:return UnitTesting::SummationSeries::Ackermman(m - 1, 1)
	mov	EAX,000000001h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	call	 UnitTesting_SummationSeries_Ackermman
	jmp	OFFSET $L000542

; else {
$L000980:

;{82}:return UnitTesting::SummationSeries::Ackermman(m - 1, UnitTesting::SummationSeries::Ackermman(m, n - 1))
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	call	 UnitTesting_SummationSeries_Ackermman
	push	EAX 

	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	call	 UnitTesting_SummationSeries_Ackermman
	jmp	OFFSET $L000542
$L000981:

; }
$L000979:

; }
;}
$L000542:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SummationSeries_Ackermman ENDP

UnitTesting_SummationSeries_ComputeRenderGamma PROC NEAR 
;void UnitTesting::SummationSeries::ComputeRenderGamma(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-000Ch]
	mov	ECX,000000003h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{68}:result= 0;
	xor	EAX,EAX
	push	EAX
	fild	dword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{69}:for(i= 1; i <= 500000; ++i)
	mov	EAX,000000001h
	pop	EDX
	pop	EAX 
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000982
$L000983:
	inc	dword ptr [EBP-12]
	mov	EAX,dword ptr [EBP-12]
$L000982:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,00007A120h
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	EAX,EAX
	jz	OFFSET $L000984

;{70}:result+= 1.0 / i - Math::log2((i + 1.0) / i);
	fld1
	push	ECX
	push	ECX 
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP-000Ch]
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	fld1
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP-000Ch]
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_log2
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	clc	
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	fadd	qword ptr [EBP-0008h]
	fstp	qword ptr [EBP-0008h]
	jmp	OFFSET $L000983 
$L000984:

;{72}:Console::WriteLn("Gamma y = ", result);
	lea	EAX,OFFSET $S000541
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
$L000536:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_SummationSeries_ComputeRenderGamma ENDP

UnitTesting_SummationSeries_GeometricSeriesClosedSum PROC NEAR 
;int UnitTesting::SummationSeries::GeometricSeriesClosedSum(int x, signed n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{62}:return FloatingPoint::ToInt((Math::Pow(x, n + 1) - 1) / (x - 1))

	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	
call	 Math_Pow
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 FloatingPoint_ToInt
	jmp	OFFSET $L000533
;}
$L000533:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SummationSeries_GeometricSeriesClosedSum ENDP

UnitTesting_SummationSeries_GeometricSeriesSum PROC NEAR 
;int UnitTesting::SummationSeries::GeometricSeriesSum(int x, signed n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000018h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0014h]
	mov	ECX,000000005h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{21}:nx= FloatingPoint::ToInt(3.145464654);
	mov	EDX,05F5D3B4Eh
	mov	EAX,0400929E9h 
	push	EAX
	push	EDX 
	call	 FloatingPoint_ToInt
	mov	dword ptr [EBP-0004h],EAX

;{23}:sum= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX

;{24}:for(i= 0; i <= n; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000985
$L000986:
	inc	dword ptr [EBP-12]
	mov	EAX,dword ptr [EBP-12]
$L000985:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	EAX,EAX
	jz	OFFSET $L000987
;{

;{26}:prod= 1;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0010h],EAX

;{27}:for(j= 0; j < i; ++j)
	xor	EAX,EAX
	mov	dword ptr [EBP-0014h],EAX
	jmp	OFFSET $L000988
$L000989:
	inc	dword ptr [EBP-20]
	mov	EAX,dword ptr [EBP-20]
$L000988:
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	EAX,EAX
	jz	OFFSET $L000990

;{28}:prod*= x;
	mov	EAX,dword ptr [EBP+0008h]
	imul	dword ptr [EBP-0010h]
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000989 
$L000990:

;{29}:sum+= prod;
	mov	EAX,dword ptr [EBP-0010h]
	clc	
	add	dword ptr [EBP-0008h],EAX
;}
	jmp	OFFSET $L000986 
$L000987:

;{31}:return sum
	mov	EAX,dword ptr [EBP-0008h]
	jmp	OFFSET $L000512
;}
$L000512:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SummationSeries_GeometricSeriesSum ENDP

UnitTesting_SummationSeries_Horner_GeometricSeriesSum PROC NEAR 
;int UnitTesting::SummationSeries::Horner::GeometricSeriesSum(int x, signed n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{49}:sum= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{50}:for(i= 0; i <= n; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L000991
$L000992:
	inc	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L000991:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	EAX,EAX
	jz	OFFSET $L000993

;{51}:sum= sum * x + 1;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fistp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000992 
$L000993:

;{53}:return sum
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000528
;}
$L000528:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SummationSeries_Horner_GeometricSeriesSum ENDP

UnitTesting_SummationSeries_Horner_Horner PROC NEAR 
;int UnitTesting::SummationSeries::Horner::Horner(int [] a, signed n, int x);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{39}:result= a[n];
	mov	EBX,dword ptr [EBP+0008h]
	lea	EAX,dword ptr [EBX]
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP+000Ch]
	mov	ECX,EAX
	mov	EAX,dword ptr [ESI+ECX*0004h] 
	mov	dword ptr [EBP-0004h],EAX

;{41}:for(i= n - 1; i >= 0; --i)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L000994
$L000995:
	dec	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L000994:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	EAX,EAX
	jz	OFFSET $L000996

;{42}:result*= x + a[i];
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	lea	EAX,dword ptr [EBX]
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0008h]
	mov	ECX,EAX
	mov	EAX,dword ptr [ESI+ECX*0004h] 
	pop	EDX
	add	EAX,EDX
	imul	dword ptr [EBP-0004h]
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000995 
$L000996:

;{43}:return result
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000522
;}
$L000522:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_SummationSeries_Horner_Horner ENDP

UnitTesting_SummationSeries_SimpleSum PROC NEAR 
;signed UnitTesting::SummationSeries::SimpleSum(signed n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{11}:result= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{12}:for(i= 1; i <= n; ++i)
	mov	EAX,000000001h
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L000997
$L000998:
	inc	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L000997:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	EAX,EAX
	jz	OFFSET $L000999

;{13}:result+= i;
	mov	EAX,dword ptr [EBP-0008h]
	clc	
	add	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000998 
$L000999:

;{15}:return result
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_SummationSeries_SimpleSum ENDP

UnitTesting_TestArrays_get_Name PROC NEAR 
;string get::Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{474}:return name
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	jmp	OFFSET $L000828
;}
$L000828:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestArrays_get_Name ENDP

UnitTesting_TestArrays_put_Name PROC NEAR 
;void put::Name(string value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{478}:name= value;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX]
	mov	dword ptr [EBX],EAX
;}
$L000829:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestArrays_put_Name ENDP

UnitTesting_TestArrays PROC NEAR 
;void UnitTesting::TestArrays(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestArrays ENDP

UnitTesting_TestArrays_DoTest PROC NEAR 
;void UnitTesting::TestArrays::DoTest(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,0000001C0h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-01BCh]
	mov	ECX,00000006Fh
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{506}:array2;
	lea	EAX,dword ptr [EBP-00C0h]

;{508}:array2[0].Width= 100;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	push	ECX
	mov	EAX,000000064h
	pop	ECX
	push	EAX
	call	OFFSET UnitTesting_TestIntegers_put_Width

;{509}:array2[0].Height= 200;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	push	ECX
	mov	EAX,0000000C8h
	pop	ECX
	push	EAX
	call	OFFSET UnitTesting_TestIntegers_put_Height

;{511}:nArea= array2[0].Width;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	call	 UnitTesting_TestIntegers_get_Width
	cdq	
	mov	dword ptr [EBP-00C8h],EDX
	mov	dword ptr [EBP-00C4h],EAX 

;{513}:nArea= array2[0].Width * array2[0].Height;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-00C8h],EDX
	mov	dword ptr [EBP-00C4h],EAX 

;{515}:array2[0].member1= Math::pi();
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	lea	EAX,dword ptr [ECX+0008h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{516}:array2[0].member1= Math::log_e_base2();
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	lea	EAX,dword ptr [ECX+0008h]
	push	EAX
	call	 Math_log_e_base2
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{519}:array2[1].Width= 100;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000001h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	push	ECX
	mov	EAX,000000064h
	pop	ECX
	push	EAX
	call	OFFSET UnitTesting_TestIntegers_put_Width

;{520}:array2[1].Height= 200;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000001h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	push	ECX
	mov	EAX,0000000C8h
	pop	ECX
	push	EAX
	call	OFFSET UnitTesting_TestIntegers_put_Height

;{522}:nArea= array2[1].Width * array2[1].Height;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000001h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000001h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-00C8h],EDX
	mov	dword ptr [EBP-00C4h],EAX 

;{524}:array2[2].Width= 100;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	push	ECX
	mov	EAX,000000064h
	pop	ECX
	push	EAX
	call	OFFSET UnitTesting_TestIntegers_put_Width

;{525}:array2[2].Height= 200;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	push	ECX
	mov	EAX,0000000C8h
	pop	ECX
	push	EAX
	call	OFFSET UnitTesting_TestIntegers_put_Height

;{527}:nArea= array2[2].Width * array2[2].Height;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-00C8h],EDX
	mov	dword ptr [EBP-00C4h],EAX 

;{530}:array2[3].my_array1[0]= 9.99;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	lea	EAX,dword ptr [EAX+0018h] ;array data member as element on an object
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0008h]
	push	EAX
	mov	EDX,047AE147Bh
	mov	EAX,04023FAE1h 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{531}:array2[3].my_array2[0]= FloatingPoint::ToInt(9.99);
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	imul	ECX,000000030h
	lea	EAX,dword ptr [ESI+ECX]
	mov	ECX,EAX 
	lea	EAX,dword ptr [EAX+0028h] ;array data member as element on an object
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	mov	EDX,047AE147Bh
	mov	EAX,04023FAE1h 
	push	EAX
	push	EDX 
	call	 FloatingPoint_ToInt
	pop	EBX
	mov	dword ptr [EBX],EAX

;{533}:name= "Harold L. Marzan";
	lea	EAX,OFFSET $S000845
	mov	dword ptr [EBP-00CCh],EAX

;{534}:UnitTesting::TestArrays::printChars(name, StringHandling::StringLength(name));
	mov	EAX,dword ptr [EBP-00CCh]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	mov	EAX,dword ptr [EBP-00CCh]
	push	EAX
	call	 UnitTesting_TestArrays_printChars

;{536}:my_name_is;
	lea	EAX,dword ptr [EBP-00E0h]

;{538}:my_name_is[0]= 'H';
	lea	EAX,dword ptr [EBP-00E0h]
	mov	ESI,EAX
	xor	EAX,EAX
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0001h]
	push	EAX
	mov	EAX,000000048h
	pop	EBX
	mov	byte ptr [EBX],AL

;{539}:my_name_is[1]= 'a';
	lea	EAX,dword ptr [EBP-00E0h]
	mov	ESI,EAX
	mov	EAX,000000001h
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0001h]
	push	EAX
	mov	EAX,000000061h
	pop	EBX
	mov	byte ptr [EBX],AL

;{540}:my_name_is[2]= 'r';
	lea	EAX,dword ptr [EBP-00E0h]
	mov	ESI,EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0001h]
	push	EAX
	mov	EAX,000000072h
	pop	EBX
	mov	byte ptr [EBX],AL

;{541}:my_name_is[3]= 'o';
	lea	EAX,dword ptr [EBP-00E0h]
	mov	ESI,EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0001h]
	push	EAX
	mov	EAX,00000006Fh
	pop	EBX
	mov	byte ptr [EBX],AL

;{542}:my_name_is[4]= 'l';
	lea	EAX,dword ptr [EBP-00E0h]
	mov	ESI,EAX
	mov	EAX,000000004h
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0001h]
	push	EAX
	mov	EAX,00000006Ch
	pop	EBX
	mov	byte ptr [EBX],AL

;{543}:my_name_is[5]= 'd';
	lea	EAX,dword ptr [EBP-00E0h]
	mov	ESI,EAX
	mov	EAX,000000005h
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0001h]
	push	EAX
	mov	EAX,000000064h
	pop	EBX
	mov	byte ptr [EBX],AL

;{544}:my_name_is[6]= ' ';
	lea	EAX,dword ptr [EBP-00E0h]
	mov	ESI,EAX
	mov	EAX,000000006h
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0001h]
	push	EAX
	mov	EAX,000000000h
	pop	EBX
	mov	byte ptr [EBX],AL

;{546}:Console::WriteLn("My name is :", my_name_is);
	lea	EAX,OFFSET $S000854
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	EAX,dword ptr [EBP-00E0h]
	push	000000014h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{548}:UnitTesting::TestArrays::printChars(my_name_is, StringHandling::StringLength(my_name_is));
	lea	EAX,dword ptr [EBP-00E0h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	lea	EAX,dword ptr [EBP-00E0h]
	push	EAX
	call	 UnitTesting_TestArrays_printChars

;{550}:arr;
	lea	EAX,dword ptr [EBP-01A8h]

;{552}:UnitTesting::TestArrays::printChars(arr[9], StringHandling::StringLength(arr[9]));
	lea	EAX,dword ptr [EBP-01A8h]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,000000009h
	mov	ECX,000000014h
	imul	ECX
	pop	ECX
	add	ECX,EAX
	mov	EAX,dword ptr [ESI+ECX*0001h] 
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 

	lea	EAX,dword ptr [EBP-01A8h]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,000000009h
	mov	ECX,000000014h
	imul	ECX
	pop	ECX
	add	ECX,EAX
	mov	EAX,dword ptr [ESI+ECX*0001h] 
	push	EAX
	call	 UnitTesting_TestArrays_printChars

;{554}:arr_of_strings;
	lea	EAX,dword ptr [EBP-01B8h]

;{556}:arr_of_strings[0]= "Harold ";
	lea	EAX,dword ptr [EBP-01B8h]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	xor	EAX,EAX
	pop	ECX
	add	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	lea	EAX,OFFSET $S000857
	pop	EBX
	mov	dword ptr [EBX],EAX

;{557}:arr_of_strings[1]= "Lawrence ";
	lea	EAX,dword ptr [EBP-01B8h]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,000000001h
	pop	ECX
	add	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	lea	EAX,OFFSET $S000858
	pop	EBX
	mov	dword ptr [EBX],EAX

;{558}:arr_of_strings[2]= "Marzan ";
	lea	EAX,dword ptr [EBP-01B8h]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,000000002h
	pop	ECX
	add	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	lea	EAX,OFFSET $S000859
	pop	EBX
	mov	dword ptr [EBX],EAX

;{559}:arr_of_strings[3]= "Mercado.";
	lea	EAX,dword ptr [EBP-01B8h]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,000000003h
	pop	ECX
	add	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	lea	EAX,OFFSET $S000860
	pop	EBX
	mov	dword ptr [EBX],EAX

;{561}:for(i= 0; i < 4; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-01BCh],EAX
	jmp	OFFSET $L001001
$L001002:
	inc	dword ptr [EBP-444]
	mov	EAX,dword ptr [EBP-444]
$L001001:
	mov	EAX,dword ptr [EBP-01BCh]
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	EAX,EAX
	jz	OFFSET $L001003
;{

;{563}:UnitTesting::TestArrays::printChars(arr_of_strings[i], StringHandling::StringLength(arr_of_strings[i]));
	lea	EAX,dword ptr [EBP-01B8h]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,dword ptr [EBP-01BCh]
	pop	ECX
	add	ECX,EAX
	mov	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 

	lea	EAX,dword ptr [EBP-01B8h]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,dword ptr [EBP-01BCh]
	pop	ECX
	add	ECX,EAX
	mov	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	call	 UnitTesting_TestArrays_printChars
;}
	jmp	OFFSET $L001002 
$L001003:

;{566}:StringHandling::StringCopy(my_name_is, name, StringHandling::StringLength(name));
	mov	EAX,dword ptr [EBP-00CCh]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	mov	EAX,dword ptr [EBP-00CCh]
	push	EAX
	lea	EAX,dword ptr [EBP-00E0h]
	push	EAX
	call	 StringHandling_StringCopy

;{567}:UnitTesting::TestArrays::printChars(my_name_is, StringHandling::StringLength(my_name_is));
	lea	EAX,dword ptr [EBP-00E0h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	lea	EAX,dword ptr [EBP-00E0h]
	push	EAX
	call	 UnitTesting_TestArrays_printChars
;}
$L000839:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestArrays_DoTest ENDP

UnitTesting_TestArrays_printChars PROC NEAR 
;void UnitTesting::TestArrays::printChars(char [] array, int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;try
	push	ESP ;pPrevESP
	push	EBP ;pPrevEBP
	push	OFFSET __except_handlerXXX001005 
	assume FS:nothing
	push	dword ptr  FS:[0] 
	mov	dword ptr  FS:[0],ESP

;{487}:for(i= 0; i < n; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001008
$L001009:
	inc	dword ptr [EBP-4]
	mov	EAX,dword ptr [EBP-4]
$L001008:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	EAX,EAX
	jz	OFFSET $L001010

;{488}:Console::WriteLn("Char at i:[", i, "] == ", array[i]);
	lea	EAX,OFFSET $S000835
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000836
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EBX,dword ptr [EBP+0008h]
	lea	EAX,dword ptr [EBX]
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0004h]
	mov	ECX,EAX
	mov	EAX,dword ptr [ESI+ECX*0001h] 
	push	EAX 
	call	 Console_WriteChar 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001009 
$L001010:
;{

;{491}:Console::WriteLn("Oops! there was a bug in this code!");
	lea	EAX,OFFSET $S000837
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
;}
	jmp	OFFSET $L001004
__except_handlerXXX001005:
	mov	EBX,dword ptr [ESP+0004h] ;_ExceptionRecord
	mov	ECX,dword ptr [EBX] ;_ExceptionRecord->ExceptionCode // The reason the exception occurred.
	mov	EBX,dword ptr  FS:[0] 
	mov	ESP,dword ptr [EBX] 
	pop	dword ptr  FS:[0]
	mov	EBP,dword ptr [ESP+0004h] ;the prev EBP
	mov	ESP,dword ptr [ESP+0008h] ;the prev ESP
	mov	EAX,000000001h
	cmp	EAX,ECX
	jnz	OFFSET $L001011

;{495}:Console::WriteLn("Oops! there was a serious bug in this code!");
	lea	EAX,OFFSET $S000838
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001007 
$L001011:
	mov	EAX,000000002h
	cmp	EAX,ECX 
	jnz	OFFSET $L001012 

;{499}:Console::WriteLn("Oops! there was a serious bug in this code!");
	lea	EAX,OFFSET $S000838
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001007 
$L001012:
	jmp	OFFSET $L001007 
$L001004:
	mov	EBX,dword ptr  FS:[0] 
	mov	ESP,dword ptr [EBX] 
	pop	dword ptr  FS:[0] 
	mov	EBP,dword ptr [ESP+0004h] ;the prev EBP
	mov	ESP,dword ptr [ESP+0008h] ;the prev ESP
$L001007:
;}
$L000831:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestArrays_printChars ENDP

UnitTesting_TestFloatingPoint_Area PROC NEAR 
;double Area(double minor_base, double major_base, double height);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{459}:area= ((minor_base + major_base) * height) / 2.0;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBP+0014h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0018h]
	mov	EAX,dword ptr [EBP+001Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,000000000h
	mov	EAX,040000000h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{461}:return area
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L000820
;}
$L000820:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000018h
UnitTesting_TestFloatingPoint_Area ENDP

UnitTesting_TestFloatingPoint_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{438}:System::Debug::OutputString("destroying a TestFloatingPoint() object...");
	lea	EAX,OFFSET $S000813
	push	EAX
	call	 System_Debug_OutputString
;}
$L000812:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestFloatingPoint_Destructor ENDP

UnitTesting_TestFloatingPoint_Power PROC NEAR 
;double Power(double X, int n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{442}:if(n == 0)
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001013

;{443}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L000814
$L001013:

;{445}:if(n % 2 == 0)
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001015

;{446}:return Power(X * X, n / 2)

	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	push	EAX

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]

	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestFloatingPoint_Power
	jmp	OFFSET $L000814

; else {
$L001015:

;{448}:return X * Power(X * X, n / 2)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 

	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	push	EAX

	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]

	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestFloatingPoint_Power
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000814
$L001016:

; }
;}
$L000814:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestFloatingPoint_Power ENDP

UnitTesting_TestFloatingPoint PROC NEAR 
;void UnitTesting::TestFloatingPoint(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{433}:System::Debug::OutputString("constructing a TestFloatingPoint() object...");
	lea	EAX,OFFSET $S000811
	push	EAX
	call	 System_Debug_OutputString
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestFloatingPoint ENDP

UnitTesting_TestFloatingPoint_speed PROC NEAR 
;double UnitTesting::TestFloatingPoint::speed(double distance, double time);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{454}:return distance / time
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBP+0014h] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000817
;}
$L000817:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000010h
UnitTesting_TestFloatingPoint_speed ENDP

UnitTesting_TestIntegers_Calc1 PROC NEAR 
;int Calc1(int i, int ref j);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{327}:nArea= j * Height;
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,dword ptr [EBX]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-0004h],EAX

;{329}:j= Width;
	mov	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_TestIntegers_get_Width
	mov	EBX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBX],EAX

;{331}:j= i div 5;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000005h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EBX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBX],EAX

;{333}:nArea= FloatingPoint::ToInt(j * Height * 1.0);

	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,dword ptr [EBX]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	push	EDX 
	fld1
	fclex
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fistp	qword ptr [ESP]
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 

	call	 FloatingPoint_ToInt
	mov	dword ptr [EBP-0004h],EAX

;{336}:j*= 3;
	mov	EAX,000000003h
	mov	EBX,dword ptr [EBP+000Ch]
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX

;{338}:return nArea
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000750
;}
$L000750:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_Calc1 ENDP

UnitTesting_TestIntegers_Calc2 PROC NEAR 
;void Calc2(Int32 ref x, Int32 ref y);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{350}:a= 1000;
	mov	EAX,0000003E8h
	mov	dword ptr [EBP-0004h],EAX

;{351}:x= 9 * 3 * a;
	mov	EAX,000000009h
	push	EAX
	mov	EAX,000000003h
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ECX 
	cdq	
	imul	EAX,ECX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	dword ptr [EBX],EAX

;{352}:y= a * 4 * 5;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000004h
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	push	EAX
	mov	EAX,000000005h
	pop	ECX 
	xor	EDX,EDX 
	imul	AX,CX 
	shl	EDX,000000010h 
	or	EAX,EDX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBX],EAX
;}
$L000758:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_Calc2 ENDP

UnitTesting_TestIntegers_Factorial PROC NEAR 
;int Factorial(int n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{407}:System::Debug::BreakPoint();
	int	000000003h ;User breakpoint

;{409}:if(n == 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001017

;{410}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L000799

; else {
$L001017:

;{412}:return n * Factorial(n - 1)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestIntegers_Factorial
	pop	ECX
	cdq	
	imul	EAX,ECX
	jmp	OFFSET $L000799
$L001018:

; }
;}
$L000799:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestIntegers_Factorial ENDP

UnitTesting_TestIntegers_get_Height PROC NEAR 
;int get::Height(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{103}:return nHeight
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	jmp	OFFSET $L000685
;}
$L000685:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_get_Height ENDP

UnitTesting_TestIntegers_put_Height PROC NEAR 
;void put::Height(int value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{108}:nHeight= value;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	mov	dword ptr [EBX],EAX
;}
$L000686:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestIntegers_put_Height ENDP

UnitTesting_TestIntegers_Swap PROC NEAR 
;void Swap(int ref value1, int ref value2);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{343}:tmp= value1;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBX]
	mov	dword ptr [EBP-0004h],EAX

;{344}:value1= value2;
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,dword ptr [EBX]
	mov	EBX,dword ptr [EBP+0008h]
	mov	dword ptr [EBX],EAX

;{345}:value2= tmp;
	mov	EAX,dword ptr [EBP-0004h]
	mov	EBX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBX],EAX
;}
$L000754:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_Swap ENDP

UnitTesting_TestIntegers_SwapDebug PROC NEAR 
;void SwapDebug(int ref value1, int ref value2);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{417}:System::Debug::OutputString("Swaping values...");
	lea	EAX,OFFSET $S000804
	push	EAX
	call	 System_Debug_OutputString

;{418}:Swap(value1, value2);
	push	dword ptr [EBP+000Ch]
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestIntegers_Swap
;}
$L000801:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_SwapDebug ENDP

UnitTesting_TestIntegers_get_Width PROC NEAR 
;int get::Width(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{93}:return nWidth
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	jmp	OFFSET $L000681
;}
$L000681:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_get_Width ENDP

UnitTesting_TestIntegers_put_Width PROC NEAR 
;void put::Width(int value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{98}:nWidth= value;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX]
	mov	dword ptr [EBX],EAX
;}
$L000682:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestIntegers_put_Width ENDP

UnitTesting_TestIntegers_add PROC NEAR 
;void add(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{358}:res= v1 + v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	add	EAX,EDX
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{360}:Console::WriteLn("(+) the result is: ", res);
	lea	EAX,OFFSET $S000767
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000763:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_add ENDP

UnitTesting_TestIntegers_divide PROC NEAR 
;void divide(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{379}:res= v1 div v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{381}:Console::WriteLn("(div) the result is: ", res);
	lea	EAX,OFFSET $S000782
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000778:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_divide ENDP

UnitTesting_TestIntegers_divide2 PROC NEAR 
;void divide2(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{393}:res= Math::Round(v1 / v2);

	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_Round
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{395}:Console::WriteLn("(round(/)) the result is: ", res);
	lea	EAX,OFFSET $S000792
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000788:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_divide2 ENDP

UnitTesting_TestIntegers_getArea PROC NEAR 
;int getArea(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{113}:return Width * Height
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	jmp	OFFSET $L000688
;}
$L000688:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_getArea ENDP

UnitTesting_TestIntegers_getArea2 PROC NEAR 
;double getArea2(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{118}:return nWidth * nHeight * 1.0
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	push	EDX 
	fld1
	fclex
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fistp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000689
;}
$L000689:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_getArea2 ENDP

UnitTesting_TestIntegers_modulus PROC NEAR 
;void modulus(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{386}:res= v1 % v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{388}:Console::WriteLn("(mod) the result is: ", res);
	lea	EAX,OFFSET $S000787
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000783:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_modulus ENDP

UnitTesting_TestIntegers_multiple_assignments PROC NEAR 
;void multiple_assignments(int ref param1, int param2);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{400}:local= param2= param1= (0x400 * 1024) / 0x10;
	mov	EAX,000000400h
	push	EAX
	mov	EAX,000000400h
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	push	EAX
	mov	EAX,000000010h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBP+000Ch],EAX
	mov	dword ptr [EBP-0004h],EAX

;{402}:what= (local == 0x10000);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000010000h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0008h],AL
;}
$L000793:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_multiple_assignments ENDP

UnitTesting_TestIntegers_multiply PROC NEAR 
;void multiply(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{372}:res= v1 * v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{374}:Console::WriteLn("(*) the result is: ", res);
	lea	EAX,OFFSET $S000777
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000773:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_multiply ENDP

UnitTesting_TestIntegers_subs PROC NEAR 
;void subs(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{365}:res= v1 - v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{367}:Console::WriteLn("(-) the result is: ", res);
	lea	EAX,OFFSET $S000772
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000768:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_subs ENDP

UnitTesting_TestIntegers PROC NEAR 
;void UnitTesting::TestIntegers(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 __member_Init@UnitTesting_TestIntegers

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers ENDP

UnitTesting_TestIntegers_TestExpressions PROC NEAR 
;void UnitTesting::TestIntegers::TestExpressions(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000080h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-007Ch]
	mov	ECX,00000001Fh
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{125}:hex_value= 0xDEADC0DEh;
	mov	EAX,0DEADC0DEh
	mov	dword ptr [EBP-0004h],EAX

;{127}:hex_value= hex_value << 0x10;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000010h
	mov	CL,AL
	pop	EAX
	shl	EAX,CL
	mov	dword ptr [EBP-0004h],EAX

;{129}:hex_value= hex_value >> 8;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000008h
	mov	CL,AL
	pop	EAX
	shr	EAX,CL
	mov	dword ptr [EBP-0004h],EAX

;{131}:hex_value= hex_value >> 8;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000008h
	mov	CL,AL
	pop	EAX
	shr	EAX,CL
	mov	dword ptr [EBP-0004h],EAX

;{134}:j= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX

;{136}:what= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-000Ch],AL

;{145}:hex_value= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{147}:while(true)
$L001020:
	mov	EAX,000000001h
	test	EAX,EAX
	jz	OFFSET $L001021
;{

;{149}:j= (4 + (--j)) % 4;
	mov	EAX,000000004h
	push	EAX
	dec	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000004h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-0008h],EAX

;{151}:if(++hex_value < 12)
	inc	dword ptr [EBP-4]
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	mov	EAX,00000000Ch
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001022

;continue;
	jmp	OFFSET $L001020
$L001022:

;{154}:what= (j % 2) == 0;
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;break;
	jmp	OFFSET $L001021
;}
	jmp	OFFSET $L001020
$L001021:

;{159}:what= j == 3;
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000003h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;do
$L001024:
;{

;{162}:j= (4 + (--j)) % 4;
	mov	EAX,000000004h
	push	EAX
	dec	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000004h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-0008h],EAX

;{164}:if(j == 0)
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001027

;break;
	jmp	OFFSET $L001026
$L001027:
;}
$L001025:

;{165}:while(j > 0)
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	EAX,EAX
	jne	OFFSET $L001024
$L001026:

;{169}:x= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX

;{171}:y= 1, z= 2;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0014h],EAX
	mov	EAX,000000002h
	mov	dword ptr [EBP-0018h],EAX

;{173}:result= (y + 1) * z;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,dword ptr [EBP-0018h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-001Ch],EAX

;{175}:x++ ;
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]

;{176}:++x;
	inc	dword ptr [EBP-16]
	mov	EAX,dword ptr [EBP-16]

;{178}:x+= 14;
	mov	EAX,00000000Eh
	clc	
	add	dword ptr [EBP-0010h],EAX

;{180}:what= x == 0x10h;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000010h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{182}:x/= 4;
	mov	EAX,000000004h
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBP-0010h],EAX 
	pop	ECX

;{184}:--x;
	dec	dword ptr [EBP-16]
	mov	EAX,dword ptr [EBP-16]

;{185}:x-- ;
	mov	EAX,dword ptr [EBP-16]
	dec	dword ptr [EBP-16]

;{187}:x= 7 % x;
	mov	EAX,000000007h
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-0010h],EAX

;{189}:what= x == 1;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{191}:x++ ;
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]

;{193}:x*= 10;
	mov	EAX,00000000Ah
	imul	dword ptr [EBP-0010h]
	mov	dword ptr [EBP-0010h],EAX

;{195}:x/= 5;
	mov	EAX,000000005h
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBP-0010h],EAX 
	pop	ECX

;{197}:x/= 4;
	mov	EAX,000000004h
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBP-0010h],EAX 
	pop	ECX

;{199}:x%= 4;
	mov	EAX,000000004h
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBP-0010h],EDX 
	pop	ECX

;{201}:y= 0x400h;
	mov	EAX,000000400h
	mov	dword ptr [EBP-0014h],EAX

;{203}:x= y div 15;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,00000000Fh
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0010h],EAX

;{205}:what= x == 68;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000044h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{207}:z= 0x10;
	mov	EAX,000000010h
	mov	dword ptr [EBP-0018h],EAX

;{209}:x= y * z;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBP-0018h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-0010h],EAX

;{211}:what= x == 0x400;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000400h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{213}:y= z= x;
	mov	EAX,dword ptr [EBP-0010h]
	mov	dword ptr [EBP-0018h],EAX
	mov	dword ptr [EBP-0014h],EAX

;{215}:x= y div 4;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000004h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0010h],EAX

;{217}:what= x == 4096;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000001000h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{219}:z= x % 3;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-0018h],EAX

;{221}:what= x == 1;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{223}:y= x div 3;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0014h],EAX

;{225}:what= x == 1365;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000555h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{227}:result= FloatingPoint::ToInt(x / 3);

	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000003h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 FloatingPoint_ToInt
	mov	dword ptr [EBP-001Ch],EAX

;{229}:result= x / (3 + 1);
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000003h
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	mov	dword ptr [EBP-001Ch],EAX

;{231}:what= (result == 1024);
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,000000400h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{233}:a= 20000, b= 4, c= 10;
	mov	EAX,000004E20h
	mov	word ptr [EBP-0020h],AX
	mov	EAX,000000004h
	mov	word ptr [EBP-0024h],AX
	mov	EAX,00000000Ah
	mov	word ptr [EBP-0028h],AX

;{235}:result= a * b * c;
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0020h]
	push	EAX
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0024h]
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	push	EAX
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0028h]
	pop	ECX 
	xor	EDX,EDX 
	imul	AX,CX 
	shl	EDX,000000010h 
	or	EAX,EDX 
	mov	dword ptr [EBP-001Ch],EAX

;{237}:what= result == 0xC3500h;
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,0000C3500h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{239}:result/= 0x10;
	mov	EAX,000000010h
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBP-001Ch],EAX 
	pop	ECX

;{241}:what= (result == 50000);
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,00000C350h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{243}:x= result % 3;
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-0010h],EAX

;{245}:result= Math::Round(a / 3) * 4;

	xor	EAX,EAX
	mov	AX,word ptr [EBP-0020h]
	push	EAX
	mov	EAX,000000003h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_Round
	push	EAX
	mov	EAX,000000004h
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	mov	dword ptr [EBP-001Ch],EAX

;{247}:what= (result == 33335);
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,000008237h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{249}:a= 1;
	mov	EAX,000000001h
	mov	word ptr [EBP-0020h],AX

;{249}:b= 4;
	mov	EAX,000000004h
	mov	word ptr [EBP-0024h],AX

;{249}:c= 4;
	mov	EAX,000000004h
	mov	word ptr [EBP-0028h],AX

;{251}:disc= Math::Sqr(b) - 4 * a * c;
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0024h]
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 Math_Sqr
	push	EAX
	push	EDX 
	mov	EAX,000000004h
	push	EAX
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0020h]
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	push	EAX
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0028h]
	pop	ECX 
	xor	EDX,EDX 
	imul	AX,CX 
	shl	EDX,000000010h 
	or	EAX,EDX 
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0030h]

;{253}:what= disc == 0.0;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0030h]
	mov	EAX,dword ptr [EBP-002Ch] 
	push	EAX
	push	EDX 
	fldz
	push	ECX
	push	ECX 
	fstp	qword ptr [ESP]
	call	 FloatingPoint_Compare
	test	EAX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{255}:x1= -b + Math::Sqrt(disc) / 2 * a;
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0024h]
	neg	EAX
	push	EAX
	mov	EDX,dword ptr [EBP-0030h]
	mov	EAX,dword ptr [EBP-002Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0020h]
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX 
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0038h]

;{256}:what= x1 == -2.0;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0038h]
	mov	EAX,dword ptr [EBP-0034h] 
	push	EAX
	push	EDX 
	mov	EDX,000000000h
	mov	EAX,040000000h 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 FloatingPoint_Compare
	test	EAX,EAX
	setz	AL
	pop	EDX
	pop	EAX 
	mov	byte ptr [EBP-000Ch],AL

;{258}:x2= -b - Math::Sqrt(disc) / 2 * a;
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0024h]
	neg	EAX
	push	EAX
	mov	EDX,dword ptr [EBP-0030h]
	mov	EAX,dword ptr [EBP-002Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0020h]
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX 
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0040h]

;{259}:what= x2 == -2.0;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0040h]
	mov	EAX,dword ptr [EBP-003Ch] 
	push	EAX
	push	EDX 
	mov	EDX,000000000h
	mov	EAX,040000000h 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 FloatingPoint_Compare
	test	EAX,EAX
	setz	AL
	pop	EDX
	pop	EAX 
	mov	byte ptr [EBP-000Ch],AL

;{261}:x= 1;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0010h],EAX

;{262}:Console::WriteLn("the value of x is: ", x);
	lea	EAX,OFFSET $S000727
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{264}:++x;
	inc	dword ptr [EBP-16]
	mov	EAX,dword ptr [EBP-16]

;{265}:Console::WriteLn("the value of x is: ", x);
	lea	EAX,OFFSET $S000727
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{267}:--x;
	dec	dword ptr [EBP-16]
	mov	EAX,dword ptr [EBP-16]

;{268}:Console::WriteLn("the value of x is: ", x);
	lea	EAX,OFFSET $S000727
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{270}:Console::WriteLn("the value of x is: ", x++ );
	lea	EAX,OFFSET $S000727
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{272}:Console::WriteLn("the value of x is: ", x-- );
	lea	EAX,OFFSET $S000727
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-16]
	dec	dword ptr [EBP-16]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{274}:Console::WriteLn("the value is: ", x++ -4 / (-1));
	lea	EAX,OFFSET $S000728
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
	push	EAX
	mov	EAX,000000004h
	push	EAX
	mov	EAX,000000001h
	neg	EAX
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{276}:Console::WriteLn("the value is: ", --x - 4 / (-1));
	lea	EAX,OFFSET $S000728
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	dec	dword ptr [EBP-16]
	mov	EAX,dword ptr [EBP-16]
	push	EAX
	mov	EAX,000000004h
	push	EAX
	mov	EAX,000000001h
	neg	EAX
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{278}:Console::WriteLn("the value is: ", (x++ -4) / (-1));
	lea	EAX,OFFSET $S000728
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	neg	EAX
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{280}:Console::WriteLn("the value is: ", (--x - 4) / (-1));
	lea	EAX,OFFSET $S000728
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	dec	dword ptr [EBP-16]
	mov	EAX,dword ptr [EBP-16]
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	neg	EAX
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{282}:x= UnitTesting::ten * 100;
	mov	EAX,00000000Ah
	xor	EDX,EDX
	push	EAX
	mov	EAX,000000064h
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	mov	dword ptr [EBP-0010h],EAX

;{284}:what= x == 1000;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,0000003E8h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{286}:what= UnitTesting::ten * 50 == 500;
	mov	EAX,00000000Ah
	xor	EDX,EDX
	push	EAX
	mov	EAX,000000032h
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	push	EAX
	mov	EAX,0000001F4h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-000Ch],AL

;{295}:UnitTesting::TestIntegers::bigValue*= 4;
	mov	EAX,000000004h
	cdq	
	lea	EBX,OFFSET UnitTesting_TestIntegers_bigValue
	push	EAX
	push	EDX 
	fild	qword ptr [ESP]
	fmul	qword ptr [EBX]
	fistp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	mov	dword ptr [EBX+4],EAX
	mov	dword ptr [EBX],EDX 

;{299}:alett= UnitTesting::misc1::alpha;
	mov	EAX,000000000h
	xor	EDX,EDX
	mov	dword ptr [EBP-0044h],EAX

;{301}:lundi= UnitTesting::misc1::monday, mardi= UnitTesting::misc1::tuesday;
	mov	EAX,000000001h
	xor	EDX,EDX
	mov	dword ptr [EBP-0048h],EAX
	mov	EAX,000000002h
	xor	EDX,EDX
	mov	dword ptr [EBP-004Ch],EAX

;{304}:length= 15, width= 10;
	mov	EAX,00000000Fh
	mov	dword ptr [EBP-0050h],EAX
	mov	EAX,00000000Ah
	mov	dword ptr [EBP-0054h],EAX

;{305}:area= length * width;
	mov	EAX,dword ptr [EBP-0050h]
	push	EAX
	mov	EAX,dword ptr [EBP-0054h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	push	EDX 
	fild	qword ptr [ESP]
	fstp	qword ptr [EBP-005Ch]

;{307}:radius, ;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0064h]
	mov	EAX,dword ptr [EBP-0060h] 

;{307}:circ;
	mov	EDX,dword ptr [EBP-006Ch]
	mov	EAX,dword ptr [EBP-0068h] 

;{309}:letter= 'x';
	mov	EAX,000000078h
	mov	byte ptr [EBP-0070h],AL

;{311}:darea= (length * width) * 0.9;
	mov	EAX,dword ptr [EBP-0050h]
	push	EAX
	mov	EAX,dword ptr [EBP-0054h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	push	EDX 
	mov	EDX,0CCCCCCCDh
	mov	EAX,03FECCCCCh 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt64
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fistp	qword ptr [ESP]
	fild	qword ptr [ESP]
	fstp	qword ptr [EBP-0078h]

;{313}:a= 2;
	pop	EDX
	pop	EAX 
	mov	EAX,000000002h
	mov	word ptr [EBP-0020h],AX

;{315}:ternary= 4 >= a ? 999 < 1000 && 1 > 0 : 777 == 77.7 * 10;
	mov	EAX,000000004h
	push	EAX
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	 $L001029
	mov	EAX,0000003E7h
	push	EAX
	mov	EAX,0000003E8h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	push	EAX
	mov	EAX,000000001h
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	pop	EDX
	and	EAX,EDX
	jmp	 $L001030
$L001029:
	mov	EAX,000000309h
	push	EAX
	mov	EDX,0CCCCCCCDh
	mov	EAX,040536CCCh 
	push	EAX
	push	EDX 
	mov	EAX,00000000Ah
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	test	EAX,EAX
	setz	AL
$L001030:
	pop	EDX
	pop	EAX 
	mov	byte ptr [EBP-007Ch],AL

;{315}:7 == 111;
	mov	EAX,000000007h
	push	EAX
	mov	EAX,00000006Fh
	pop	EDX
	cmp	EDX,EAX
	setz	AL

;{317}:ternary= (4 >= a) ? 999 > 1000 && 1 > 0 : 777 / 7 == 111;
	mov	EAX,000000004h
	push	EAX
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	 $L001031
	mov	EAX,0000003E7h
	push	EAX
	mov	EAX,0000003E8h
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	push	EAX
	mov	EAX,000000001h
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	pop	EDX
	and	EAX,EDX
	jmp	 $L001032
$L001031:
	mov	EAX,000000309h
	push	EAX
	mov	EAX,000000007h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,00000006Fh
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	test	EAX,EAX
	setz	AL
$L001032:
	pop	EDX
	pop	EAX 
	mov	byte ptr [EBP-007Ch],AL

;{319}:ternary= 4 < a ? 999 > 1000 && 1 > 0 : 777 / (3 + 4) == 111;
	mov	EAX,000000004h
	push	EAX
	xor	EAX,EAX
	mov	AX,word ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	 $L001033
	mov	EAX,0000003E7h
	push	EAX
	mov	EAX,0000003E8h
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	push	EAX
	mov	EAX,000000001h
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	pop	EDX
	and	EAX,EDX
	jmp	 $L001034
$L001033:
	mov	EAX,000000309h
	push	EAX
	mov	EAX,000000003h
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	add	EAX,EDX
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,00000006Fh
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	test	EAX,EAX
	setz	AL
$L001034:
	pop	EDX
	pop	EAX 
	mov	byte ptr [EBP-007Ch],AL

;{322}:return 
	jmp	OFFSET $L000692
;}
$L000692:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_TestExpressions ENDP

UnitTesting_TestSwitch_RunTest PROC NEAR 
;void UnitTesting::TestSwitch::RunTest(int option);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{14}:switch(option)
	mov	EAX,dword ptr [EBP+0008h]
	mov	ESI,EAX
	mov	EAX,000000001h
	xor	EDX,EDX
	cmp	EAX,ESI
	jz	OFFSET $L001036
	mov	EAX,000000002h
	xor	EDX,EDX
	cmp	EAX,ESI
	jz	OFFSET $L001037
	mov	EAX,000000003h
	xor	EDX,EDX
	cmp	EAX,ESI
	jz	OFFSET $L001038

	mov	EAX,000000004h
	xor	EDX,EDX
	cmp	EAX,ESI
	jz	OFFSET $L001039
	mov	EAX,000000005h
	cmp	EAX,ESI
	jz	OFFSET $L001040
	mov	EAX,000000006h
	cmp	EAX,ESI 
	jz	OFFSET $L001041 
	jmp	OFFSET $L001042
$L001036:

;{17}:Console::WriteLn("Opening file...");
	lea	EAX,OFFSET $S000564
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001035

$L001037:

;{20}:Console::WriteLn("Closing file...");
	lea	EAX,OFFSET $S000565
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001035

$L001038:

;{23}:Console::WriteLn("Do Write to file...");
	lea	EAX,OFFSET $S000566
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001035

$L001039:

;{26}:Console::WriteLn("Do Read from file...");
	lea	EAX,OFFSET $S000567
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001035

$L001040:

;{29}:Console::WriteLn("Do for 5 and follow to 6");
	lea	EAX,OFFSET $S000568
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

$L001041:
;{

;{32}:Console::WriteLn("Do 6, then finish");
	lea	EAX,OFFSET $S000570
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001035

$L001042:

;{36}:Console::WriteLn("Invalid Option : ", option);
	lea	EAX,OFFSET $S000571
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
$L001035:
;}
$L000562:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestSwitch_RunTest ENDP

UnitTesting_TestVirtuals_ExponentialRV_get_MU PROC NEAR 
;double get::MU(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{125}:return mu
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000501
;}
$L000501:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_ExponentialRV_get_MU ENDP

UnitTesting_TestVirtuals_ExponentialRV_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{138}:return "An exponential variable"
	lea	EAX,OFFSET $S000506
	jmp	OFFSET $L000505
;}
$L000505:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_ExponentialRV_Name ENDP

UnitTesting_TestVirtuals_ExponentialRV_Sample PROC NEAR 
;double Sample(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{134}:return -MU * Math::log10(UnitTesting::Rnd::NextDblEx())
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_ExponentialRV_get_MU
	push	EAX
	push	EDX 
	call	 UnitTesting_Rnd_NextDblEx
	push	EAX
	push	EDX 
	call	 Math_log10
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_ExponentialRV_Sample ENDP

UnitTesting_TestVirtuals_ExponentialRV PROC NEAR 
;void UnitTesting::TestVirtuals::ExponentialRV(double _mu);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_RandomVariable ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestVirtuals_ExponentialRV 
;{

;{130}:mu= _mu;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	fstp	qword ptr [EBX]
;}
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestVirtuals_ExponentialRV ENDP

UnitTesting_TestVirtuals_RandomVariable_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{62}:return "(none)"
	lea	EAX,OFFSET $S000473
	jmp	OFFSET $L000472
;}
$L000472:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_RandomVariable_Name ENDP

UnitTesting_TestVirtuals_RandomVariable PROC NEAR 
;void UnitTesting::TestVirtuals::RandomVariable(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestVirtuals_RandomVariable 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_RandomVariable ENDP

UnitTesting_TestVirtuals_SimpleRV_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{75}:return "A simple variable"
	lea	EAX,OFFSET $S000478
	jmp	OFFSET $L000477
;}
$L000477:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_SimpleRV_Name ENDP

UnitTesting_TestVirtuals_SimpleRV_Sample PROC NEAR 
;double Sample(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{70}:return UnitTesting::Rnd::NextDblEx()
	call	 UnitTesting_Rnd_NextDblEx
	jmp	OFFSET $L000476
;}
$L000476:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_SimpleRV_Sample ENDP

UnitTesting_TestVirtuals_SimpleRV PROC NEAR 
;void UnitTesting::TestVirtuals::SimpleRV(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_RandomVariable ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestVirtuals_SimpleRV 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_SimpleRV ENDP

UnitTesting_TestVirtuals_UniformRV_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{115}:return "An uniform variable"
	lea	EAX,OFFSET $S000496
	jmp	OFFSET $L000495
;}
$L000495:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_UniformRV_Name ENDP

UnitTesting_TestVirtuals_UniformRV_Sample PROC NEAR 
;double Sample(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{111}:return u + (v - u) * UnitTesting::Rnd::NextDblEx()
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0010h]
	mov	EDX,dword ptr [ECX+000Ch] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 UnitTesting_Rnd_NextDblEx
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_UniformRV_Sample ENDP

UnitTesting_TestVirtuals_UniformRV_get_U PROC NEAR 
;double get::U(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{86}:return u
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000484
;}
$L000484:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_UniformRV_get_U ENDP

UnitTesting_TestVirtuals_UniformRV_put_U PROC NEAR 
;void put::U(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{91}:u= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	fstp	qword ptr [EBX]
;}
$L000485:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestVirtuals_UniformRV_put_U ENDP

UnitTesting_TestVirtuals_UniformRV PROC NEAR 
;void UnitTesting::TestVirtuals::UniformRV(double _u, double _v);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_RandomVariable ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestVirtuals_UniformRV 
;{

;{106}:U= _u;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	call	OFFSET UnitTesting_TestVirtuals_UniformRV_put_U

;{106}:V= _v;
	mov	EDX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBP+0014h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	call	OFFSET UnitTesting_TestVirtuals_UniformRV_put_V
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000010h
UnitTesting_TestVirtuals_UniformRV ENDP

UnitTesting_TestVirtuals_UniformRV_get_V PROC NEAR 
;double get::V(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{96}:return v
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0010h]
	mov	EDX,dword ptr [ECX+000Ch] 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_UniformRV_get_V ENDP

UnitTesting_TestVirtuals_UniformRV_put_V PROC NEAR 
;void put::V(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{101}:v= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+000Ch]
	fstp	qword ptr [EBX]
;}
$L000489:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestVirtuals_UniformRV_put_V ENDP

UnitTesting_Triangle_get_Base PROC NEAR 
;double get::Base(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{147}:return dBase
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000620
;}
$L000620:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_get_Base ENDP

UnitTesting_Triangle_put_Base PROC NEAR 
;void put::Base(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{152}:dBase= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	fstp	qword ptr [EBX]
;}
$L000621:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Triangle_put_Base ENDP

UnitTesting_Triangle_ComputeArea PROC NEAR 
;double ComputeArea(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{181}:return Base * High / 2
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Triangle_get_Base
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Triangle_get_High
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX 
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000632
;}
$L000632:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_ComputeArea ENDP

UnitTesting_Triangle_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{186}:return 
	jmp	OFFSET $L000633
;}
$L000633:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_Destructor ENDP

UnitTesting_Triangle_Draw PROC NEAR 
;void Draw(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{175}:Console::WriteLn("Drawing a Triangle!");
	lea	EAX,OFFSET $S000631
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000630:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_Draw ENDP

UnitTesting_Triangle_get_High PROC NEAR 
;double get::High(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{157}:return dHigh
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0010h]
	mov	EDX,dword ptr [ECX+000Ch] 
	jmp	OFFSET $L000624
;}
$L000624:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_get_High ENDP

UnitTesting_Triangle_put_High PROC NEAR 
;void put::High(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{162}:dHigh= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+000Ch]
	fstp	qword ptr [EBX]
;}
$L000625:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Triangle_put_High ENDP

UnitTesting_Triangle_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{170}:return "Triangle"
	lea	EAX,OFFSET $S000629
	jmp	OFFSET $L000628
;}
$L000628:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_Name ENDP

UnitTesting_Triangle_Type PROC NEAR 
;UnitTesting::ShapeType Type(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{166}:return UnitTesting::stTriangle
	mov	EAX,000000003h
	xor	EDX,EDX
	jmp	OFFSET $L000627
;}
$L000627:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_Type ENDP

UnitTesting_Triangle PROC NEAR 
;void UnitTesting::Triangle(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Shape ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Triangle 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_Triangle 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle ENDP

__member_Init@UnitTesting_Circle PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{56}:radius= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	fstp	qword ptr [EBX]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Circle ENDP
__member_Init@UnitTesting_Square PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{95}:dWidth= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	fstp	qword ptr [EBX]

;{95}:dHeight= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+000Ch]
	fstp	qword ptr [EBX]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Square ENDP
__member_Init@UnitTesting_TestIntegers PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:nWidth= 0;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX]
	mov	dword ptr [EBX],EAX

;{0}:nHeight= 0;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	mov	dword ptr [EBX],EAX

;{118}:UnitTesting::TestIntegers::bigValue= 0x80000000h;
	mov	EAX,080000000h
	cdq	
	lea	EBX,OFFSET UnitTesting_TestIntegers_bigValue
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{418}:member1= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0008h]
	fstp	qword ptr [EBX]

;{418}:member2= 1.0;
	fld1
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0010h]
	fstp	qword ptr [EBX]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_TestIntegers ENDP
__member_Init@UnitTesting_Triangle PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{140}:dBase= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+0004h]
	fstp	qword ptr [EBX]

;{140}:dHigh= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	lea	EBX,dword ptr [ECX+000Ch]
	fstp	qword ptr [EBX]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Triangle ENDP
__User_Globals_Init PROC

	push	EBP
	mov	EBP,ESP
	push	EBX 
	push	ESI 
	push	EDI 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__User_Globals_Init ENDP

UnitTesting_Test1_TestRunner_main PROC 
;void UnitTesting::Test1::TestRunner::main(int argc, string [] argv);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000031Ch
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-031Ch]
	mov	ECX,0000000C7h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	call	 __User_Globals_Init
;{

;{577}:for(ac= 0; ac < argc; ac++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001046
$L001047:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L001046:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	EAX,EAX
	jz	OFFSET $L001048
;{

;{579}:Console::WriteLn("Argument: [", ac, "]= ", argv[ac]);
	lea	EAX,OFFSET $S000868
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000869
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EBX,dword ptr [EBP+000Ch]
	lea	EAX,dword ptr [EBX]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ECX
	add	ECX,EAX
	mov	EAX,dword ptr [ESI+ECX*0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001047 
$L001048:

;{581}:__HELLO_PART: hello();
__HELLO_PART:

;{582}:hello();
	lea	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_HelloWorld

;{584}:say= "Hello World from H++!!!";
	lea	EAX,OFFSET $S000873
	mov	dword ptr [EBP-000Ch],EAX

;{586}:hello.SayHello(say);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	lea	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_HelloWorld_SayHello

;{588}:hello.ShowHello(say);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	lea	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_HelloWorld_ShowHello

;{590}:tester1;
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers

;{592}:tester1.Width= 0x400h * 1024;
	mov	EAX,000000400h
	push	EAX
	mov	EAX,000000400h
	pop	ECX
	xor	EDX,EDX
	imul	AX,CX
	shl	EDX,000000010h
	or	EAX,EDX
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	OFFSET UnitTesting_TestIntegers_put_Width

;{593}:tester1.Height= 0x20h;
	mov	EAX,000000020h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	OFFSET UnitTesting_TestIntegers_put_Height

;{595}:nWidth= tester1.Width, nHeight= tester1.Height;
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_get_Width
	mov	dword ptr [EBP-0040h],EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_get_Height
	mov	dword ptr [EBP-0044h],EAX

;{598}:nArea= tester1.Width * tester1.Height;
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-004Ch],EDX
	mov	dword ptr [EBP-0048h],EAX 

;{600}:with(tester1)
;{
	mov	EAX,000000666h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	OFFSET UnitTesting_TestIntegers_put_Width
	mov	EAX,000000777h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	OFFSET UnitTesting_TestIntegers_put_Height
;}

;goto
	jmp	OFFSET __CALC_FACTORIAL
	int	000000003h ;User breakpoint

;{612}:nArea= nWidth * nHeight;
	mov	EAX,dword ptr [EBP-0040h]
	push	EAX
	mov	EAX,dword ptr [EBP-0044h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-004Ch],EDX
	mov	dword ptr [EBP-0048h],EAX 

;{614}:n= 7;
	mov	EAX,000000007h
	mov	dword ptr [EBP-0050h],EAX

;{616}:UnitTesting::Integers_Inline::Test();
	call	 UnitTesting_Integers_Inline_Test

;{618}:for(index= 0; index < 100; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0054h],EAX
	jmp	OFFSET $L001049
$L001050:
	mov	EAX,dword ptr [EBP-84]
	inc	dword ptr [EBP-84]
$L001049:
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	mov	EAX,000000064h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	EAX,EAX
	jz	OFFSET $L001051
;{

;{620}:Console::WriteLn("Current Index :", index);
	lea	EAX,OFFSET $S000884
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001050 
$L001051:

;{623}:for(; ; )
	jmp	OFFSET $L001052
$L001053:
$L001052:
;{

;{626}:if(--index == 0)
	dec	dword ptr [EBP-84]
	mov	EAX,dword ptr [EBP-84]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001055

;break;
	jmp	OFFSET $L001054
$L001055:
;}
	jmp	OFFSET $L001053 
$L001054:

;{630}:what= !(index == 0);
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	not	EAX
	mov	byte ptr [EBP-0058h],AL

;{632}:__CALC_FACTORIAL: nf= tester1.Factorial(n);
__CALC_FACTORIAL:

;{634}:nf= tester1.Factorial(n);
	mov	EAX,dword ptr [EBP-0050h]
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_Factorial
	mov	dword ptr [EBP-005Ch],EAX

;{636}:--n;
	dec	dword ptr [EBP-80]
	mov	EAX,dword ptr [EBP-80]

;{637}:if(n == 0)
	mov	EAX,dword ptr [EBP-0050h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001057

;goto
	jmp	OFFSET __END_FACTORIAL
$L001057:

;goto
	jmp	OFFSET __CALC_FACTORIAL

;{642}:__END_FACTORIAL: myRef1= 0;
__END_FACTORIAL:

;{645}:myRef1= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0060h],EAX

;{646}:myVar1= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0064h],EAX
	int	000000003h ;User breakpoint

;{650}:tester1.multiple_assignments(myRef1, myVar1);
	mov	EAX,dword ptr [EBP-0064h]
	push	EAX
	lea	EAX,dword ptr [EBP-0060h]
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_multiple_assignments

;{652}:Console::WriteLn("The value of myRef1 must be 65536 ==", myRef1);
	lea	EAX,OFFSET $S000890
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0060h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{653}:Console::WriteLn("The value of myVar1 is not 65536 but zero", myVar1);
	lea	EAX,OFFSET $S000891
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0064h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{655}:Console::WriteLn("(int)the area is: ", tester1.getArea());
	lea	EAX,OFFSET $S000892
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_getArea
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{656}:Console::WriteLn("(double)the area is: ", tester1.getArea2());
	lea	EAX,OFFSET $S000893
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_getArea2
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{658}:result= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0068h],EAX

;{659}:tester1.add(1024, 3072, result);
	lea	EAX,dword ptr [EBP-0068h]
	push	EAX
	mov	EAX,000000C00h
	push	EAX 
	mov	EAX,000000400h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_add

;{661}:tester1.subs(1024, 3072, result);
	lea	EAX,dword ptr [EBP-0068h]
	push	EAX
	mov	EAX,000000C00h
	push	EAX 
	mov	EAX,000000400h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_subs

;{663}:tester1.modulus(4096, 6, result);
	lea	EAX,dword ptr [EBP-0068h]
	push	EAX
	mov	EAX,000000006h
	push	EAX 
	mov	EAX,000001000h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_modulus

;{665}:tester1.multiply(3, 927, result);
	lea	EAX,dword ptr [EBP-0068h]
	push	EAX
	mov	EAX,00000039Fh
	push	EAX 
	mov	EAX,000000003h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_multiply

;{667}:tester1.divide(4096, 6, result);
	lea	EAX,dword ptr [EBP-0068h]
	push	EAX
	mov	EAX,000000006h
	push	EAX 
	mov	EAX,000001000h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_divide

;{669}:tester1.divide2(4096, 6, result);
	lea	EAX,dword ptr [EBP-0068h]
	push	EAX
	mov	EAX,000000006h
	push	EAX 
	mov	EAX,000001000h
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_divide2

;{672}:UnitTesting::TestIntegers::TestExpressions();
	call	 UnitTesting_TestIntegers_TestExpressions

;{674}:val1= 1, val2= 2;
	mov	EAX,000000001h
	mov	dword ptr [EBP-006Ch],EAX
	mov	EAX,000000002h
	mov	dword ptr [EBP-0070h],EAX

;{676}:what= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-0058h],AL

;{678}:tester1.Swap(val1, val2);
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_Swap

;{680}:what= val1 == 2 && val2 == 1;
	mov	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000000002h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	push	EAX
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	pop	EDX
	and	EAX,EDX
	mov	byte ptr [EBP-0058h],AL

;{682}:tester1.Calc2(val1, val2);
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_Calc2

;{684}:what= val1 == 27000 && val2 == 20000;
	mov	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000006978h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	push	EAX
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,000004E20h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	pop	EDX
	and	EAX,EDX
	mov	byte ptr [EBP-0058h],AL

;{686}:tester1.Swap(val1, val2);
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_Swap

;{688}:tester1.SwapDebug(val1, val2);
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_SwapDebug

;{690}:what= val1 == 20000 && val2 == 27000;
	mov	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000004E20h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	push	EAX
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,000006978h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	pop	EDX
	and	EAX,EDX
	mov	byte ptr [EBP-0058h],AL

;{692}:tester1.Calc1(val1, val2);
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,dword ptr [EBP-006Ch]
	push	EAX
	lea	ECX,dword ptr [EBP-003Ch]
	call	 UnitTesting_TestIntegers_Calc1

;{694}:what= val2 != 27000;
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,000006978h
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	mov	byte ptr [EBP-0058h],AL

;{696}:val1= val1 << 24;
	mov	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000000018h
	mov	CL,AL
	pop	EAX
	shl	EAX,CL
	mov	dword ptr [EBP-006Ch],EAX

;{698}:fpTester();
	lea	ECX,dword ptr [EBP-0074h]
	call	 UnitTesting_TestFloatingPoint

;{700}:_pow= fpTester.Power(2.0, 32);
	mov	EAX,000000020h
	push	EAX 
	mov	EDX,000000000h
	mov	EAX,040000000h 
	push	EAX
	push	EDX 
	lea	ECX,dword ptr [EBP-0074h]
	call	 UnitTesting_TestFloatingPoint_Power
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-007Ch]

;{702}:array1;
	pop	EDX
	pop	EAX 
	lea	EAX,dword ptr [EBP-020Ch]

;{704}:for(index= 0; index < sizeof (array1); )
	xor	EAX,EAX
	mov	dword ptr [EBP-0054h],EAX
	jmp	OFFSET $L001059
$L001060:
$L001059:
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	mov	EAX,000000190h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	EAX,EAX
	jz	OFFSET $L001061
;{

;{706}:array1[index]= FloatingPoint::ToInt((index + 1) * 9.45);
	lea	EAX,dword ptr [EBP-020Ch]
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0054h]
	mov	ECX,EAX
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX

	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EDX,066666667h
	mov	EAX,04022E666h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 FloatingPoint_ToInt
	pop	EBX
	mov	dword ptr [EBX],EAX

;{707}:index++ ;
	mov	EAX,dword ptr [EBP-84]
	inc	dword ptr [EBP-84]
;}
	jmp	OFFSET $L001060 
$L001061:

;{710}:UnitTesting::TestArrays::DoTest();
	call	 UnitTesting_TestArrays_DoTest

;{712}:rnd(Math::Round(0x400 * Math::log_10_base2() + 1.0));


	mov	EAX,000000400h
	push	EAX
	call	 Math_log_10_base2
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	dword ptr FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld1
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]

	call	 Math_Round
	push	EAX

	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd

;goto
	jmp	OFFSET _BlockRndDoubles

;{716}:Console::WriteLn("Pseudo-Random Integer values:");
	lea	EAX,OFFSET $S000908
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{717}:Console::WriteLn("(1)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S000909
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{718}:Console::WriteLn("(2)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S000910
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{719}:Console::WriteLn("(3)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S000911
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{720}:Console::WriteLn("(4)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S000912
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{721}:Console::WriteLn("(5)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S000913
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{722}:Console::WriteLn("(6)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S000914
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{724}:_BlockRndDoubles: Console::WriteLn("Pseudo-Random Double values:");
_BlockRndDoubles:

;{726}:Console::WriteLn("Pseudo-Random Double values:");
	lea	EAX,OFFSET $S000915
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{727}:Console::WriteLn("(1)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S000909
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{728}:Console::WriteLn("(2)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S000910
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{729}:Console::WriteLn("(3)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S000911
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{730}:Console::WriteLn("(4)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S000912
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{731}:Console::WriteLn("(5)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S000913
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{732}:Console::WriteLn("(6)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S000914
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0210h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{737}:res= 0.0;
	fldz
	fstp	qword ptr [EBP-0218h]

;{739}:srv;
	lea	ECX,dword ptr [EBP-021Ch]
	call	 UnitTesting_TestVirtuals_SimpleRV

;{741}:res= srv.Sample();
	lea	ECX,dword ptr [EBP-021Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{742}:Console::WriteLn("(1)A simple random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000918
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{743}:res= srv.Sample();
	lea	ECX,dword ptr [EBP-021Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{744}:Console::WriteLn("(2)A simple random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000920
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{745}:res= srv.Sample();
	lea	ECX,dword ptr [EBP-021Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{746}:Console::WriteLn("(3)A simple random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000921
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{747}:res= srv.Sample();
	lea	ECX,dword ptr [EBP-021Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{748}:Console::WriteLn("(4)A simple random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000922
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{749}:Console::WriteLn("my name is", srv.Name());
	lea	EAX,OFFSET $S000923
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-021Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{751}:res= 1.0;
	fld1
	fstp	qword ptr [EBP-0218h]

;{753}:urv(Math::log_e_base2(), Math::log_2_base_e());
	call	 Math_log_2_base_e
	push	EAX 
	push	EDX 
	call	 Math_log_e_base2
	push	EAX
	push	EDX 
	lea	ECX,dword ptr [EBP-0230h]
	call	 UnitTesting_TestVirtuals_UniformRV

;{755}:res= urv.Sample();
	lea	ECX,dword ptr [EBP-0230h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{756}:Console::WriteLn("(1)An uniform random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000925
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{757}:res= urv.Sample();
	lea	ECX,dword ptr [EBP-0230h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{758}:Console::WriteLn("(2)An uniform random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000926
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{759}:res= urv.Sample();
	lea	ECX,dword ptr [EBP-0230h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{760}:Console::WriteLn("(3)An uniform random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000927
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{761}:res= urv.Sample();
	lea	ECX,dword ptr [EBP-0230h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{762}:Console::WriteLn("(4)An uniform random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000928
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{763}:Console::WriteLn("my name is", urv.Name());
	lea	EAX,OFFSET $S000923
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0230h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{765}:res= 0.0;
	fldz
	fstp	qword ptr [EBP-0218h]

;{767}:erv(Math::pi());
	call	 Math_pi
	push	EAX
	push	EDX 
	lea	ECX,dword ptr [EBP-023Ch]
	call	 UnitTesting_TestVirtuals_ExponentialRV

;{769}:res= erv.Sample();
	lea	ECX,dword ptr [EBP-023Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{770}:Console::WriteLn("(1)An exponential random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000930
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{771}:res= erv.Sample();
	lea	ECX,dword ptr [EBP-023Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{772}:Console::WriteLn("(2)An exponential random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000931
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{773}:res= erv.Sample();
	lea	ECX,dword ptr [EBP-023Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{774}:Console::WriteLn("(3)An exponential random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000932
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{775}:res= erv.Sample();
	lea	ECX,dword ptr [EBP-023Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{776}:Console::WriteLn("(4)An exponential random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000933
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0218h]
	mov	EAX,dword ptr [EBP-0214h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000919
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{777}:Console::WriteLn("my name is", erv.Name());
	lea	EAX,OFFSET $S000923
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-023Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{781}:UnitTesting::TestSwitch::RunTest(UnitTesting::TestSwitch::open);
	mov	EAX,000000001h
	xor	EDX,EDX
	push	EAX
	call	 UnitTesting_TestSwitch_RunTest

;{785}:p= new double;
	push	000000008h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001062
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000002h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	mov	dword ptr [EBP-0240h],ESI 
	jz	 $L001063 
$L001062:
	xor	ESI,ESI
$L001063:
	mov	EAX,ESI 

;{788}:*p= 3.141516927;
	mov	EAX,dword ptr [EBP-576]
	push	EAX
	mov	EDX,0A06A5D05h
	mov	EAX,0400921D3h 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{790}:res= *p;
	mov	EAX,dword ptr [EBP-576]
	mov	EDX,dword ptr [EAX]
	mov	EAX,dword ptr [EAX+4] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0218h]

;{793}:destroy p;
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP-576]
	push	EAX
	call	 System_Memory_Destroy

;{801}:fpTester_ptr= new UnitTesting::TestFloatingPoint();
	push	000000001h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001064
	mov	ESI,EAX
	mov	dword ptr [EBP-0244h],ESI 
	mov	ECX,ESI 
	call	 UnitTesting_TestFloatingPoint
	jz	 $L001065 
$L001064:
	xor	ESI,ESI
$L001065:
	mov	EAX,ESI 

;{803}:_pow= fpTester_ptr.Power(2.0, 64);
	mov	EAX,000000040h
	push	EAX 
	mov	EDX,000000000h
	mov	EAX,040000000h 
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP-580]
	mov	ECX,EAX 
	call	 UnitTesting_TestFloatingPoint_Power
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-007Ch]

;{805}:destroy fpTester_ptr;
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP-580]
	mov	ECX,EAX 
	mov	ESI,ECX
	call	 UnitTesting_TestFloatingPoint_Destructor
	push	ESI
	call	 System_Memory_Destroy

;{808}:iptr= new int;
	push	000000190h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001066
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000064h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	mov	dword ptr [EBP-0248h],ESI 
	jz	 $L001067 
$L001066:
	xor	ESI,ESI
$L001067:
	mov	EAX,ESI 

;{810}:iptr[0][0]= 145;
	mov	EAX,dword ptr [EBP-584]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	xor	EAX,EAX
	mov	ECX,00000000Ah
	imul	ECX
	pop	ECX
	add	ECX,EAX
	push	ECX 
	xor	EAX,EAX
	pop	ECX 
	add	ECX,EAX 
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	mov	EAX,000000091h
	pop	EBX
	mov	dword ptr [EBX],EAX

;{811}:iptr[1][9]= 541;
	mov	EAX,dword ptr [EBP-584]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,000000001h
	mov	ECX,00000000Ah
	imul	ECX
	pop	ECX
	add	ECX,EAX
	push	ECX 
	mov	EAX,000000009h
	pop	ECX 
	add	ECX,EAX 
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	mov	EAX,00000021Dh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{812}:iptr[2][7]= 561;
	mov	EAX,dword ptr [EBP-584]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,000000002h
	mov	ECX,00000000Ah
	imul	ECX
	pop	ECX
	add	ECX,EAX
	push	ECX 
	mov	EAX,000000007h
	pop	ECX 
	add	ECX,EAX 
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	mov	EAX,000000231h
	pop	EBX
	mov	dword ptr [EBX],EAX

;{813}:iptr[3][9]= 123;
	mov	EAX,dword ptr [EBP-584]
	mov	ESI,EAX
	and	ECX,000000000h
	push	ECX
	mov	EAX,000000003h
	mov	ECX,00000000Ah
	imul	ECX
	pop	ECX
	add	ECX,EAX
	push	ECX 
	mov	EAX,000000009h
	pop	ECX 
	add	ECX,EAX 
	lea	EAX,dword ptr [ESI+ECX*0004h]
	push	EAX
	mov	EAX,00000007Bh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{815}:destroy iptr;
	mov	EAX,dword ptr [EBP-584]
	push	EAX
	call	 System_Memory_Destroy

;{817}:iptr= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-0248h]
	mov	dword ptr [EBX],EAX

;{819}:xptr= null;
	xor	EAX,EAX
	mov	dword ptr [EBP-024Ch],EAX

;{821}:xptr= new int;
	push	000000004h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001068
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000001h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	mov	dword ptr [EBP-024Ch],ESI 
	jz	 $L001069 
$L001068:
	xor	ESI,ESI
$L001069:
	mov	EAX,ESI 

;{823}:destroy xptr;
	mov	EAX,dword ptr [EBP-588]
	push	EAX
	call	 System_Memory_Destroy

;{825}:ii2ptr= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-0250h]
	mov	dword ptr [EBX],EAX

;{827}:xtarget, ;
	lea	ECX,dword ptr [EBP-0280h]
	call	 UnitTesting_TestIntegers

;{828}:ysource;
	lea	ECX,dword ptr [EBP-02B0h]
	call	 UnitTesting_TestIntegers

;{830}:ysource.Width= 0x666;
	mov	EAX,000000666h
	push	EAX
	lea	ECX,dword ptr [EBP-02B0h]
	call	OFFSET UnitTesting_TestIntegers_put_Width

;{831}:ysource.Height= 0x777;
	mov	EAX,000000777h
	push	EAX
	lea	ECX,dword ptr [EBP-02B0h]
	call	OFFSET UnitTesting_TestIntegers_put_Height

;{834}:xtarget= ysource;
	lea	ECX,dword ptr [EBP-02B0h]
	mov	ESI,ECX
	lea	EDI,dword ptr [EBP-0280h]
	mov	ECX,000000030h 
	cld	
	rep movsb	

;{836}:val1= 5, val2= 3;
	mov	EAX,000000005h
	mov	dword ptr [EBP-006Ch],EAX
	mov	EAX,000000003h
	mov	dword ptr [EBP-0070h],EAX

;{838}:xptr= xptr + 1;
	mov	EAX,dword ptr [EBP-588]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-024Ch],EAX

;{847}:npi= sizeof (UnitTesting::misc1::pi);
	mov	EAX,000000008h
	mov	dword ptr [EBP-02B4h],EAX

;{849}:npi= sizeof UnitTesting::misc1::pi;
	mov	EAX,000000008h
	mov	dword ptr [EBP-02B4h],EAX

;{851}:nint= sizeof (int), ndbl= sizeof (double), ni64= sizeof Int64, ntit= sizeof (UnitTesting::TestIntegers), nptr= sizeof (p), narr= sizeof (iptr), nar2= sizeof (array1), nar3= sizeof (UnitTesting::misc1::array);
	mov	EAX,000000004h
	mov	dword ptr [EBP-02B8h],EAX
	mov	EAX,000000008h
	mov	dword ptr [EBP-02BCh],EAX
	mov	EAX,000000008h
	mov	dword ptr [EBP-02C0h],EAX
	mov	EAX,000000030h
	mov	dword ptr [EBP-02C4h],EAX
	mov	EAX,000000004h
	mov	dword ptr [EBP-02C8h],EAX
	mov	EAX,000000004h
	mov	dword ptr [EBP-02CCh],EAX
	mov	EAX,000000190h
	mov	dword ptr [EBP-02D0h],EAX
	mov	EAX,SIZEOF UnitTesting_misc1_array
	mov	dword ptr [EBP-02D4h],EAX

;{860}:nint= sizeof int + sizeof double;
	mov	EAX,000000004h
	push	EAX
	mov	EAX,000000008h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-02B8h],EAX

;{862}:nint= sizeof (int) + sizeof (Int64);
	mov	EAX,000000004h
	push	EAX
	mov	EAX,000000008h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-02B8h],EAX

;{864}:if(nint >= ndbl && ni64 < ntit)
	mov	EAX,dword ptr [EBP-02B8h]
	push	EAX
	mov	EAX,dword ptr [EBP-02BCh]
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	push	EAX
	mov	EAX,dword ptr [EBP-02C0h]
	push	EAX
	mov	EAX,dword ptr [EBP-02C4h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	pop	EDX
	and	EAX,EDX
	test	AL,AL
	jz	OFFSET $L001070
;{

;{866}:Console::WriteLn("This is getting complex and better each time!");
	lea	EAX,OFFSET $S000958
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001070:

;{869}:obj;
	lea	ECX,dword ptr [EBP-02E0h]
	call	 UnitTesting_Circle

;{871}:obj.Radius= 115.456;
	mov	EDX,01A9FBE77h
	mov	EAX,0405CDD2Fh 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-02E0h]
	call	OFFSET UnitTesting_Circle_put_Radius

;{873}:area= obj.ComputeArea();
	lea	ECX,dword ptr [EBP-02E0h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-02E8h]

;{875}:obj2= obj;
	pop	EDX
	pop	EAX 
	lea	ECX,dword ptr [EBP-02F4h]
	call	 UnitTesting_Circle
	lea	ECX,dword ptr [EBP-02E0h]
	mov	ESI,ECX
	lea	EDI,dword ptr [EBP-02F4h]
	mov	ECX,00000000Ch 
	cld	
	rep movsb	

;{877}:what= (area == obj2.ComputeArea());
	mov	EDX,dword ptr [EBP-02E8h]
	mov	EAX,dword ptr [EBP-02E4h] 
	push	EAX
	push	EDX 
	lea	ECX,dword ptr [EBP-02F4h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	test	EAX,EAX
	setz	AL
	mov	byte ptr [EBP-0058h],AL

;{879}:sq;
	lea	ECX,dword ptr [EBP-0308h]
	call	 UnitTesting_Square

;{881}:sq.Width= 500.456;
	mov	EDX,0C6A7EF9Eh
	mov	EAX,0407F474Bh 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-0308h]
	call	OFFSET UnitTesting_Square_put_Width

;{882}:sq.Height= 1045.4564;
	mov	EDX,05A858794h
	mov	EAX,0409055D3h 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-0308h]
	call	OFFSET UnitTesting_Square_put_Height

;{884}:sq.ComputeArea();
	lea	ECX,dword ptr [EBP-0308h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]

;{886}:tri;
	lea	ECX,dword ptr [EBP-031Ch]
	call	 UnitTesting_Triangle

;{888}:tri.Base= 450.4564;
	mov	EDX,06A161E50h
	mov	EAX,0407C274Dh 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-031Ch]
	call	OFFSET UnitTesting_Triangle_put_Base

;{889}:tri.High= 4572.4564;
	mov	EDX,0D6A161E5h
	mov	EAX,040B1DC74h 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-031Ch]
	call	OFFSET UnitTesting_Triangle_put_High

;{891}:tri.ComputeArea();
	lea	ECX,dword ptr [EBP-031Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]

;{895}:Console::WriteLn("I'm tired of waiting!!!");
	lea	EAX,OFFSET $S000970
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000864:
	lea	ECX,dword ptr [EBP-031Ch]
	mov	ESI,ECX
	call	 UnitTesting_Triangle_Destructor
	lea	ECX,dword ptr [EBP-0074h]
	mov	ESI,ECX
	call	 UnitTesting_TestFloatingPoint_Destructor
	lea	ECX,dword ptr [EBP-0008h]
	mov	ESI,ECX
	call	 UnitTesting_HelloWorld_Destructor

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Test1_TestRunner_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	lea	EBX,dword ptr ___argc
	push	EBX
	call	 System_GetCommandLineArgv 
	mov	dword ptr ___argv,EAX 
	push	EAX 
	mov	ECX,dword ptr ___argc 
	push	ECX 
	call	 UnitTesting_Test1_TestRunner_main ;user entry point (stdcall calling convention)
	push	EAX 
	mov	EAX,dword ptr ___argv 
	push	EAX 
	call	 System_Memory_GetProcessHeap 
	push	EAX 
	call	 System_Memory_Free 
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
@@class_vptr_vtbl@@__UnitTesting_Circle	DWORD	OFFSET UnitTesting_Circle_Type,
						OFFSET UnitTesting_Circle_ComputeArea,
						OFFSET UnitTesting_Circle_Name,
						OFFSET UnitTesting_Circle_Draw

@@class_vptr_vtbl@@__UnitTesting_Shape	DWORD	OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall

@@class_vptr_vtbl@@__UnitTesting_Square	DWORD	OFFSET UnitTesting_Square_Type,
						OFFSET UnitTesting_Square_ComputeArea,
						OFFSET UnitTesting_Square_Name,
						OFFSET UnitTesting_Square_Draw

@@class_vptr_vtbl@@__UnitTesting_TestVirtuals_ExponentialRV	DWORD	OFFSET UnitTesting_TestVirtuals_ExponentialRV_Sample,
						OFFSET UnitTesting_TestVirtuals_ExponentialRV_Name

@@class_vptr_vtbl@@__UnitTesting_TestVirtuals_RandomVariable	DWORD	OFFSET __purecall,
						OFFSET UnitTesting_TestVirtuals_RandomVariable_Name

@@class_vptr_vtbl@@__UnitTesting_TestVirtuals_SimpleRV	DWORD	OFFSET UnitTesting_TestVirtuals_SimpleRV_Sample,
						OFFSET UnitTesting_TestVirtuals_SimpleRV_Name

@@class_vptr_vtbl@@__UnitTesting_TestVirtuals_UniformRV	DWORD	OFFSET UnitTesting_TestVirtuals_UniformRV_Sample,
						OFFSET UnitTesting_TestVirtuals_UniformRV_Name

@@class_vptr_vtbl@@__UnitTesting_Triangle	DWORD	OFFSET UnitTesting_Triangle_Type,
						OFFSET UnitTesting_Triangle_ComputeArea,
						OFFSET UnitTesting_Triangle_Name,
						OFFSET UnitTesting_Triangle_Draw

.DATA ;data segment
File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh
UnitTesting_TestSwitch_open	=	000000001h
UnitTesting_TestSwitch_close	=	000000002h
UnitTesting_TestSwitch_write	=	000000003h
UnitTesting_TestSwitch_read	=	000000004h
UnitTesting_ten	=	00000000Ah
UnitTesting_minusten	=	0FFFFFFF6h
UnitTesting_hundred	=	000000064h
UnitTesting_max_length	=	000000050h
UnitTesting_max_64	QWORD	00000000002893052h
UnitTesting_max_64_neg	QWORD	0FFFFFFFFFD76CFAEh
UnitTesting_misc1_pi	REAL8	3.141593
UnitTesting_misc1_e	REAL4	2.211400
UnitTesting_misc1_ten_plus	=	00000000Ah
UnitTesting_misc1_ch1	=	'a'
UnitTesting_misc1_ch2	=	'z'
UnitTesting_misc1_hello	BYTE "hello, world.",0
UnitTesting_misc1_hell	BYTE "human",0
UnitTesting_misc1_boy	BYTE "mistakes",0
UnitTesting_misc1_dX	REAL8	4.990000
UnitTesting_misc1_dY	REAL8	9.456700

$S000919 		BYTE 	" as its value.",0
$S000777 		BYTE 	"(*) the result is: ",0
$S000767 		BYTE 	"(+) the result is: ",0
$S000772 		BYTE 	"(-) the result is: ",0
$S000909 		BYTE 	"(1)A pseudo-random value: ",0
$S000918 		BYTE 	"(1)A simple random variable has : ",0
$S000930 		BYTE 	"(1)An exponential random variable has : ",0
$S000925 		BYTE 	"(1)An uniform random variable has : ",0
$S000910 		BYTE 	"(2)A pseudo-random value: ",0
$S000920 		BYTE 	"(2)A simple random variable has : ",0
$S000931 		BYTE 	"(2)An exponential random variable has : ",0
$S000926 		BYTE 	"(2)An uniform random variable has : ",0
$S000911 		BYTE 	"(3)A pseudo-random value: ",0
$S000921 		BYTE 	"(3)A simple random variable has : ",0
$S000932 		BYTE 	"(3)An exponential random variable has : ",0
$S000927 		BYTE 	"(3)An uniform random variable has : ",0
$S000912 		BYTE 	"(4)A pseudo-random value: ",0
$S000922 		BYTE 	"(4)A simple random variable has : ",0
$S000933 		BYTE 	"(4)An exponential random variable has : ",0
$S000928 		BYTE 	"(4)An uniform random variable has : ",0
$S000913 		BYTE 	"(5)A pseudo-random value: ",0
$S000914 		BYTE 	"(6)A pseudo-random value: ",0
$S000782 		BYTE 	"(div) the result is: ",0
$S000893 		BYTE 	"(double)the area is: ",0
$S000892 		BYTE 	"(int)the area is: ",0
$S000787 		BYTE 	"(mod) the result is: ",0
$S000473 		BYTE 	"(none)",0
$S000792 		BYTE 	"(round(/)) the result is: ",0
$S000552 		BYTE 	", and b = ",0
$S000478 		BYTE 	"A simple variable",0
$S000506 		BYTE 	"An exponential variable",0
$S000496 		BYTE 	"An uniform variable",0
$S000868 		BYTE 	"Argument: [",0
$S000835 		BYTE 	"Char at i:[",0
$S000593 		BYTE 	"Circle",0
$S000565 		BYTE 	"Closing file...",0
$S000884 		BYTE 	"Current Index :",0
$S000570 		BYTE 	"Do 6, then finish",0
$S000567 		BYTE 	"Do Read from file...",0
$S000566 		BYTE 	"Do Write to file...",0
$S000568 		BYTE 	"Do for 5 and follow to 6",0
$S000595 		BYTE 	"Drawing a Circle!",0
$S000614 		BYTE 	"Drawing a Square!",0
$S000631 		BYTE 	"Drawing a Triangle!",0
$S000541 		BYTE 	"Gamma y = ",0
$S000642 		BYTE 	"H++ First program",0
$S000857 		BYTE 	"Harold ",0
$S000845 		BYTE 	"Harold L. Marzan",0
$S000873 		BYTE 	"Hello World from H++!!!",0
$S000970 		BYTE 	"I'm tired of waiting!!!",0
$S000571 		BYTE 	"Invalid Option : ",0
$S000858 		BYTE 	"Lawrence ",0
$S000859 		BYTE 	"Marzan ",0
$S000860 		BYTE 	"Mercado.",0
$S000854 		BYTE 	"My name is :",0
$S000837 		BYTE 	"Oops! there was a bug in this code!",0
$S000838 		BYTE 	"Oops! there was a serious bug in this code!",0
$S000564 		BYTE 	"Opening file...",0
$S000915 		BYTE 	"Pseudo-Random Double values:",0
$S000908 		BYTE 	"Pseudo-Random Integer values:",0
$S000612 		BYTE 	"Square",0
$S000804 		BYTE 	"Swaping values...",0
$S000636 		BYTE 	"The HelloWorld constructor",0
$S000644 		BYTE 	"The HelloWorld destructor",0
$S000554 		BYTE 	"The max value is = ",0
$S000556 		BYTE 	"The min value is = ",0
$S000890 		BYTE 	"The value of myRef1 must be 65536 ==",0
$S000891 		BYTE 	"The value of myVar1 is not 65536 but zero",0
$S000551 		BYTE 	"The values: a = ",0
$S000958 		BYTE 	"This is getting complex and better each time!",0
$S000629 		BYTE 	"Triangle",0
$S000836 		BYTE 	"] == ",0
$S000869 		BYTE 	"]= ",0
$S000811 		BYTE 	"constructing a TestFloatingPoint() object...",0
$S000813 		BYTE 	"destroying a TestFloatingPoint() object...",0
$S000923 		BYTE 	"my name is",0
$S000728 		BYTE 	"the value is: ",0
$S000727 		BYTE 	"the value of x is: ",0
$S000639 		BYTE 	"this is what I have to say for the first time in H++ :",0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000010h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count
UnitTesting_Rnd_seed	 DWORD	0
UnitTesting_Rnd_a	 DWORD	0
UnitTesting_Rnd_m	 DWORD	0
UnitTesting_Rnd_q	 DWORD	0
UnitTesting_Rnd_r	 DWORD	0
UnitTesting_misc1_array	 REAL8 00000000Ah DUP(?) 
UnitTesting_TestIntegers_bigValue	 DQ	0

END __System_Hpp_Runtime_Init

