TITLE	 StanfordAlgs.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE stdhpp\hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{389}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000469
;}
$L000469:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000486
;}
$L000486:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000492
;}
$L000492:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000490
;}
$L000490:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000483
;}
$L000483:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000500
;}
$L000500:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000506
;}
$L000506:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000497
;}
$L000497:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000502
;}
$L000502:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{384}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_RadiansToDegrees ENDP

Stanford_StanfordAlgorithms_Fibonacci PROC NEAR 
;unsigned Fibonacci(unsigned n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
;{

;{34}:if(n == 0 || n == 1)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000565
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
$L000565:
	test	AL,AL
	jz	OFFSET $L000563

;{35}:return n
	mov	EAX,dword ptr [EBP+0008h]
	jmp	OFFSET $L000531
$L000563:

;{37}:a= Fibonacci((n + 1) div 2);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	mov	ECX,dword ptr [EBP-000Ch]
	call	 Stanford_StanfordAlgorithms_Fibonacci
	mov	dword ptr [EBP-0004h],EAX

;{38}:b= Fibonacci(((n + 1) div 2) - 1);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-000Ch]
	call	 Stanford_StanfordAlgorithms_Fibonacci
	mov	dword ptr [EBP-0008h],EAX

;{40}:if(n % 2 == 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000566

;{41}:return a * (a + 2 * b)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000002h
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	pop	EDX
	add	EAX,EDX
	pop	ECX
	cdq	
	imul	EAX,ECX
	jmp	OFFSET $L000531

; else {
$L000566:

;{43}:return a * a + b * b
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	EDX
	add	EAX,EDX
	jmp	OFFSET $L000531
$L000567:

; }
;}
$L000531:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Stanford_StanfordAlgorithms_Fibonacci ENDP

Stanford_StanfordAlgorithms_Power PROC NEAR 
;int Power(int x, int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{13}:if(n == 0)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000568

;{14}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L000525

; else {
$L000568:

;{15}:if(n == 1)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000570

;{16}:return x
	mov	EAX,dword ptr [EBP+0008h]
	jmp	OFFSET $L000525
$L000570:
$L000569:

; }

;{17}:result= 1;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX

;{18}:while(n > 0)
$L000572:
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L000573
;{

;{19}:if(n % 2 == 0)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000574
;{

;{21}:result*= (x * x);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	lea	EBX,dword ptr [EBP-0004h]
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX

;{22}:n-= 2;
	mov	EAX,000000002h
	clc	
	sub	dword ptr [EBP+000Ch],EAX
;}
	jmp	OFFSET $L000575

; else {
$L000574:
;{

;{25}:result*= (x * x * x);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ECX 
	cdq	 
	imul	EAX,ECX 
	lea	EBX,dword ptr [EBP-0004h]
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX

;{26}:n-= 3;
	mov	EAX,000000003h
	clc	
	sub	dword ptr [EBP+000Ch],EAX
;}
$L000575:

; }
;}
	jmp	OFFSET $L000572
$L000573:

;{29}:return result
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000525
;}
$L000525:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Stanford_StanfordAlgorithms_Power ENDP

Stanford_StanfordAlgorithms_PrintPrettySeq1 PROC NEAR 
;void PrintPrettySeq1(int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{50}:i= Power(n - 1, 2) + 1;
	mov	EAX,000000002h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Stanford_StanfordAlgorithms_Power
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX

;{51}:m= Power(n, 2) + 1;
	mov	EAX,000000002h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Stanford_StanfordAlgorithms_Power
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX

;{52}:for(j= i; j < m; j++ )
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000576
$L000577:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000576:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000578
;{

;{53}:Console::Write(j);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	call	 Console_WriteInteger

;{54}:if(j < (m - 1))
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000579

;{55}:Console::Write("+");
	mov	EAX,00000002Bh
	push	EAX
	call	 Console_WriteChar
$L000579:
;}
	jmp	OFFSET $L000577 
$L000578:

;{57}:Console::WriteLn("\t= ", Power(n - 1, 3), " + ", Power(n, 3));
	lea	EAX,OFFSET $S000541
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Stanford_StanfordAlgorithms_Power
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000542
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,000000003h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Stanford_StanfordAlgorithms_Power
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000535:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Stanford_StanfordAlgorithms_PrintPrettySeq1 ENDP

Stanford_StanfordAlgorithms_PrintPrettySeq2 PROC NEAR 
;void PrintPrettySeq2(int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{62}:i= Power(n, 2) - n + 1;
	mov	EAX,000000002h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Stanford_StanfordAlgorithms_Power
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	pop	EDX 
	add	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX

;{63}:m= Power(n, 2) + n - 1;
	mov	EAX,000000002h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Stanford_StanfordAlgorithms_Power
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	pop	EDX 
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX

;{64}:for(j= 1; j <= n; j++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000581
$L000582:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000581:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000583
;{

;{65}:Console::Write(i);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Console_WriteInteger

;{66}:if(j < n && i < m)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000586
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
$L000586:
	test	AL,AL
	jz	OFFSET $L000584

;{67}:Console::Write("+");
	mov	EAX,00000002Bh
	push	EAX
	call	 Console_WriteChar
$L000584:

;{68}:i+= 2;
	mov	EAX,000000002h
	clc	
	add	dword ptr [EBP-0004h],EAX
;}
	jmp	OFFSET $L000582 
$L000583:

;{70}:Console::WriteLn(" \t= ", Power(n, 3));
	lea	EAX,OFFSET $S000548
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Stanford_StanfordAlgorithms_Power
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000543:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Stanford_StanfordAlgorithms_PrintPrettySeq2 ENDP

Stanford_StanfordAlgorithms PROC NEAR 
;void Stanford::StanfordAlgorithms(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Stanford_StanfordAlgorithms ENDP

Stanford_Application_main PROC NEAR 
;void Stanford::Application::main(int argc, string string [] argv);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{79}:simple= new Stanford::StanfordAlgorithms();
	push	000000001h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000587
	mov	ESI,EAX
	jmp	 $L000588
$L000587:
	xor	ESI,ESI
$L000588:
	mov	dword ptr [EBP-0004h],ESI 
	mov	ECX,ESI
	call	 Stanford_StanfordAlgorithms
	mov	EAX,ESI 

;{81}:Console::Write("Please, enter the number n = ");
	lea	EAX,OFFSET $S000554
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{82}:n= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0008h],EAX

;{83}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000556
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{84}:Console::WriteLn("Calculate the Sum[i, {i,(n-1)^2 + 1},{m, 2n-1}]\t= \t(n-1)^3 + n^3.\n");
	lea	EAX,OFFSET $S000557
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{85}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000556
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{86}:for(i= 1; i <= n; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000589
$L000590:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000589:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000591

;{87}:simple.PrintPrettySeq1(i);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	call	 Stanford_StanfordAlgorithms_PrintPrettySeq1
	jmp	OFFSET $L000590 
$L000591:

;{88}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000556
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{89}:Console::WriteLn("Calculate the Sum[i+2*j, {j, 0}, {i,n^2-n+1},{m, n^2+n-1}, {n}]\t= \tn^3.\n");
	lea	EAX,OFFSET $S000559
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{90}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000556
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{91}:for(i= 1; i <= n; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000592
$L000593:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000592:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000594

;{92}:simple.PrintPrettySeq2(i);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	call	 Stanford_StanfordAlgorithms_PrintPrettySeq2
	jmp	OFFSET $L000593 
$L000594:

;{93}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000556
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{94}:Console::WriteLn("Fibonacci Sequence, up to: ", n);
	lea	EAX,OFFSET $S000560
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{95}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000556
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{96}:for(i= 1; i <= n; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000595
$L000596:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000595:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000597

;{97}:Console::Write(simple.Fibonacci(i), ", ");
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	call	 Stanford_StanfordAlgorithms_Fibonacci
	push	EAX
	call	 Console_WriteInteger
	lea	EAX,OFFSET $S000561
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	jmp	OFFSET $L000596 
$L000597:

;{98}:Console::WriteLn("\n--------------------------------------------");
	lea	EAX,OFFSET $S000562
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{99}:destroy simple;
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	call	 System_Memory_Destroy
;}
$L000550:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Stanford_Application_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	lea	EBX,dword ptr ___argc
	push	EBX
	call	 System_GetCommandLineArgv 
	mov	dword ptr ___argv,EAX 
	push	EAX 
	mov	ECX,dword ptr ___argc 
	push	ECX 
	call	 Stanford_Application_main ;user entry point (stdcall calling convention)
	push	EAX 
	mov	EAX,dword ptr ___argv 
	push	EAX 
	call	 System_Memory_GetProcessHeap 
	push	EAX 
	call	 System_Memory_Free 
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

$S000542 		BYTE 	" + ",0
$S000548 		BYTE 	" ",09h,"= ",0
$S000561 		BYTE 	", ",0
$S000556 		BYTE 	"--------------------------------------------",0
$S000559 		BYTE 	"Calculate the Sum[i+2*j, {j, 0}, {i,n^2-n+1},{m, n^2+n-1}, {n}]",09h,"= ",09h,"n^3.",0Ah,0
$S000557 		BYTE 	"Calculate the Sum[i, {i,(n-1)^2 + 1},{m, 2n-1}]",09h,"= ",09h,"(n-1)^3 + n^3.",0Ah,0
$S000560 		BYTE 	"Fibonacci Sequence, up to: ",0
$S000554 		BYTE 	"Please, enter the number n = ",0
$S000562 		BYTE 	0Ah,"--------------------------------------------",0
$S000541 		BYTE 	09h,"= ",0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000020h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count

END __System_Hpp_Runtime_Init

