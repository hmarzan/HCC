TITLE	 nc_ieee.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE stdhpp\hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{389}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000469
;}
$L000469:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000486
;}
$L000486:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000492
;}
$L000492:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000490
;}
$L000490:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000483
;}
$L000483:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000500
;}
$L000500:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000506
;}
$L000506:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000497
;}
$L000497:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000502
;}
$L000502:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{384}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_RadiansToDegrees ENDP

Numerical_Computing_Program_ApproximateADerivativeByDifferenceQuotient PROC NEAR 
;void Numerical::Computing::Program::ApproximateADerivativeByDifferenceQuotient(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000030h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{78}:n= 1;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX

;{79}:x= 1.0, h= 1.0, deriv= Math::Cos(x), diffquo, ;
	fld1
	fstp	qword ptr [EBP-000Ch]
	fld1
	fstp	qword ptr [EBP-0014h]
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	call	 Math_Cos
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-001Ch]
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0024h]
	mov	EAX,dword ptr [EBP-0020h] 

;{79}:error;
	mov	EDX,dword ptr [EBP-002Ch]
	mov	EAX,dword ptr [EBP-0028h] 

;{81}:Console::WriteLn(" deriv = ", deriv);
	lea	EAX,OFFSET $S000572
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-001Ch]
	mov	EAX,dword ptr [EBP-0018h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{82}:Console::WriteLn("\n h\t\t\tdiffquo\t\t\tabs(deriv - diffquo) \n");
	lea	EAX,OFFSET $S000573
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{86}:while(n <= 20)
$L000633:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000014h
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000634
;{

;{88}:h/= 10;
	mov	EAX,00000000Ah
	push	EAX
	fild	dword ptr [ESP]
	pop	EAX
	lea	EBX,dword ptr [EBP-0014h]
	fdivr	qword ptr [EBX]
	fstp	qword ptr [EBX]

;{89}:diffquo= (Math::Sin(x + h) - Math::Sin(x)) / h;
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sin
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	call	 Math_Sin
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0024h]

;{90}:error= Math::Abs(deriv - diffquo);
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-001Ch]
	mov	EAX,dword ptr [EBP-0018h] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-0024h]
	mov	EAX,dword ptr [EBP-0020h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Abs
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-002Ch]

;{93}:if(n <= 8)
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000008h
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000635

;{94}:Console::WriteLn(h, "     \t\t", diffquo, "    \t", error);
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	push	EAX
	push	EDX 
	call	 Console_WriteDouble
	lea	EAX,OFFSET $S000575
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0024h]
	mov	EAX,dword ptr [EBP-0020h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000576
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-002Ch]
	mov	EAX,dword ptr [EBP-0028h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L000636

; else {
$L000635:

;{95}:if(n <= 15)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,00000000Fh
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000637

;{96}:Console::WriteLn(h, "     \t", diffquo, "    \t", error);
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	push	EAX
	push	EDX 
	call	 Console_WriteDouble
	lea	EAX,OFFSET $S000578
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0024h]
	mov	EAX,dword ptr [EBP-0020h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000576
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-002Ch]
	mov	EAX,dword ptr [EBP-0028h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L000638

; else {
$L000637:

;{97}:if(n == 16)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000010h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000639

;{98}:Console::WriteLn(h, "     \t", diffquo, "    \t\t\t", error);
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	push	EAX
	push	EDX 
	call	 Console_WriteDouble
	lea	EAX,OFFSET $S000578
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0024h]
	mov	EAX,dword ptr [EBP-0020h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000580
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-002Ch]
	mov	EAX,dword ptr [EBP-0028h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L000640

; else {
$L000639:

;{100}:Console::WriteLn(h, "     \t\t", diffquo, "    \t\t\t", error);
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	push	EAX
	push	EDX 
	call	 Console_WriteDouble
	lea	EAX,OFFSET $S000575
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0024h]
	mov	EAX,dword ptr [EBP-0020h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000580
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-002Ch]
	mov	EAX,dword ptr [EBP-0028h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
$L000640:

; }
$L000638:

; }
$L000636:

; }

;{102}:n++ ;
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
;}
	jmp	OFFSET $L000633
$L000634:
;}
$L000565:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_ApproximateADerivativeByDifferenceQuotient ENDP

Numerical_Computing_Program_ApproximateEulerConstant PROC NEAR 
;double Numerical::Computing::Program::ApproximateEulerConstant(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000018h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{108}:e= 0.0;
	fldz
	fstp	qword ptr [EBP-0008h]

;{109}:x= 1.0;
	fld1
	fstp	qword ptr [EBP-0010h]

;{110}:n= 100000000;
	mov	EAX,005F5E100h
	mov	dword ptr [EBP-0014h],EAX

;{111}:e= Math::Pow((1 + x / n), n);
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP-0014h]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Pow
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{113}:Console::WriteLn("e = ", e, ", ln e = ", Math::Ln(e));
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000586
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000587
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	call	 Math_Ln
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{115}:return e
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L000581
;}
$L000581:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_ApproximateEulerConstant ENDP

Numerical_Computing_Program_ApproximateEulerConstantByTaylor PROC NEAR 
;double Numerical::Computing::Program::ApproximateEulerConstantByTaylor(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000001Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{127}:e= 0.0;
	fldz
	fstp	qword ptr [EBP-0008h]

;{128}:x= 1.0;
	fld1
	fstp	qword ptr [EBP-0010h]

;{129}:n= 20;
	mov	EAX,000000014h
	mov	dword ptr [EBP-0014h],EAX

;{130}:for(i= 0; i < n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0018h],EAX
	jmp	OFFSET $L000641
$L000642:
	mov	EAX,dword ptr [EBP-24]
	inc	dword ptr [EBP-24]
$L000641:
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000643

;{131}:e+= Math::Pow(x, i) / Numerical::Computing::Program::Factorial(i);
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Pow
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	call	 Numerical_Computing_Program_Factorial
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	clc	
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	lea	EBX,dword ptr [EBP-0008h]
	fadd	qword ptr [EBX]
	fstp	qword ptr [EBX]
	jmp	OFFSET $L000642 
$L000643:

;{133}:Console::WriteLn("e = ", e, ", ln e = ", Math::Ln(e));
	lea	EAX,OFFSET $S000586
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000587
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	call	 Math_Ln
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{135}:return e
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L000590
;}
$L000590:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_ApproximateEulerConstantByTaylor ENDP

Numerical_Computing_Program_CalcAddOneToReciprocalPowerOf2 PROC NEAR 
;void Numerical::Computing::Program::CalcAddOneToReciprocalPowerOf2(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000018h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{29}:x= 1, y= 2;
	mov	EAX,000000001h
	push	EAX
	fild	dword ptr [ESP]
	fstp	qword ptr [EBP-0008h]
	pop	EAX
	mov	EAX,000000002h
	push	EAX
	fild	dword ptr [ESP]
	fstp	qword ptr [EBP-0010h]

;{30}:n= 0;
	pop	EAX
	xor	EAX,EAX
	mov	dword ptr [EBP-0014h],EAX

;{34}:while(y > 1)
$L000644:
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L000645
;{

;{36}:x= x / 2;
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{37}:y= 1 + x;
	pop	EDX
	pop	EAX 
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0010h]

;{38}:n++ ;
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP-20]
	inc	dword ptr [EBP-20]

;{39}:Console::WriteLn(" 2^ - ", n, " = ", y);
	lea	EAX,OFFSET $S000530
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000531
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000644
$L000645:
;}
$L000532:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_CalcAddOneToReciprocalPowerOf2 ENDP

Numerical_Computing_Program_CalcEulersGammaConstant PROC NEAR 
;double Numerical::Computing::Program::CalcEulersGammaConstant(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{140}:result= 0.0;
	fldz
	fstp	qword ptr [EBP-0008h]

;{141}:n= 100000;
	mov	EAX,0000186A0h
	mov	dword ptr [EBP-000Ch],EAX

;{142}:for(i= 1; i < n; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000646
$L000647:
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
$L000646:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000648
;{

;{144}:result+= 1 / i;
	mov	EAX,000000001h
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	clc	
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	lea	EBX,dword ptr [EBP-0008h]
	fadd	qword ptr [EBX]
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L000647 
$L000648:

;{146}:result-= Math::Ln(n);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 Math_Ln
	clc	
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	lea	EBX,dword ptr [EBP-0008h]
	fsubr	qword ptr [EBX]
	fstp	qword ptr [EBX]

;{148}:return result
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L000595
;}
$L000595:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_CalcEulersGammaConstant ENDP

Numerical_Computing_Program_CalcHyperbolicDemo2 PROC NEAR 
;double Numerical::Computing::Program::CalcHyperbolicDemo2(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{172}:return (Math::Hyperbolic::HCos(Math::pi()) * Math::Hyperbolic::HCos(Math::pi())) - (Math::Hyperbolic::HSin(Math::pi()) * Math::Hyperbolic::HSin(Math::pi()))
	call	 Math_pi
	push	EAX
	push	EDX 
	call	 Math_Hyperbolic_HCos
	push	EAX
	push	EDX 
	call	 Math_pi
	push	EAX
	push	EDX 
	call	 Math_Hyperbolic_HCos
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_pi
	push	EAX
	push	EDX 
	call	 Math_Hyperbolic_HSin
	push	EAX
	push	EDX 
	call	 Math_pi
	push	EAX
	push	EDX 
	call	 Math_Hyperbolic_HSin
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000608
;}
$L000608:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_CalcHyperbolicDemo2 ENDP

Numerical_Computing_Program_CalcHyperbolicFunctionsDemo PROC NEAR 
;double Numerical::Computing::Program::CalcHyperbolicFunctionsDemo(double x);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{165}:e_PowX= Math::Hyperbolic::HSin(x) + Math::Hyperbolic::HCos(x);
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Hyperbolic_HSin
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Hyperbolic_HCos
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{167}:return e_PowX
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L000605
;}
$L000605:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Numerical_Computing_Program_CalcHyperbolicFunctionsDemo ENDP

Numerical_Computing_Program_CalcPowerOfReciprocalCubes PROC NEAR 
;double Numerical::Computing::Program::CalcPowerOfReciprocalCubes(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{153}:result= 0.0;
	fldz
	fstp	qword ptr [EBP-0008h]

;{154}:n= 1000;
	mov	EAX,0000003E8h
	mov	dword ptr [EBP-000Ch],EAX

;{155}:for(i= 1; i < n; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000649
$L000650:
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
$L000649:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000651
;{

;{157}:result+= 1 / Math::Pow(i, 3);
	mov	EAX,000000001h
	push	EAX
	mov	EAX,000000003h
	push	EAX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 Math_Pow
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	clc	
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	lea	EBX,dword ptr [EBP-0008h]
	fadd	qword ptr [EBX]
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L000650 
$L000651:

;{160}:return result
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L000600
;}
$L000600:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_CalcPowerOfReciprocalCubes ENDP

Numerical_Computing_Program_CalcReciprocalPowerOf2 PROC NEAR 
;void Numerical::Computing::Program::CalcReciprocalPowerOf2(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{14}:x= 1;
	mov	EAX,000000001h
	push	EAX
	fild	dword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{15}:n= 0;
	pop	EAX
	xor	EAX,EAX
	mov	dword ptr [EBP-000Ch],EAX

;{19}:while(x > 1.0e-17)
$L000652:
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	mov	EDX,04646D497h
	mov	EAX,03C670EF5h 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L000653
;{

;{21}:x= x / 2;
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{22}:n++ ;
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]

;{23}:Console::WriteLn(" 2^ - ", n, " = ", x);
	lea	EAX,OFFSET $S000530
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000531
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000652
$L000653:
;}
$L000525:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_CalcReciprocalPowerOf2 ENDP

Numerical_Computing_Program_Factorial PROC NEAR 
;int Numerical::Computing::Program::Factorial(int n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{120}:if(n == 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000654

;{121}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L000588
$L000654:

;{122}:return n * Numerical::Computing::Program::Factorial(n - 1)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	call	 Numerical_Computing_Program_Factorial
	pop	ECX
	cdq	
	imul	EAX,ECX
	jmp	OFFSET $L000588
;}
$L000588:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Numerical_Computing_Program_Factorial ENDP

Numerical_Computing_Program_FindOneFromQuotient PROC NEAR 
;void Numerical::Computing::Program::FindOneFromQuotient(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{67}:y= 0.0;
	fldz
	fstp	qword ptr [EBP-0008h]

;{69}:for(x= 1; x <= 10; x++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000656
$L000657:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000656:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000658
;{

;{71}:y= 1 / (1 / x);
	mov	EAX,000000001h
	push	EAX
	mov	EAX,000000001h
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{72}:Console::WriteLn("y is ", x, "? == ", y);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000563
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000564
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000657 
$L000658:
;}
$L000558:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_FindOneFromQuotient ENDP

Numerical_Computing_Program_TotalParallelResistance PROC NEAR 
;void Numerical::Computing::Program::TotalParallelResistance(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000060h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{45}:R1= 1.0;
	fld1
	fstp	qword ptr [EBP-0008h]

;{46}:R2;
	lea	EAX,dword ptr [EBP-0050h]

;{48}:R2[0]= 1.0;
	xor	EAX,EAX
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	fld1
	pop	EBX
	fstp	qword ptr [EBX]

;{49}:R2[1]= 10.0;
	mov	EAX,000000001h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	xor	EDX,EDX
	mov	EAX,040240000h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{50}:R2[2]= 1000.0;
	mov	EAX,000000002h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	xor	EDX,EDX
	mov	EAX,0408F4000h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{51}:R2[3]= 1.0e5;
	mov	EAX,000000003h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	xor	EDX,EDX
	mov	EAX,040F86A00h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{52}:R2[4]= 1.0e10;
	mov	EAX,000000004h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	mov	EDX,020000000h
	mov	EAX,04202A05Fh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{53}:R2[5]= 0.1;
	mov	EAX,000000005h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	mov	EDX,09999999Ah
	mov	EAX,03FB99999h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{54}:R2[6]= 1.0e-5;
	mov	EAX,000000006h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	mov	EDX,088E368F0h
	mov	EAX,03EE4F8B5h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{55}:R2[7]= 1.0e-10;
	mov	EAX,000000007h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	mov	EDX,0D9D7BDBAh
	mov	EAX,03DDB7CDFh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{56}:R2[8]= 0;
	mov	EAX,000000008h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0050h]
	push	EAX
	xor	EAX,EAX
	push	EAX
	fild	dword ptr [ESP]
	pop	EAX
	pop	EBX
	fstp	qword ptr [EBX]

;{58}:for(i= 0; i < sizeof (R2) / sizeof (double); ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-0054h],EAX
	jmp	OFFSET $L000659
$L000660:
	inc	dword ptr [EBP-84]
	mov	EAX,dword ptr [EBP-84]
$L000659:
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	mov	EAX,000000048h
	push	EAX
	mov	EAX,000000008h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_CompareToInteger
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000661
;{

;{60}:total= 1 / (1 / R1 + 1 / R2[i]);
	mov	EAX,000000001h
	push	EAX
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EAX,dword ptr [EBP-0054h]
	imul	EAX,EAX,000000008h
	mov	EDX,dword ptr [EBP+EAX-0050h]
	add	EAX,000000004h ;low part
	mov	EAX,dword ptr [EBP+EAX-0050h] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-005Ch]

;{61}:Console::WriteLn("r1 = ", R1, "\tR2 = ", R2[i], "\t Total Resistance = ", total);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000555
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000556
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0054h]
	imul	EAX,EAX,000000008h
	mov	EDX,dword ptr [EBP+EAX-0050h]
	add	EAX,000000004h ;low part
	mov	EAX,dword ptr [EBP+EAX-0050h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000557
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-005Ch]
	mov	EAX,dword ptr [EBP-0058h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000660 
$L000661:
;}
$L000536:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_TotalParallelResistance ENDP

Numerical_Computing_Program_main PROC NEAR 
;void Numerical::Computing::Program::main(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000020h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{177}:Console::WriteLn("Reciprocal power of 2:\n");
	lea	EAX,OFFSET $S000610
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{178}:Numerical::Computing::Program::CalcReciprocalPowerOf2();
	call	 Numerical_Computing_Program_CalcReciprocalPowerOf2

;{179}:Console::WriteLn("1 + Reciprocal power of 2:\n");
	lea	EAX,OFFSET $S000611
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{180}:Numerical::Computing::Program::CalcAddOneToReciprocalPowerOf2();
	call	 Numerical_Computing_Program_CalcAddOneToReciprocalPowerOf2

;{181}:Console::WriteLn("\nTotal Parallel Resistance:\n");
	lea	EAX,OFFSET $S000612
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{182}:Numerical::Computing::Program::TotalParallelResistance();
	call	 Numerical_Computing_Program_TotalParallelResistance

;{183}:Console::WriteLn("\nProblem: 1/(1/x):\n");
	lea	EAX,OFFSET $S000613
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{184}:Numerical::Computing::Program::FindOneFromQuotient();
	call	 Numerical_Computing_Program_FindOneFromQuotient

;{185}:Console::WriteLn("Approximate A Derivative By Difference Quotient:\n");
	lea	EAX,OFFSET $S000614
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{186}:Numerical::Computing::Program::ApproximateADerivativeByDifferenceQuotient();
	call	 Numerical_Computing_Program_ApproximateADerivativeByDifferenceQuotient

;{187}:Console::WriteLn("\nApproximating e:\n");
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{188}:e1= Numerical::Computing::Program::ApproximateEulerConstant();
	call	 Numerical_Computing_Program_ApproximateEulerConstant
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{189}:Console::WriteLn("\nApproximating e using Taylor series:\n");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000617
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{190}:e2= Numerical::Computing::Program::ApproximateEulerConstantByTaylor();
	call	 Numerical_Computing_Program_ApproximateEulerConstantByTaylor
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0010h]

;{192}:Console::WriteLn("\n\nCancellation phenomena:\n\ne1= ", e1, "\ne2= ", e2, "\n\n| e1 - e2 | = ", Math::Abs(e1 - e2));
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000619
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000620
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000621
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Abs
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{194}:Console::WriteLn("\nCalculating the Euler\'s gamma constant: ", Numerical::Computing::Program::CalcEulersGammaConstant());
	lea	EAX,OFFSET $S000622
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Numerical_Computing_Program_CalcEulersGammaConstant
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{197}:Console::WriteLn("\nCalculating the Power of ", "Reciprocal Cubes: ", Numerical::Computing::Program::CalcPowerOfReciprocalCubes());
	lea	EAX,OFFSET $S000623
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	EAX,OFFSET $S000624
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Numerical_Computing_Program_CalcPowerOfReciprocalCubes
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{198}:Console::WriteLn("\nShould be: ", Math::Pow(Math::pi(), 3) / 25.79436089);
	lea	EAX,OFFSET $S000625
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	push	EAX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 Math_pi
	push	EAX
	push	EDX 
	call	 Math_Pow
	push	EAX
	push	EDX 
	mov	EDX,03C3BC57Eh
	mov	EAX,04039CB5Bh 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{200}:x= Math::pi();
	call	 Math_pi
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0018h]

;{201}:e_PowX= Numerical::Computing::Program::CalcHyperbolicFunctionsDemo(x);
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0018h]
	mov	EAX,dword ptr [EBP-0014h] 
	push	EAX
	push	EDX 
	call	 Numerical_Computing_Program_CalcHyperbolicFunctionsDemo
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0020h]

;{203}:Console::WriteLn("\n x = pi = ", x);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000629
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0018h]
	mov	EAX,dword ptr [EBP-0014h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{204}:Console::WriteLn("\nValue of e^x == Sinh[x] + Cosh[x] == ", e_PowX, "\n\t\t\t   Aprox. == ", Math::Exp(x));
	lea	EAX,OFFSET $S000630
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0020h]
	mov	EAX,dword ptr [EBP-001Ch] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S000631
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0018h]
	mov	EAX,dword ptr [EBP-0014h] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{207}:Console::WriteLn("\n Cosh^2 pi - Sinh^2 pi == ", Math::Round(Numerical::Computing::Program::CalcHyperbolicDemo2()));
	lea	EAX,OFFSET $S000632
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Numerical_Computing_Program_CalcHyperbolicDemo2
	push	EAX
	push	EDX 
	call	 Math_Round
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000609:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Numerical_Computing_Program_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	call	 Numerical_Computing_Program_main ;user entry point (stdcall calling convention)
	push	EAX
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

$S000578 		BYTE 	"     ",09h,0
$S000575 		BYTE 	"     ",09h,09h,0
$S000576 		BYTE 	"    ",09h,0
$S000580 		BYTE 	"    ",09h,09h,09h,0
$S000530 		BYTE 	" 2^ - ",0
$S000531 		BYTE 	" = ",0
$S000572 		BYTE 	" deriv = ",0
$S000587 		BYTE 	", ln e = ",0
$S000611 		BYTE 	"1 + Reciprocal power of 2:",0Ah,0
$S000564 		BYTE 	"? == ",0
$S000614 		BYTE 	"Approximate A Derivative By Difference Quotient:",0Ah,0
$S000624 		BYTE 	"Reciprocal Cubes: ",0
$S000610 		BYTE 	"Reciprocal power of 2:",0Ah,0
$S000632 		BYTE 	0Ah," Cosh^2 pi - Sinh^2 pi == ",0
$S000573 		BYTE 	0Ah," h",09h,09h,09h,"diffquo",09h,09h,09h,"abs(deriv - diffquo) ",0Ah,0
$S000629 		BYTE 	0Ah," x = pi = ",0
$S000617 		BYTE 	0Ah,"Approximating e using Taylor series:",0Ah,0
$S000615 		BYTE 	0Ah,"Approximating e:",0Ah,0
$S000622 		BYTE 	0Ah,"Calculating the Euler's gamma constant: ",0
$S000623 		BYTE 	0Ah,"Calculating the Power of ",0
$S000613 		BYTE 	0Ah,"Problem: 1/(1/x):",0Ah,0
$S000625 		BYTE 	0Ah,"Should be: ",0
$S000612 		BYTE 	0Ah,"Total Parallel Resistance:",0Ah,0
$S000630 		BYTE 	0Ah,"Value of e^x == Sinh[x] + Cosh[x] == ",0
$S000619 		BYTE 	0Ah,0Ah,"Cancellation phenomena:",0Ah,0Ah,"e1= ",0
$S000621 		BYTE 	0Ah,0Ah,"| e1 - e2 | = ",0
$S000631 		BYTE 	0Ah,09h,09h,09h,"   Aprox. == ",0
$S000620 		BYTE 	0Ah,"e2= ",0
$S000557 		BYTE 	09h," Total Resistance = ",0
$S000556 		BYTE 	09h,"R2 = ",0
$S000586 		BYTE 	"e = ",0
$S000555 		BYTE 	"r1 = ",0
$S000563 		BYTE 	"y is ",0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000020h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count

END __System_Hpp_Runtime_Init

