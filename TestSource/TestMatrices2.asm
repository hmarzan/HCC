TITLE	 TestMatrices2.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE stdhpp\hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{389}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000469
;}
$L000469:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000486
;}
$L000486:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000492
;}
$L000492:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000490
;}
$L000490:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000483
;}
$L000483:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000500
;}
$L000500:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000506
;}
$L000506:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000497
;}
$L000497:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000502
;}
$L000502:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{384}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_RadiansToDegrees ENDP

Program_CalcTrace PROC NEAR 
;double Program::CalcTrace(double double [] M, int rM, int cM);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{20}:Tr= 0.0;
	fldz
	fstp	qword ptr [EBP-0008h]

;{21}:n= min(rM, cM);
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EBX
	sub	EBX,EAX
	sbb	ECX,ECX
	and	ECX,EBX
	add	EAX,ECX
	mov	dword ptr [EBP-000Ch],EAX

;{22}:for(i= 0; i < n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000633
$L000634:
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
$L000633:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000635
;{

;{23}:Console::WriteLn("M[", i, ",", i, "]= ", M[(i * (n + 1)) * sizeof (double)]);
	lea	EAX,OFFSET $S000541
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000002Ch
	push	EAX 
	call	 Console_WriteChar 
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000543
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{24}:Tr+= M[(i * (n + 1)) * sizeof (double)];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	clc	
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	lea	EBX,dword ptr [EBP-0008h]
	fadd	qword ptr [EBX]
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L000634 
$L000635:

;{26}:return Tr
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L000533
;}
$L000533:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Program_CalcTrace ENDP

Program_MultiplyMatrices PROC NEAR 
;void Program::MultiplyMatrices(double double [] A, double double [] B, int rA, int cA, int rB, int cB);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{79}:Res= new double[rA * cB];
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+001Ch]
	pop	ECX
	cdq	
	imul	EAX,ECX
	imul	EAX,000000008h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000636
	mov	ESI,EAX 
	jmp	 $L000637
$L000636:
	xor	ESI,ESI
$L000637:
	mov	dword ptr [EBP-0004h],ESI 

;{80}:if(cA == rB)
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX
	mov	EAX,dword ptr [EBP+0018h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000638
;{

;{83}:for(i= 0; i < rA; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L000640
$L000641:
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]
$L000640:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000642

;{84}:for(j= 0; j < cB; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000643
$L000644:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000643:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+001Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000645
;{

;{85}:Res[(i * cB + j) * sizeof (double)]= 0.0;
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+001Ch]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	fldz
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{86}:Console::WriteLn("Res[", i, ",", i, "]= ", Res[(i * cB + j) * sizeof (double)]);
	lea	EAX,OFFSET $S000574
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000002Ch
	push	EAX 
	call	 Console_WriteChar 
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000543
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	ECX
	push	ECX 
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP+001Ch]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000644 
$L000645:
	jmp	OFFSET $L000641 
$L000642:

;{98}:Program::ShowMatrixForm(Res, rA, cB);
	mov	EAX,dword ptr [EBP+001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	call	 Program_ShowMatrixForm
;}
	jmp	OFFSET $L000639

; else {
$L000638:

;{100}:Console::WriteLn("El numero de filas de B debe ser igual al numero de filas de A.");
	lea	EAX,OFFSET $S000575
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000639:

; }

;{102}:destroy []Res;
	mov	EAX,dword ptr [EBP-4]
	test	EAX,EAX
	jz	OFFSET $L000646
	push	EAX
	call	 System_Memory_Destroy
$L000646:

;{103}:Res= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX
;}
$L000564:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000018h
Program_MultiplyMatrices ENDP

Program_ShowMatrixForm PROC NEAR 
;void Program::ShowMatrixForm(double double [] M, int rM, int cM);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{11}:for(i= 0; i < rM; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000647
$L000648:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L000647:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000649
;{

;{12}:Console::Write("\n| ");
	lea	EAX,OFFSET $S000529
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{13}:for(j= 0; j < cM; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L000650
$L000651:
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]
$L000650:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000652

;{14}:Console::Write(M[(i * cM + j) * sizeof (double)], "  ");
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 Console_WriteDouble
	lea	EAX,OFFSET $S000531
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	jmp	OFFSET $L000651 
$L000652:

;{15}:Console::Write("| ");
	lea	EAX,OFFSET $S000532
	push	000000000h
	push	EAX 
	call	 Console_WriteString
;}
	jmp	OFFSET $L000648 
$L000649:
;}
$L000523:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Program_ShowMatrixForm ENDP

Program_SumMatrices PROC NEAR 
;void Program::SumMatrices(double double [] A, double double [] B, int rows, int cols, Program::OpType what);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000018h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{54}:Res= new double[rows * cols];
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	imul	EAX,000000008h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000653
	mov	ESI,EAX 
	jmp	 $L000654
$L000653:
	xor	ESI,ESI
$L000654:
	mov	dword ptr [EBP-0004h],ESI 

;{55}:Result= 0.0;
	fldz
	fstp	qword ptr [EBP-000Ch]

;{56}:for(i= 0; i < rows; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000655
$L000656:
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
$L000655:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000657

;{57}:for(j= 0; j < cols; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0014h],EAX
	jmp	OFFSET $L000658
$L000659:
	mov	EAX,dword ptr [EBP-20]
	inc	dword ptr [EBP-20]
$L000658:
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000660
;{

;{58}:if(Program::Sum == what)
	mov	EAX,000000001h
	push	EAX
	mov	EAX,dword ptr [EBP+0018h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000661

;{59}:Result= A[(i * cols + j) * sizeof (double)] + B[(i * cols + j) * sizeof (double)];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]
	jmp	OFFSET $L000662

; else {
$L000661:

;{61}:Result= A[(i * cols + j) * sizeof (double)] - B[(i * cols + j) * sizeof (double)];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]
$L000662:

; }

;{63}:Res[(i * cols + j) * sizeof (double)]= Result;
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 
;}
	jmp	OFFSET $L000659 
$L000660:
	jmp	OFFSET $L000656 
$L000657:

;{66}:Program::ShowMatrixForm(Res, rows, cols);
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	call	 Program_ShowMatrixForm

;{68}:destroy []Res;
	mov	EAX,dword ptr [EBP-4]
	test	EAX,EAX
	jz	OFFSET $L000663
	push	EAX
	call	 System_Memory_Destroy
$L000663:

;{69}:Res= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX
;}
$L000554:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000014h
Program_SumMatrices ENDP

Program_Traspose PROC NEAR 
;void Program::Traspose(double double [] M, int rM, int cM);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{31}:Res= new double[rM * cM];
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	imul	EAX,000000008h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000664
	mov	ESI,EAX 
	jmp	 $L000665
$L000664:
	xor	ESI,ESI
$L000665:
	mov	dword ptr [EBP-0004h],ESI 

;{33}:for(i= 0; i < rM; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L000666
$L000667:
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]
$L000666:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000668

;{34}:for(j= 0; j < cM; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000669
$L000670:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000669:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000671

;{35}:Res[(j * cM + i) * sizeof (double)]= M[(i * cM + j) * sizeof (double)];
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 
	jmp	OFFSET $L000670 
$L000671:
	jmp	OFFSET $L000667 
$L000668:

;{37}:Program::ShowMatrixForm(Res, rM, cM);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	call	 Program_ShowMatrixForm

;{39}:destroy []Res;
	mov	EAX,dword ptr [EBP-4]
	test	EAX,EAX
	jz	OFFSET $L000672
	push	EAX
	call	 System_Memory_Destroy
$L000672:

;{40}:Res= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX
;}
$L000544:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Program_Traspose ENDP

Program_main PROC NEAR 
;void Program::main(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000003Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{108}:Tr= 0.0;
	fldz
	fstp	qword ptr [EBP-0008h]

;{109}:bExitProgram= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-000Ch],AL

;{110}:bReEnterMatrices= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-0010h],AL

;{111}:while(true)
$L000673:
	mov	EAX,000000001h
	test	AL,AL
	jz	OFFSET $L000674
;{

;{113}:Console::ClearScreen();
	call	 Console_ClearScreen

;{114}:Console::WriteLn("Programa de Matrices\n\n");
	lea	EAX,OFFSET $S000580
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{115}:Console::WriteLn("Entre las dimensiones de dos matrices:\n");
	lea	EAX,OFFSET $S000581
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{116}:Console::Write("Entre las filas de A: ");
	lea	EAX,OFFSET $S000582
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{117}:rA= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0014h],EAX

;{118}:Console::Write("\nEntre las columnas de A: ");
	lea	EAX,OFFSET $S000584
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{119}:cA= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0018h],EAX

;{121}:Console::Write("\nEntre las filas de B: ");
	lea	EAX,OFFSET $S000586
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{122}:rB= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-001Ch],EAX

;{123}:Console::Write("\nEntre las columnas de B: ");
	lea	EAX,OFFSET $S000588
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{124}:cB= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0020h],EAX

;{126}:Console::ClearScreen();
	call	 Console_ClearScreen

;{128}:x= 'N';
	mov	EAX,00000004Eh
	mov	byte ptr [EBP-0024h],AL

;{129}:if(rA <= 0 || rB <= 0)
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jnz	OFFSET $L000677
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
$L000677:
	test	AL,AL
	jz	OFFSET $L000675
;{

;{131}:Console::WriteLn("El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
	lea	EAX,OFFSET $S000592
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{132}:x= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0024h],AL

;{133}:if(x == 'y' || x == 'Y')
	movsx	EAX,byte ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000079h
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000680
	movsx	EAX,byte ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000059h
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000680:
	test	AL,AL
	jz	OFFSET $L000678

;continue;
	jmp	OFFSET $L000673
$L000678:

;break;
	jmp	OFFSET $L000674
;}
$L000675:

;{138}:if(rA > 10 || rB > 10)
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jnz	OFFSET $L000683
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setg	AL
$L000683:
	test	AL,AL
	jz	OFFSET $L000681
;{

;{140}:Console::WriteLn("El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
	lea	EAX,OFFSET $S000592
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{141}:x= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0024h],AL

;{142}:if(x == 'y' || x == 'Y')
	movsx	EAX,byte ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000079h
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000686
	movsx	EAX,byte ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000059h
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000686:
	test	AL,AL
	jz	OFFSET $L000684

;continue;
	jmp	OFFSET $L000673
$L000684:

;break;
	jmp	OFFSET $L000674
;}
$L000681:

;{147}:if(cA <= 0 || cB <= 0)
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jnz	OFFSET $L000689
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
$L000689:
	test	AL,AL
	jz	OFFSET $L000687
;{

;{149}:Console::WriteLn("El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
	lea	EAX,OFFSET $S000596
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{150}:x= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0024h],AL

;{151}:if(x == 'y' || x == 'Y')
	movsx	EAX,byte ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000079h
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000692
	movsx	EAX,byte ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000059h
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000692:
	test	AL,AL
	jz	OFFSET $L000690

;continue;
	jmp	OFFSET $L000673
$L000690:

;break;
	jmp	OFFSET $L000674
;}
$L000687:

;{156}:if(cA > 10 || cB > 10)
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jnz	OFFSET $L000695
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setg	AL
$L000695:
	test	AL,AL
	jz	OFFSET $L000693
;{

;{158}:Console::WriteLn("El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
	lea	EAX,OFFSET $S000596
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{159}:x= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0024h],AL

;{160}:if(x == 'y' || x == 'Y')
	movsx	EAX,byte ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000079h
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000698
	movsx	EAX,byte ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000059h
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000698:
	test	AL,AL
	jz	OFFSET $L000696

;continue;
	jmp	OFFSET $L000673
$L000696:

;break;
	jmp	OFFSET $L000674
;}
$L000693:

;{165}:A= new double[rA * cA];
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBP-0018h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	imul	EAX,000000008h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000699
	mov	ESI,EAX 
	jmp	 $L000700
$L000699:
	xor	ESI,ESI
$L000700:
	mov	dword ptr [EBP-0028h],ESI 

;{166}:B= new double[rB * cB];
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0020h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	imul	EAX,000000008h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000701
	mov	ESI,EAX 
	jmp	 $L000702
$L000701:
	xor	ESI,ESI
$L000702:
	mov	dword ptr [EBP-002Ch],ESI 

;{168}:Console::WriteLn("Entre los valores para la matriz A[", rA, "][", cA, "]");
	lea	EAX,OFFSET $S000599
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000600
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000005Dh
	push	EAX 
	call	 Console_WriteChar 
	call	 Console_WriteCrLf 

;{169}:for(i= 0; i < rA; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0030h],EAX
	jmp	OFFSET $L000703
$L000704:
	mov	EAX,dword ptr [EBP-48]
	inc	dword ptr [EBP-48]
$L000703:
	mov	EAX,dword ptr [EBP-0030h]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000705

;{170}:for(j= 0; j < cA; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0034h],EAX
	jmp	OFFSET $L000706
$L000707:
	mov	EAX,dword ptr [EBP-52]
	inc	dword ptr [EBP-52]
$L000706:
	mov	EAX,dword ptr [EBP-0034h]
	push	EAX
	mov	EAX,dword ptr [EBP-0018h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000708
;{

;{172}:Console::Write("Elemento en A[", i, ",", j, "] = ");
	lea	EAX,OFFSET $S000604
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0030h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000002Ch
	push	EAX 
	call	 Console_WriteChar 
	mov	EAX,dword ptr [EBP-0034h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000605
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 

;{173}:A[(i * cA + j) * sizeof (double)]= Console::ReadDouble();
	mov	EAX,dword ptr [EBP-40]
	push	EAX
	mov	EAX,dword ptr [EBP-0030h]
	push	EAX
	mov	EAX,dword ptr [EBP-0018h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0034h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	call	 Console_ReadDouble
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 
;}
	jmp	OFFSET $L000707 
$L000708:
	jmp	OFFSET $L000704 
$L000705:

;{176}:Console::WriteLn("\nEntre los valores para la matriz B[", rB, "][", cB, "]");
	lea	EAX,OFFSET $S000606
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000600
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000005Dh
	push	EAX 
	call	 Console_WriteChar 
	call	 Console_WriteCrLf 

;{177}:for(i= 0; i < rB; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0030h],EAX
	jmp	OFFSET $L000709
$L000710:
	mov	EAX,dword ptr [EBP-48]
	inc	dword ptr [EBP-48]
$L000709:
	mov	EAX,dword ptr [EBP-0030h]
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000711

;{178}:for(j= 0; j < cB; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0034h],EAX
	jmp	OFFSET $L000712
$L000713:
	mov	EAX,dword ptr [EBP-52]
	inc	dword ptr [EBP-52]
$L000712:
	mov	EAX,dword ptr [EBP-0034h]
	push	EAX
	mov	EAX,dword ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000714
;{

;{180}:Console::Write("Elemento en B[", i, ",", j, "] = ");
	lea	EAX,OFFSET $S000607
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0030h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000002Ch
	push	EAX 
	call	 Console_WriteChar 
	mov	EAX,dword ptr [EBP-0034h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000605
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 

;{181}:B[(i * cB + j) * sizeof (double)]= Console::ReadDouble();
	mov	EAX,dword ptr [EBP-44]
	push	EAX
	mov	EAX,dword ptr [EBP-0030h]
	push	EAX
	mov	EAX,dword ptr [EBP-0020h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0034h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000008h
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	call	 Console_ReadDouble
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 
;}
	jmp	OFFSET $L000713 
$L000714:
	jmp	OFFSET $L000710 
$L000711:

;{185}:Console::WriteLn("Matriz A:\n");
	lea	EAX,OFFSET $S000608
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{186}:Program::ShowMatrixForm(A, rA, cA);
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-40]
	push	EAX
	call	 Program_ShowMatrixForm

;{187}:Console::WriteLn("\n\nMatriz B:\n");
	lea	EAX,OFFSET $S000609
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{188}:Program::ShowMatrixForm(B, rB, cB);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX 
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-44]
	push	EAX
	call	 Program_ShowMatrixForm

;do
$L000715:
;{

;{191}:Console::WriteLn("\n\nQue deseas hacer?\n");
	lea	EAX,OFFSET $S000610
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{192}:Console::WriteLn("0. Mostrar las Matrices\n1. Sumar las matrices.\n2. Restar las matrices.\n3. Multiplicar las matrices (A*B).\n4. Multiplicar las matrices (B*A).\n5. Calcular la traza de A\n6. Calcular la traza de B.\n7. Trasponer matriz A.\n8. Trasponer matriz B.\n9. Re-Entrar Matrices\n10. Salir\n\n");
	lea	EAX,OFFSET $S000611
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{193}:Console::Write(">:");
	lea	EAX,OFFSET $S000612
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{194}:nOption= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0038h],EAX

;{195}:switch(nOption)
	mov	EAX,dword ptr [EBP-0038h]
	mov	ESI,EAX
	xor	EAX,EAX
	cmp	EAX,ESI
	jz	OFFSET $L000719
	mov	EAX,000000001h
	cmp	EAX,ESI
	jz	OFFSET $L000720
	mov	EAX,000000002h
	cmp	EAX,ESI 
	jz	OFFSET $L000721 
	mov	EAX,000000003h
	cmp	EAX,ESI
	jz	OFFSET $L000727
	mov	EAX,000000004h
	cmp	EAX,ESI
	jz	OFFSET $L000730
	mov	EAX,000000005h
	cmp	EAX,ESI
	jz	OFFSET $L000733
	mov	EAX,000000006h
	cmp	EAX,ESI
	jz	OFFSET $L000734
	mov	EAX,000000007h
	cmp	EAX,ESI
	jz	OFFSET $L000735
	mov	EAX,000000008h
	cmp	EAX,ESI
	jz	OFFSET $L000738
	mov	EAX,000000009h
	cmp	EAX,ESI
	jz	OFFSET $L000741
	mov	EAX,00000000Ah
	cmp	EAX,ESI
	jz	OFFSET $L000742
	jmp	OFFSET $L000743
$L000719:
;{

;{198}:Console::WriteLn("Matriz A:\n");
	lea	EAX,OFFSET $S000608
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{199}:Program::ShowMatrixForm(A, rA, cA);
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-40]
	push	EAX
	call	 Program_ShowMatrixForm

;{200}:Console::WriteLn("\n\nMatriz B:\n");
	lea	EAX,OFFSET $S000609
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{201}:Program::ShowMatrixForm(B, rB, cB);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX 
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-44]
	push	EAX
	call	 Program_ShowMatrixForm
;}
	jmp	OFFSET $L000718
$L000720:
$L000721:
;{

;{207}:if(rA != rB || cA != cB)
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jnz	OFFSET $L000724
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,dword ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
$L000724:
	test	AL,AL
	jz	OFFSET $L000722
;{

;{209}:Console::WriteLn("Las matrices deben tener las mismas dimensiones para ser sumadas.");
	lea	EAX,OFFSET $S000614
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000723

; else {
$L000722:
;{

;{211}:Console::WriteLn("La matriz resultado:");
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{212}:Program::SumMatrices(A, B, rA, rB, nOption == 1 ? Program::Sum : Program::Substract);
	mov	EAX,dword ptr [EBP-0038h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	 $L000725
	mov	EAX,000000001h
	jmp	 $L000726
$L000725:
	mov	EAX,000000002h
$L000726:
	push	EAX 
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-44]
	push	EAX 
	mov	EAX,dword ptr [EBP-40]
	push	EAX
	call	 Program_SumMatrices
;}
$L000723:

; }
;}
	jmp	OFFSET $L000718
$L000727:
;{

;{218}:if(cA == rB)
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000728
;{

;{220}:Console::WriteLn("La matriz resultado C = A*B es:\n");
	lea	EAX,OFFSET $S000617
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{221}:Program::MultiplyMatrices(A, B, rA, cA, rB, cB);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX 
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-44]
	push	EAX 
	mov	EAX,dword ptr [EBP-40]
	push	EAX
	call	 Program_MultiplyMatrices
;}
	jmp	OFFSET $L000729

; else {
$L000728:

;{223}:Console::WriteLn("El numero de filas de B debe ser igual al numero de columnas de A.");
	lea	EAX,OFFSET $S000618
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000729:

; }
;}
	jmp	OFFSET $L000718
$L000730:
;{

;{228}:if(cB == rA)
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000731
;{

;{230}:Console::WriteLn("La matriz resultado C = B*A es:\n");
	lea	EAX,OFFSET $S000620
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{231}:Program::MultiplyMatrices(B, A, rB, cB, rA, cA);
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX 
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-40]
	push	EAX 
	mov	EAX,dword ptr [EBP-44]
	push	EAX
	call	 Program_MultiplyMatrices
;}
	jmp	OFFSET $L000732

; else {
$L000731:

;{233}:Console::WriteLn("El numero de filas de A debe ser igual al numero de columnas de B.");
	lea	EAX,OFFSET $S000621
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000732:

; }
;}
	jmp	OFFSET $L000718
$L000733:
;{

;{237}:Tr= Program::CalcTrace(A, rA, cA);
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-40]
	push	EAX
	call	 Program_CalcTrace
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{238}:Console::WriteLn("\nLa Traza de la matriz es = ", Tr);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000623
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000718
$L000734:
;{

;{242}:Tr= Program::CalcTrace(B, rB, cB);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX 
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-44]
	push	EAX
	call	 Program_CalcTrace
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{243}:Console::WriteLn("\nLa Traza de la matriz es = ", Tr);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000623
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000718
$L000735:
;{

;{247}:if(rA == cA)
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBP-0018h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000736
;{

;{249}:Console::WriteLn("La Traspuesta de la matriz es:");
	lea	EAX,OFFSET $S000626
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{250}:Program::Traspose(A, rA, cA);
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-40]
	push	EAX
	call	 Program_Traspose
;}
	jmp	OFFSET $L000737

; else {
$L000736:

;{252}:Console::WriteLn("Esta matriz no se puede trasponer ya que no es cuadrada.");
	lea	EAX,OFFSET $S000627
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000737:

; }
;}
	jmp	OFFSET $L000718
$L000738:
;{

;{256}:if(rB == cB)
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000739
;{

;{258}:Console::WriteLn("La Traspuesta de la matriz es:");
	lea	EAX,OFFSET $S000626
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{259}:Program::Traspose(B, rB, cB);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX 
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-44]
	push	EAX
	call	 Program_Traspose
;}
	jmp	OFFSET $L000740

; else {
$L000739:

;{261}:Console::WriteLn("Esta matriz no se puede trasponer ya que no es cuadrada.");
	lea	EAX,OFFSET $S000627
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000740:

; }
;}
	jmp	OFFSET $L000718
$L000741:
;{

;{266}:bReEnterMatrices= true;
	mov	EAX,000000001h
	mov	byte ptr [EBP-0010h],AL
;}
	jmp	OFFSET $L000718
$L000742:
;{

;{271}:bExitProgram= true;
	mov	EAX,000000001h
	mov	byte ptr [EBP-000Ch],AL
;}
	jmp	OFFSET $L000718
$L000743:
;{

;{276}:Console::WriteLn("Entrada desconocida. Favor seleccionar una opcion.");
	lea	EAX,OFFSET $S000630
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000718:

;{280}:if(false == bExitProgram)
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-000Ch]
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L000744
;{

;{282}:Console::WriteLn("\n\nPresione una tecla para regresar...");
	lea	EAX,OFFSET $S000631
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{283}:ch= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-003Ch],AL
;}
$L000744:
;}
$L000716:

;{283}:while(false == bExitProgram && false == bReEnterMatrices)
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-000Ch]
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L000746
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-0010h]
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000746:
	test	AL,AL
	jne	OFFSET $L000715
$L000717:

;{288}:destroy []A;
	mov	EAX,dword ptr [EBP-40]
	test	EAX,EAX
	jz	OFFSET $L000747
	push	EAX
	call	 System_Memory_Destroy
$L000747:

;{289}:destroy []B;
	mov	EAX,dword ptr [EBP-44]
	test	EAX,EAX
	jz	OFFSET $L000748
	push	EAX
	call	 System_Memory_Destroy
$L000748:

;{291}:if(bExitProgram)
	movzx	EAX,byte ptr [EBP-000Ch]
	test	AL,AL
	jz	OFFSET $L000749

;break;
	jmp	OFFSET $L000674
$L000749:

;{293}:if(bReEnterMatrices)
	movzx	EAX,byte ptr [EBP-0010h]
	test	AL,AL
	jz	OFFSET $L000751
;{

;{294}:bReEnterMatrices= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-0010h],AL

;continue;
	jmp	OFFSET $L000673
;}
$L000751:
;}
	jmp	OFFSET $L000673
$L000674:
;}
$L000576:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	call	 Program_main ;user entry point (stdcall calling convention)
	push	EAX
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

$S000531 		BYTE 	"  ",0
$S000611 		BYTE 	"0. Mostrar las Matrices",0Ah,"1. Sumar las matrices.",0Ah,"2. Restar las matrices.",0Ah,"3. Multiplicar las matrices (A*B).",0Ah,"4. Multiplicar las matrices (B*A).",0Ah,"5. Calcular la traza de A",0Ah,"6. Calcular la traza de B.",0Ah,"7. Trasponer matriz A.",0Ah,"8. Trasponer matriz B.",0Ah,"9. Re-Entrar Matrices",0Ah,"10. Salir",0Ah,0Ah,0
$S000612 		BYTE 	">:",0
$S000596 		BYTE 	"El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?",0
$S000621 		BYTE 	"El numero de filas de A debe ser igual al numero de columnas de B.",0
$S000618 		BYTE 	"El numero de filas de B debe ser igual al numero de columnas de A.",0
$S000575 		BYTE 	"El numero de filas de B debe ser igual al numero de filas de A.",0
$S000592 		BYTE 	"El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?",0
$S000604 		BYTE 	"Elemento en A[",0
$S000607 		BYTE 	"Elemento en B[",0
$S000630 		BYTE 	"Entrada desconocida. Favor seleccionar una opcion.",0
$S000581 		BYTE 	"Entre las dimensiones de dos matrices:",0Ah,0
$S000582 		BYTE 	"Entre las filas de A: ",0
$S000599 		BYTE 	"Entre los valores para la matriz A[",0
$S000627 		BYTE 	"Esta matriz no se puede trasponer ya que no es cuadrada.",0
$S000626 		BYTE 	"La Traspuesta de la matriz es:",0
$S000617 		BYTE 	"La matriz resultado C = A*B es:",0Ah,0
$S000620 		BYTE 	"La matriz resultado C = B*A es:",0Ah,0
$S000615 		BYTE 	"La matriz resultado:",0
$S000614 		BYTE 	"Las matrices deben tener las mismas dimensiones para ser sumadas.",0
$S000541 		BYTE 	"M[",0
$S000608 		BYTE 	"Matriz A:",0Ah,0
$S000580 		BYTE 	"Programa de Matrices",0Ah,0Ah,0
$S000574 		BYTE 	"Res[",0
$S000584 		BYTE 	0Ah,"Entre las columnas de A: ",0
$S000588 		BYTE 	0Ah,"Entre las columnas de B: ",0
$S000586 		BYTE 	0Ah,"Entre las filas de B: ",0
$S000606 		BYTE 	0Ah,"Entre los valores para la matriz B[",0
$S000623 		BYTE 	0Ah,"La Traza de la matriz es = ",0
$S000609 		BYTE 	0Ah,0Ah,"Matriz B:",0Ah,0
$S000631 		BYTE 	0Ah,0Ah,"Presione una tecla para regresar...",0
$S000610 		BYTE 	0Ah,0Ah,"Que deseas hacer?",0Ah,0
$S000529 		BYTE 	0Ah,"| ",0
$S000605 		BYTE 	"] = ",0
$S000543 		BYTE 	"]= ",0
$S000600 		BYTE 	"][",0
$S000532 		BYTE 	"| ",0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000020h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count

END __System_Hpp_Runtime_Init

