TITLE	 hello.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE stdhpp\hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{389}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000469
;}
$L000469:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000486
;}
$L000486:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000492
;}
$L000492:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000490
;}
$L000490:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000483
;}
$L000483:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000500
;}
$L000500:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000506
;}
$L000506:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000497
;}
$L000497:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000502
;}
$L000502:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{384}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_RadiansToDegrees ENDP

Samples_Cotorra_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{33}:Console::WriteLn("in the Destructor()...\n");
	lea	EAX,OFFSET $S000532
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{34}:if(what != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L000623

;{35}:destroy []what;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	test	EAX,EAX
	jz	OFFSET $L000625
	push	EAX
	call	 System_Memory_Destroy
$L000625:
$L000623:
;}
$L000531:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Samples_Cotorra_Destructor ENDP

Samples_Cotorra_Listen PROC NEAR 
;void Listen(string phrase);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{17}:n= StringHandling::StringLength(phrase);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	call	 StringHandling_StringLength
	mov	dword ptr [EBP-0004h],EAX

;{18}:if(what != null)
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L000626

;{19}:destroy []what;
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	test	EAX,EAX
	jz	OFFSET $L000628
	push	EAX
	call	 System_Memory_Destroy
$L000628:
$L000626:

;{21}:what= new char[n + 1];
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	imul	EAX,000000001h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000629
	mov	ESI,EAX 
	jmp	 $L000630
$L000629:
	xor	ESI,ESI
$L000630:
	mov	ECX,dword ptr [EBP-0008h]
	mov	dword ptr [ECX],ESI 

;{22}:StringHandling::StringCopy(what, phrase, n);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX 
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	call	 StringHandling_StringCopy

;{23}:what[n]= ' ';
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	xor	EAX,EAX
	pop	EBX
	mov	dword ptr [EBX],EAX
;}
$L000526:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Samples_Cotorra_Listen ENDP

Samples_Cotorra_Talk PROC NEAR 
;void Talk(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{28}:Console::WriteLn(what);
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000530:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Samples_Cotorra_Talk ENDP

Samples_Cotorra PROC NEAR 
;void Samples::Cotorra(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 __member_Init@Samples_Cotorra

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Samples_Cotorra ENDP

Samples_SimpleProbability_CalcMedia PROC NEAR 
;double CalcMedia(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
;{

;{68}:n= 12;
	mov	EAX,00000000Ch
	mov	dword ptr [EBP-0004h],EAX

;{69}:media= 0.0;
	fldz
	fstp	qword ptr [EBP-000Ch]

;{70}:for(i= 0; i <= n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000632
$L000633:
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
$L000632:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000634
;{

;{72}:media= media + array[i];
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]
;}
	jmp	OFFSET $L000633 
$L000634:

;{75}:media= media / n;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP-0004h]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]

;{79}:return media
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	jmp	OFFSET $L000562
;}
$L000562:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Samples_SimpleProbability_CalcMedia ENDP

Samples_SimpleProbability_CalcStdDev PROC NEAR 
;double CalcStdDev(double mean);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{100}:return Math::Sqrt(CalcVariance(mean))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Samples_SimpleProbability_CalcVariance
	push	EAX
	push	EDX 
	call	 Math_Sqrt
	jmp	OFFSET $L000573
;}
$L000573:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Samples_SimpleProbability_CalcStdDev ENDP

Samples_SimpleProbability_CalcVariance PROC NEAR 
;double CalcVariance(double mean);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
;{

;{84}:n= 12;
	mov	EAX,00000000Ch
	mov	dword ptr [EBP-0004h],EAX

;{85}:variance= 0.0;
	fldz
	fstp	qword ptr [EBP-000Ch]

;{86}:for(i= 0; i <= n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000635
$L000636:
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
$L000635:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000637
;{

;{90}:variance= variance + Math::Pow(Math::Abs(mean - array[i]), 2.0);
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	xor	EDX,EDX
	mov	EAX,040000000h
	push	EAX 
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Abs
	push	EAX
	push	EDX 
	call	 Math_Pow
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]
;}
	jmp	OFFSET $L000636 
$L000637:

;{93}:variance= variance / (n - 1);
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]

;{95}:return variance
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	jmp	OFFSET $L000567
;}
$L000567:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Samples_SimpleProbability_CalcVariance ENDP

Samples_SimpleProbability_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{105}:Console::WriteLn("In the Simple Destructor()...\n");
	lea	EAX,OFFSET $S000576
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000575:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Samples_SimpleProbability_Destructor ENDP

Samples_SimpleProbability_Fibonacci PROC NEAR 
;unsigned Fibonacci(unsigned n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
;{

;{131}:if(n == 0 || n == 1)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000640
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
$L000640:
	test	AL,AL
	jz	OFFSET $L000638

;{132}:return n
	mov	EAX,dword ptr [EBP+0008h]
	jmp	OFFSET $L000581
$L000638:

;{134}:a= Fibonacci((n + 1) div 2);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	mov	ECX,dword ptr [EBP-000Ch]
	call	 Samples_SimpleProbability_Fibonacci
	mov	dword ptr [EBP-0004h],EAX

;{135}:b= Fibonacci(((n + 1) div 2) - 1);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-000Ch]
	call	 Samples_SimpleProbability_Fibonacci
	mov	dword ptr [EBP-0008h],EAX

;{137}:if(n % 2 == 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000641

;{138}:return a * (a + 2 * b)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000002h
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	pop	EDX
	add	EAX,EDX
	pop	ECX
	cdq	
	imul	EAX,ECX
	jmp	OFFSET $L000581

; else {
$L000641:

;{140}:return a * a + b * b
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	EDX
	add	EAX,EDX
	jmp	OFFSET $L000581
$L000642:

; }
;}
$L000581:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Samples_SimpleProbability_Fibonacci ENDP

Samples_SimpleProbability_Init PROC NEAR 
;void Init(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{45}:array[0]= 3.1414124545234;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0DA5B6696h
	mov	EAX,04009219Ch 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{46}:array[1]= 3.0023452345234;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000001h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0940CA2B9h
	mov	EAX,0400804CDh 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{47}:array[2]= 2.9234655634676;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000002h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0E9D09ABCh
	mov	EAX,040076341h 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{48}:array[3]= 3.87345634673673;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000003h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0AE5DBE3Eh
	mov	EAX,0400EFCD6h 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{49}:array[4]= 3.99994523453452;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000004h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,04980EF3Ch
	mov	EAX,0400FFFE3h 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{50}:array[5]= 4.123452345345345;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000005h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,04AA77DB4h
	mov	EAX,040107E6Ah 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{51}:array[6]= 4.0000223412342;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000006h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0DB4B7B21h
	mov	EAX,040100005h 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{52}:array[7]= 4.0;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000007h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	xor	EDX,EDX
	mov	EAX,040100000h
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{53}:array[8]= 4.0012341234124;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000008h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0849EC82Eh
	mov	EAX,040100143h 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{54}:array[9]= 2.7567845684758;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000009h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0115DC4ADh
	mov	EAX,040060DE5h 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{55}:array[10]= 3.9345634523;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,00000000Ah
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0673D52A6h
	mov	EAX,0400F79FCh 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{56}:array[11]= 2.64756745674;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,00000000Bh
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0D8C537B2h
	mov	EAX,040052E37h 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{57}:array[12]= 3.905879567847563;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,00000000Ch
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,0C97028C0h
	mov	EAX,0400F3F3Dh 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 
;}
$L000536:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Samples_SimpleProbability_Init ENDP

Samples_SimpleProbability_Power PROC NEAR 
;int Power(int x, int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{110}:if(n == 0)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000643

;{111}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L000577

; else {
$L000643:

;{112}:if(n == 1)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000645

;{113}:return x
	mov	EAX,dword ptr [EBP+0008h]
	jmp	OFFSET $L000577
$L000645:
$L000644:

; }

;{114}:result= 1;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX

;{115}:while(n > 0)
$L000647:
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L000648
;{

;{116}:if(n % 2 == 0)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000649
;{

;{118}:result*= (x * x);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	lea	EBX,dword ptr [EBP-0004h]
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX

;{119}:n-= 2;
	mov	EAX,000000002h
	clc	
	sub	dword ptr [EBP+000Ch],EAX
;}
	jmp	OFFSET $L000650

; else {
$L000649:
;{

;{122}:result*= (x * x * x);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ECX 
	cdq	 
	imul	EAX,ECX 
	lea	EBX,dword ptr [EBP-0004h]
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX

;{123}:n-= 3;
	mov	EAX,000000003h
	clc	
	sub	dword ptr [EBP+000Ch],EAX
;}
$L000650:

; }
;}
	jmp	OFFSET $L000647
$L000648:

;{126}:return result
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000577
;}
$L000577:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Samples_SimpleProbability_Power ENDP

Samples_SimpleProbability_PrintPrettySeq1 PROC NEAR 
;void PrintPrettySeq1(int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{147}:i= Power(n - 1, 2) + 1;
	mov	EAX,000000002h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Samples_SimpleProbability_Power
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX

;{148}:m= Power(n, 2) + 1;
	mov	EAX,000000002h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Samples_SimpleProbability_Power
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX

;{149}:for(j= i; j < m; j++ )
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000651
$L000652:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000651:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000653
;{

;{150}:Console::Write(j);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	call	 Console_WriteInteger

;{151}:if(j < (m - 1))
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000654

;{152}:Console::Write("+");
	mov	EAX,00000002Bh
	push	EAX
	call	 Console_WriteChar
$L000654:
;}
	jmp	OFFSET $L000652 
$L000653:

;{154}:Console::WriteLn("\t= ", Power(n - 1, 3), " + ", Power(n, 3));
	lea	EAX,OFFSET $S000591
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Samples_SimpleProbability_Power
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000592
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,000000003h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Samples_SimpleProbability_Power
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000585:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Samples_SimpleProbability_PrintPrettySeq1 ENDP

Samples_SimpleProbability_PrintPrettySeq2 PROC NEAR 
;void PrintPrettySeq2(int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{159}:i= Power(n, 2) - n + 1;
	mov	EAX,000000002h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Samples_SimpleProbability_Power
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	pop	EDX 
	add	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX

;{160}:m= Power(n, 2) + n - 1;
	mov	EAX,000000002h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Samples_SimpleProbability_Power
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	pop	EDX 
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX

;{161}:for(j= 0; j < n; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L000656
$L000657:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L000656:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000658
;{

;{162}:Console::Write(i + 2 * j);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000002h
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	pop	EDX
	add	EAX,EDX
	push	EAX
	call	 Console_WriteInteger

;{163}:if(j < (n - 1) && i < m)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000661
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
$L000661:
	test	AL,AL
	jz	OFFSET $L000659

;{164}:Console::Write("+");
	mov	EAX,00000002Bh
	push	EAX
	call	 Console_WriteChar
$L000659:
;}
	jmp	OFFSET $L000657 
$L000658:

;{167}:Console::WriteLn(" \t= ", Power(n, 3));
	lea	EAX,OFFSET $S000598
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	call	 Samples_SimpleProbability_Power
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000593:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Samples_SimpleProbability_PrintPrettySeq2 ENDP

Samples_SimpleProbability PROC NEAR 
;void Samples::SimpleProbability(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 __member_Init@Samples_SimpleProbability
;{

;{62}:Init();
	mov	ECX,dword ptr [EBP-0004h]
	call	 Samples_SimpleProbability_Init
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Samples_SimpleProbability ENDP

__member_Init@Samples_Cotorra PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:what= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__member_Init@Samples_Cotorra ENDP
__member_Init@Samples_SimpleProbability PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:array= new double[20];
	mov	EAX,000000014h
	imul	EAX,000000008h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000662
	mov	ESI,EAX 
	jmp	 $L000663
$L000662:
	xor	ESI,ESI
$L000663:
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],ESI 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__member_Init@Samples_SimpleProbability ENDP
Samples_Application_main PROC NEAR 
;void Samples::Application::main(int argc, string string [] argv);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000024h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{189}:simple= new Samples::SimpleProbability();
	push	000000004h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000664
	mov	ESI,EAX
	jmp	 $L000665
$L000664:
	xor	ESI,ESI
$L000665:
	mov	dword ptr [EBP-0004h],ESI 
	mov	ECX,ESI
	call	 Samples_SimpleProbability
	mov	EAX,ESI 

;{191}:media= simple.CalcMedia();
	mov	ECX,dword ptr [EBP-4]
	call	 Samples_SimpleProbability_CalcMedia
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]

;{193}:Console::WriteLn("(2)And the mean is = ", media);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000605
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{195}:Console::WriteLn("(*) (mean / 4.0)% = ", (media / 4.0) * 100.0);
	lea	EAX,OFFSET $S000606
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	xor	EDX,EDX
	mov	EAX,040100000h
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	xor	EDX,EDX
	mov	EAX,040590000h
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{197}:variance= simple.CalcVariance(media);
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	call	 Samples_SimpleProbability_CalcVariance
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0014h]

;{199}:Console::WriteLn("(3) the variance is = ", variance);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000609
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{201}:stddev= simple.CalcStdDev(media);
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	call	 Samples_SimpleProbability_CalcStdDev
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-001Ch]

;{203}:Console::WriteLn("(4) the std dev is = ", stddev);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000611
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-001Ch]
	mov	EAX,dword ptr [EBP-0018h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{205}:Console::WriteLn("(5) media + stdev = ", media + stddev);
	lea	EAX,OFFSET $S000612
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-001Ch]
	mov	EAX,dword ptr [EBP-0018h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{208}:Console::Write("Please, enter the number n = ");
	lea	EAX,OFFSET $S000613
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{209}:n= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0020h],EAX

;{210}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{211}:Console::WriteLn("Calculate the Sum[i, {i,(n-1)^2 + 1},{m, 2n-1}]\t= \t(n-1)^3 + n^3.\n");
	lea	EAX,OFFSET $S000616
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{212}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{213}:for(i= 1; i <= n; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0024h],EAX
	jmp	OFFSET $L000666
$L000667:
	mov	EAX,dword ptr [EBP-36]
	inc	dword ptr [EBP-36]
$L000666:
	mov	EAX,dword ptr [EBP-0024h]
	push	EAX
	mov	EAX,dword ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000668

;{214}:simple.PrintPrettySeq1(i);
	mov	EAX,dword ptr [EBP-0024h]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	call	 Samples_SimpleProbability_PrintPrettySeq1
	jmp	OFFSET $L000667 
$L000668:

;{215}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{216}:Console::WriteLn("Calculate the Sum[i+2*j, {j, 0}, {i,n^2-n+1},{m, n^2+n-1}, {n}]\t= \tn^3.\n");
	lea	EAX,OFFSET $S000618
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{217}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{218}:for(i= 1; i <= n; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0024h],EAX
	jmp	OFFSET $L000669
$L000670:
	mov	EAX,dword ptr [EBP-36]
	inc	dword ptr [EBP-36]
$L000669:
	mov	EAX,dword ptr [EBP-0024h]
	push	EAX
	mov	EAX,dword ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000671

;{219}:simple.PrintPrettySeq2(i);
	mov	EAX,dword ptr [EBP-0024h]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	call	 Samples_SimpleProbability_PrintPrettySeq2
	jmp	OFFSET $L000670 
$L000671:

;{220}:Console::WriteLn("--------------------------------------------");
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{222}:for(i= 1; i <= n; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0024h],EAX
	jmp	OFFSET $L000672
$L000673:
	mov	EAX,dword ptr [EBP-36]
	inc	dword ptr [EBP-36]
$L000672:
	mov	EAX,dword ptr [EBP-0024h]
	push	EAX
	mov	EAX,dword ptr [EBP-0020h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000674

;{223}:Console::WriteLn(simple.Fibonacci(i));
	mov	EAX,dword ptr [EBP-0024h]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	call	 Samples_SimpleProbability_Fibonacci
	push	EAX
	call	 Console_WriteInteger
	call	 Console_WriteCrLf 
	jmp	OFFSET $L000673 
$L000674:

;{224}:destroy simple;
	mov	ECX,dword ptr [EBP-4]
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L000676
	call	 Samples_SimpleProbability_Destructor
$L000676:
	push	ESI
	call	 System_Memory_Destroy

;{226}:Console::WriteLn("Gcd = ", Math::Gcd(14, Math::Gcd(28, Math::Gcd(7, 56))));
	lea	EAX,OFFSET $S000619
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000038h
	push	EAX 
	mov	EAX,000000007h
	push	EAX
	call	 Math_Gcd
	push	EAX 
	mov	EAX,00000001Ch
	push	EAX
	call	 Math_Gcd
	push	EAX 
	mov	EAX,00000000Eh
	push	EAX
	call	 Math_Gcd
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000600:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Samples_Application_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	lea	EBX,dword ptr ___argc
	push	EBX
	call	 System_GetCommandLineArgv 
	mov	dword ptr ___argv,EAX 
	push	EAX 
	mov	ECX,dword ptr ___argc 
	push	ECX 
	call	 Samples_Application_main ;user entry point (stdcall calling convention)
	push	EAX 
	mov	EAX,dword ptr ___argv 
	push	EAX 
	call	 System_Memory_GetProcessHeap 
	push	EAX 
	call	 System_Memory_Free 
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

$S000592 		BYTE 	" + ",0
$S000598 		BYTE 	" ",09h,"= ",0
$S000606 		BYTE 	"(*) (mean / 4.0)% = ",0
$S000605 		BYTE 	"(2)And the mean is = ",0
$S000609 		BYTE 	"(3) the variance is = ",0
$S000611 		BYTE 	"(4) the std dev is = ",0
$S000612 		BYTE 	"(5) media + stdev = ",0
$S000615 		BYTE 	"--------------------------------------------",0
$S000618 		BYTE 	"Calculate the Sum[i+2*j, {j, 0}, {i,n^2-n+1},{m, n^2+n-1}, {n}]",09h,"= ",09h,"n^3.",0Ah,0
$S000616 		BYTE 	"Calculate the Sum[i, {i,(n-1)^2 + 1},{m, 2n-1}]",09h,"= ",09h,"(n-1)^3 + n^3.",0Ah,0
$S000619 		BYTE 	"Gcd = ",0
$S000576 		BYTE 	"In the Simple Destructor()...",0Ah,0
$S000613 		BYTE 	"Please, enter the number n = ",0
$S000591 		BYTE 	09h,"= ",0
$S000532 		BYTE 	"in the Destructor()...",0Ah,0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000020h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count

END __System_Hpp_Runtime_Init

