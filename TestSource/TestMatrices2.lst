Microsoft (R) Macro Assembler Version 6.15.8803		    11/24/11 23:49:49
TestMatrices2.hpp					     Page 1 - 1


				TITLE	 TestMatrices2.hpp
				SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


					.486P
					.MODEL flat,stdcall
					.STACK 000100000h
					INCLUDE stdhpp\hcclib32.INC	; the H++ library.
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C ; when the "C" calling convension is used, then we must use :PROC;
			      C ; when the stdcall calling convension is used, we must use :PROTO;
			      C 
			      C EXTERN __purecall: PROTO;
			      C 
			      C ; H++  C O N S O L E   A P I s 
			      C 
			      C EXTERN Console_ClearScreen:PROTO;
			      C EXTERN Console_ReadString:PROTO;
			      C EXTERN Console_ReadChar:PROTO;
			      C EXTERN Console_WriteString:PROTO;
			      C EXTERN Console_WriteCrlf:PROTO;
			      C EXTERN Console_WriteChar:PROTO;
			      C EXTERN Console_SetCursorPos:PROTO;
			      C EXTERN Console_SetTextColor:PROTO;
			      C EXTERN Console_SetConsoleSize:PROTO;
			      C EXTERN Console_SetTitle:PROTO;
			      C EXTERN Console_GetTitle:PROTO;
			      C EXTERN Console_MoveWindow:PROTO;
			      C 
			      C EXTERN Console_ReadDouble:PROTO;
			      C EXTERN Console_ReadInteger:PROTO;
			      C EXTERN Console_WriteDouble:PROTO;
			      C EXTERN Console_WriteInteger:PROTO;
			      C EXTERN Console_WriteInteger64:PROTO;
			      C EXTERN Console_WriteBoolean:PROTO;
			      C 
			      C ; H++  F I L E   A P I s 
			      C 
			      C EXTERN File_Open:PROTO;
			      C EXTERN File_Close:PROTO;
			      C EXTERN File_Read:PROTO;
			      C EXTERN File_Write:PROTO;
			      C EXTERN File_Seek:PROTO;
			      C EXTERN File_FileSize:PROTO;
			      C 
			      C ; H++  S Y S T E M   A P I s 
			      C 
			      C EXTERN System_Exit:PROTO;
			      C EXTERN System_LastError:PROTO;
			      C EXTERN System_CommandLineArgs:PROTO;
			      C EXTERN System_Execute:PROTO;
			      C EXTERN System_GetTickCount:PROTO;
			      C EXTERN System_Sleep:PROTO;
			      C EXTERN System_Debug_OutputString:PROTO;
			      C EXTERN System_BreakPoint:PROTO;
			      C EXTERN System_IsDebuggerPresent:PROTO;
			      C 
			      C ; H++  M A T H   A P I s
			      C 
			      C EXTERN Math_Init:PROTO;
			      C EXTERN Math_Abs:PROTO;
			      C EXTERN Math_ChangeSign:PROTO;
			      C EXTERN Math_Sqrt:PROTO;
			      C EXTERN Math_Sqr:PROTO;
			      C 
			      C EXTERN Math_Sin:PROTO;
			      C EXTERN Math_Cos:PROTO;
			      C EXTERN Math_Tan:PROTO;
			      C EXTERN Math_ArcTan:PROTO;
			      C EXTERN Math_Round:PROTO;
			      C 
			      C EXTERN Math_Modulus:PROTO;
			      C EXTERN Math_IEEEModulus:PROTO;
			      C EXTERN Math_ModulusTruncateDivisor:PROTO;
			      C 
			      C EXTERN Math_Ln:PROTO;
			      C EXTERN Math_log2:PROTO;
			      C EXTERN Math_log10:PROTO;
			      C EXTERN Math_Exp:PROTO;
			      C 
			      C EXTERN Math_MantissaOf:PROTO;
			      C EXTERN Math_GetNumberFrom:PROTO;
			      C EXTERN Math_LogN_base:PROTO;
			      C 
			      C EXTERN Math_Max:PROTO;
			      C EXTERN Math_Min:PROTO;
			      C EXTERN Math_Sign:PROTO;
			      C EXTERN Math_Pow2:PROTO;
			      C EXTERN Math_Pow:PROTO;
			      C EXTERN Math_Gcd:PROTO;
			      C EXTERN Math_Odd:PROTO;
			      C EXTERN Math_Even:PROTO;
			      C EXTERN Math_Trunc:PROTO;
			      C 
			      C ; N O N - I N T R I N S I C   M A T H   F U N C T I O N S 
			      C 
			      C EXTERN Math_Cotan:PROTO;
			      C EXTERN Math_Sec:PROTO;
			      C EXTERN Math_Cosec:PROTO;
			      C EXTERN Math_Inverse_Arcsin:PROTO;
			      C EXTERN Math_Inverse_Arccos:PROTO;
			      C EXTERN Math_Inverse_Arcsec:PROTO;
			      C EXTERN Math_Inverse_Arccosec:PROTO;
			      C EXTERN Math_Inverse_Arccotan:PROTO;
			      C 
			      C ; M A T H   C O N S T A N T S  
			      C EXTERN Math_pi:PROTO;
			      C EXTERN Math_log_10_base2:PROTO;
			      C EXTERN Math_log_e_base2:PROTO;
			      C EXTERN Math_log_2_base10:PROTO;
			      C EXTERN Math_log_2_base_e:PROTO;
			      C 
			      C 
			      C ; I N T E G E R   S P E C I F I C S   ( U T I L I T I E S )
			      C EXTERN Integer_toStringEx:PROTO;
			      C EXTERN Integer_toString:PROTO;
			      C EXTERN Integer_fromString:PROTO;
			      C 
			      C 
			      C ; F L O A T I N G   P O I N T   S P E C I F I C  (U T I L I T I E S )
			      C 
			      C EXTERN FloatingPoint_Compare:PROTO;
			      C EXTERN FloatingPoint_CompareToInteger:PROTO;
			      C EXTERN FloatingPoint_ToInt:PROTO;
			      C EXTERN FloatingPoint_ToInt64:PROTO;
			      C EXTERN FloatingPoint_FromInt:PROTO;
			      C EXTERN FloatingPoint_FromInt64:PROTO;
			      C 
			      C EXTERN FloatingPoint_toString:PROTO;
			      C EXTERN FloatingPoint_toStringEx:PROTO;
			      C EXTERN FloatingPoint_fromString:PROTO;
			      C 
			      C ; H++  S T R I N G  H A N D L I N G   A P I s 
			      C 
			      C EXTERN StringHandling_StringLength2:PROTO;
			      C EXTERN StringHandling_StringLength:PROTO;
			      C EXTERN StringHandling_StringCopy:PROTO;
			      C EXTERN StringHandling_StringCompare:PROTO;
			      C EXTERN StringHandling_StringUCase:PROTO;
			      C EXTERN StringHandling_StringLCase:PROTO;
			      C EXTERN StringHandling_StringSet:PROTO;
			      C 
			      C ; H++  M E M O R Y   H A N D L I N G   A P I s
			      C 
			      C EXTERN System_Memory_Memset:PROTO;
			      C EXTERN System_Memory_GetProcessHeap:PROTO
			      C EXTERN System_Memory_Alloc:PROTO
			      C EXTERN System_Memory_Free:PROTO
			      C EXTERN System_Memory_Size:PROTO
			      C EXTERN System_Memory_New:PROTO
			      C EXTERN System_Memory_Destroy:PROTO
			      C EXTERN System_Memory_SizeFor:PROTO
			      C 
			      C 
			      C EXTERN System_GetCommandLineArgv:PROTO;
			      C 
			      C EXTERN System_ShowMessage:PROTO;
			      C 
			      C EXTERN ConsoleHandle:DWORD;
			      C ;
			      C .LIST
			      C 

				;Windows API prototypes
				GetVersion PROTO

				;This assembly file was generated by the 32-bit H++ Compiler

 00000000			.CODE ;code segment
 00000000			Math_DegreesToRadians PROC NEAR 
				;double Math::DegreesToRadians(double deg);
 00000000  55				push	EBP
 00000001  8B EC			mov	EBP,ESP
 00000003  51				push	ECX 
 00000004  53				push	EBX 
 00000005  56				push	ESI 
 00000006  57				push	EDI 
				;{

				;{389}:return (deg * Math::pi()) / 180
 00000007  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000000A  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000000D  50				push	EAX
 0000000E  52				push	EDX 
 0000000F  E8 00000000 E		call	 Math_pi
 00000014  9B DB E2			fclex
 00000017  50				push	EAX
 00000018  52				push	EDX 
 00000019  DD 04 24			fld	qword ptr [ESP]
 0000001C  59				pop	ECX
 0000001D  59				pop	ECX 
 0000001E  DC 0C 24			fmul	qword ptr [ESP]
 00000021  DD 1C 24			fstp	qword ptr [ESP]
 00000024  B8 000000B4			mov	EAX,0000000B4h
 00000029  9B DB E2			fclex
 0000002C  50				push	EAX
 0000002D  E8 00000000 E		call	 FloatingPoint_FromInt
 00000032  50				push	EAX
 00000033  52				push	EDX 
 00000034  DD 04 24			fld	qword ptr [ESP]
 00000037  59				pop	ECX
 00000038  59				pop	ECX 
 00000039  DC 3C 24			fdivr	qword ptr [ESP]
 0000003C  DD 1C 24			fstp	qword ptr [ESP]
 0000003F  5A				pop	EDX
 00000040  58				pop	EAX 
 00000041  EB 00			jmp	OFFSET $L000469
				;}
 00000043			$L000469:

 00000043  5F				pop	EDI
 00000044  5E				pop	ESI 
 00000045  5B				pop	EBX 
 00000046  8B E5			mov	ESP,EBP
 00000048  5D				pop	EBP 
 00000049  C2 0008			retn	000000008h
 0000004C			Math_DegreesToRadians ENDP

 0000004C			Math_Hyperbolic_HCos PROC NEAR 
				;double Math::Hyperbolic::HCos(double X);
 0000004C  55				push	EBP
 0000004D  8B EC			mov	EBP,ESP
 0000004F  51				push	ECX 
 00000050  53				push	EBX 
 00000051  56				push	ESI 
 00000052  57				push	EDI 
				;{

				;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
 00000053  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000056  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000059  50				push	EAX
 0000005A  52				push	EDX 
 0000005B  E8 00000000 E		call	 Math_Exp
 00000060  50				push	EAX
 00000061  52				push	EDX 
 00000062  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000065  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000068  50				push	EAX
 00000069  52				push	EDX 
 0000006A  DD 04 24			fld	qword ptr [ESP]
 0000006D  D9 E0			fchs
 0000006F  DD 1C 24			fstp	qword ptr [ESP]
 00000072  E8 00000000 E		call	 Math_Exp
 00000077  50				push	EAX
 00000078  52				push	EDX 
 00000079  DD 04 24			fld	qword ptr [ESP]
 0000007C  59				pop	ECX
 0000007D  59				pop	ECX 
 0000007E  DC 04 24			fadd	qword ptr [ESP]
 00000081  DD 1C 24			fstp	qword ptr [ESP]
 00000084  B8 00000002			mov	EAX,000000002h
 00000089  9B DB E2			fclex
 0000008C  50				push	EAX
 0000008D  E8 00000000 E		call	 FloatingPoint_FromInt
 00000092  50				push	EAX
 00000093  52				push	EDX 
 00000094  DD 04 24			fld	qword ptr [ESP]
 00000097  59				pop	ECX
 00000098  59				pop	ECX 
 00000099  DC 3C 24			fdivr	qword ptr [ESP]
 0000009C  DD 1C 24			fstp	qword ptr [ESP]
 0000009F  5A				pop	EDX
 000000A0  58				pop	EAX 
 000000A1  EB 00			jmp	OFFSET $L000486
				;}
 000000A3			$L000486:

 000000A3  5F				pop	EDI
 000000A4  5E				pop	ESI 
 000000A5  5B				pop	EBX 
 000000A6  8B E5			mov	ESP,EBP
 000000A8  5D				pop	EBP 
 000000A9  C2 0008			retn	000000008h
 000000AC			Math_Hyperbolic_HCos ENDP

 000000AC			Math_Hyperbolic_HCosec PROC NEAR 
				;double Math::Hyperbolic::HCosec(double X);
 000000AC  55				push	EBP
 000000AD  8B EC			mov	EBP,ESP
 000000AF  51				push	ECX 
 000000B0  53				push	EBX 
 000000B1  56				push	ESI 
 000000B2  57				push	EDI 
				;{

				;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
 000000B3  B8 00000002			mov	EAX,000000002h
 000000B8  50				push	EAX
 000000B9  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000000BC  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000000BF  50				push	EAX
 000000C0  52				push	EDX 
 000000C1  E8 00000000 E		call	 Math_Exp
 000000C6  50				push	EAX
 000000C7  52				push	EDX 
 000000C8  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000000CB  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000000CE  50				push	EAX
 000000CF  52				push	EDX 
 000000D0  DD 04 24			fld	qword ptr [ESP]
 000000D3  D9 E0			fchs
 000000D5  DD 1C 24			fstp	qword ptr [ESP]
 000000D8  E8 00000000 E		call	 Math_Exp
 000000DD  50				push	EAX
 000000DE  52				push	EDX 
 000000DF  DD 04 24			fld	qword ptr [ESP]
 000000E2  59				pop	ECX
 000000E3  59				pop	ECX 
 000000E4  DD 04 24			fld	qword ptr [ESP]
 000000E7  D8 E1			fsub	st,st(1)
 000000E9  DD 1C 24			fstp	qword ptr [ESP]
 000000EC  9B DB E2			fclex
 000000EF  DD 04 24			fld	qword ptr [ESP]
 000000F2  59				pop	ECX
 000000F3  59				pop	ECX 
 000000F4  E8 00000000 E		call	 FloatingPoint_FromInt
 000000F9  50				push	EAX
 000000FA  52				push	EDX 
 000000FB  DC 3C 24			fdivr	qword ptr [ESP]
 000000FE  DD 1C 24			fstp	qword ptr [ESP]
 00000101  5A				pop	EDX
 00000102  58				pop	EAX 
 00000103  EB 00			jmp	OFFSET $L000492
				;}
 00000105			$L000492:

 00000105  5F				pop	EDI
 00000106  5E				pop	ESI 
 00000107  5B				pop	EBX 
 00000108  8B E5			mov	ESP,EBP
 0000010A  5D				pop	EBP 
 0000010B  C2 0008			retn	000000008h
 0000010E			Math_Hyperbolic_HCosec ENDP

 0000010E			Math_Hyperbolic_HCotan PROC NEAR 
				;double Math::Hyperbolic::HCotan(double X);
 0000010E  55				push	EBP
 0000010F  8B EC			mov	EBP,ESP
 00000111  51				push	ECX 
 00000112  53				push	EBX 
 00000113  56				push	ESI 
 00000114  57				push	EDI 
				;{

				;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
 00000115  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000118  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000011B  50				push	EAX
 0000011C  52				push	EDX 
 0000011D  E8 00000000 E		call	 Math_Exp
 00000122  50				push	EAX
 00000123  52				push	EDX 
 00000124  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000127  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000012A  50				push	EAX
 0000012B  52				push	EDX 
 0000012C  DD 04 24			fld	qword ptr [ESP]
 0000012F  D9 E0			fchs
 00000131  DD 1C 24			fstp	qword ptr [ESP]
 00000134  E8 00000000 E		call	 Math_Exp
 00000139  50				push	EAX
 0000013A  52				push	EDX 
 0000013B  DD 04 24			fld	qword ptr [ESP]
 0000013E  59				pop	ECX
 0000013F  59				pop	ECX 
 00000140  DC 04 24			fadd	qword ptr [ESP]
 00000143  DD 1C 24			fstp	qword ptr [ESP]
 00000146  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000149  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000014C  50				push	EAX
 0000014D  52				push	EDX 
 0000014E  E8 00000000 E		call	 Math_Exp
 00000153  50				push	EAX
 00000154  52				push	EDX 
 00000155  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000158  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000015B  50				push	EAX
 0000015C  52				push	EDX 
 0000015D  DD 04 24			fld	qword ptr [ESP]
 00000160  D9 E0			fchs
 00000162  DD 1C 24			fstp	qword ptr [ESP]
 00000165  E8 00000000 E		call	 Math_Exp
 0000016A  50				push	EAX
 0000016B  52				push	EDX 
 0000016C  DD 04 24			fld	qword ptr [ESP]
 0000016F  59				pop	ECX
 00000170  59				pop	ECX 
 00000171  DD 04 24			fld	qword ptr [ESP]
 00000174  D8 E1			fsub	st,st(1)
 00000176  DD 1C 24			fstp	qword ptr [ESP]
 00000179  9B DB E2			fclex
 0000017C  DD 04 24			fld	qword ptr [ESP]
 0000017F  59				pop	ECX
 00000180  59				pop	ECX 
 00000181  DC 3C 24			fdivr	qword ptr [ESP]
 00000184  DD 1C 24			fstp	qword ptr [ESP]
 00000187  5A				pop	EDX
 00000188  58				pop	EAX 
 00000189  EB 00			jmp	OFFSET $L000494
				;}
 0000018B			$L000494:

 0000018B  5F				pop	EDI
 0000018C  5E				pop	ESI 
 0000018D  5B				pop	EBX 
 0000018E  8B E5			mov	ESP,EBP
 00000190  5D				pop	EBP 
 00000191  C2 0008			retn	000000008h
 00000194			Math_Hyperbolic_HCotan ENDP

 00000194			Math_Hyperbolic_HSec PROC NEAR 
				;double Math::Hyperbolic::HSec(double X);
 00000194  55				push	EBP
 00000195  8B EC			mov	EBP,ESP
 00000197  51				push	ECX 
 00000198  53				push	EBX 
 00000199  56				push	ESI 
 0000019A  57				push	EDI 
				;{

				;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
 0000019B  B8 00000002			mov	EAX,000000002h
 000001A0  50				push	EAX
 000001A1  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000001A4  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000001A7  50				push	EAX
 000001A8  52				push	EDX 
 000001A9  E8 00000000 E		call	 Math_Exp
 000001AE  50				push	EAX
 000001AF  52				push	EDX 
 000001B0  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000001B3  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000001B6  50				push	EAX
 000001B7  52				push	EDX 
 000001B8  DD 04 24			fld	qword ptr [ESP]
 000001BB  D9 E0			fchs
 000001BD  DD 1C 24			fstp	qword ptr [ESP]
 000001C0  E8 00000000 E		call	 Math_Exp
 000001C5  50				push	EAX
 000001C6  52				push	EDX 
 000001C7  DD 04 24			fld	qword ptr [ESP]
 000001CA  59				pop	ECX
 000001CB  59				pop	ECX 
 000001CC  DC 04 24			fadd	qword ptr [ESP]
 000001CF  DD 1C 24			fstp	qword ptr [ESP]
 000001D2  9B DB E2			fclex
 000001D5  DD 04 24			fld	qword ptr [ESP]
 000001D8  59				pop	ECX
 000001D9  59				pop	ECX 
 000001DA  E8 00000000 E		call	 FloatingPoint_FromInt
 000001DF  50				push	EAX
 000001E0  52				push	EDX 
 000001E1  DC 3C 24			fdivr	qword ptr [ESP]
 000001E4  DD 1C 24			fstp	qword ptr [ESP]
 000001E7  5A				pop	EDX
 000001E8  58				pop	EAX 
 000001E9  EB 00			jmp	OFFSET $L000490
				;}
 000001EB			$L000490:

 000001EB  5F				pop	EDI
 000001EC  5E				pop	ESI 
 000001ED  5B				pop	EBX 
 000001EE  8B E5			mov	ESP,EBP
 000001F0  5D				pop	EBP 
 000001F1  C2 0008			retn	000000008h
 000001F4			Math_Hyperbolic_HSec ENDP

 000001F4			Math_Hyperbolic_HSin PROC NEAR 
				;double Math::Hyperbolic::HSin(double X);
 000001F4  55				push	EBP
 000001F5  8B EC			mov	EBP,ESP
 000001F7  51				push	ECX 
 000001F8  53				push	EBX 
 000001F9  56				push	ESI 
 000001FA  57				push	EDI 
				;{

				;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
 000001FB  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000001FE  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000201  50				push	EAX
 00000202  52				push	EDX 
 00000203  E8 00000000 E		call	 Math_Exp
 00000208  50				push	EAX
 00000209  52				push	EDX 
 0000020A  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000020D  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000210  50				push	EAX
 00000211  52				push	EDX 
 00000212  DD 04 24			fld	qword ptr [ESP]
 00000215  D9 E0			fchs
 00000217  DD 1C 24			fstp	qword ptr [ESP]
 0000021A  E8 00000000 E		call	 Math_Exp
 0000021F  50				push	EAX
 00000220  52				push	EDX 
 00000221  DD 04 24			fld	qword ptr [ESP]
 00000224  59				pop	ECX
 00000225  59				pop	ECX 
 00000226  DD 04 24			fld	qword ptr [ESP]
 00000229  D8 E1			fsub	st,st(1)
 0000022B  DD 1C 24			fstp	qword ptr [ESP]
 0000022E  B8 00000002			mov	EAX,000000002h
 00000233  9B DB E2			fclex
 00000236  50				push	EAX
 00000237  E8 00000000 E		call	 FloatingPoint_FromInt
 0000023C  50				push	EAX
 0000023D  52				push	EDX 
 0000023E  DD 04 24			fld	qword ptr [ESP]
 00000241  59				pop	ECX
 00000242  59				pop	ECX 
 00000243  DC 3C 24			fdivr	qword ptr [ESP]
 00000246  DD 1C 24			fstp	qword ptr [ESP]
 00000249  5A				pop	EDX
 0000024A  58				pop	EAX 
 0000024B  EB 00			jmp	OFFSET $L000483
				;}
 0000024D			$L000483:

 0000024D  5F				pop	EDI
 0000024E  5E				pop	ESI 
 0000024F  5B				pop	EBX 
 00000250  8B E5			mov	ESP,EBP
 00000252  5D				pop	EBP 
 00000253  C2 0008			retn	000000008h
 00000256			Math_Hyperbolic_HSin ENDP

 00000256			Math_Hyperbolic_HTan PROC NEAR 
				;double Math::Hyperbolic::HTan(double X);
 00000256  55				push	EBP
 00000257  8B EC			mov	EBP,ESP
 00000259  51				push	ECX 
 0000025A  53				push	EBX 
 0000025B  56				push	ESI 
 0000025C  57				push	EDI 
				;{

				;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
 0000025D  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000260  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000263  50				push	EAX
 00000264  52				push	EDX 
 00000265  E8 00000000 E		call	 Math_Exp
 0000026A  50				push	EAX
 0000026B  52				push	EDX 
 0000026C  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000026F  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000272  50				push	EAX
 00000273  52				push	EDX 
 00000274  DD 04 24			fld	qword ptr [ESP]
 00000277  D9 E0			fchs
 00000279  DD 1C 24			fstp	qword ptr [ESP]
 0000027C  E8 00000000 E		call	 Math_Exp
 00000281  50				push	EAX
 00000282  52				push	EDX 
 00000283  DD 04 24			fld	qword ptr [ESP]
 00000286  59				pop	ECX
 00000287  59				pop	ECX 
 00000288  DD 04 24			fld	qword ptr [ESP]
 0000028B  D8 E1			fsub	st,st(1)
 0000028D  DD 1C 24			fstp	qword ptr [ESP]
 00000290  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000293  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000296  50				push	EAX
 00000297  52				push	EDX 
 00000298  E8 00000000 E		call	 Math_Exp
 0000029D  50				push	EAX
 0000029E  52				push	EDX 
 0000029F  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000002A2  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000002A5  50				push	EAX
 000002A6  52				push	EDX 
 000002A7  DD 04 24			fld	qword ptr [ESP]
 000002AA  D9 E0			fchs
 000002AC  DD 1C 24			fstp	qword ptr [ESP]
 000002AF  E8 00000000 E		call	 Math_Exp
 000002B4  50				push	EAX
 000002B5  52				push	EDX 
 000002B6  DD 04 24			fld	qword ptr [ESP]
 000002B9  59				pop	ECX
 000002BA  59				pop	ECX 
 000002BB  DC 04 24			fadd	qword ptr [ESP]
 000002BE  DD 1C 24			fstp	qword ptr [ESP]
 000002C1  9B DB E2			fclex
 000002C4  DD 04 24			fld	qword ptr [ESP]
 000002C7  59				pop	ECX
 000002C8  59				pop	ECX 
 000002C9  DC 3C 24			fdivr	qword ptr [ESP]
 000002CC  DD 1C 24			fstp	qword ptr [ESP]
 000002CF  5A				pop	EDX
 000002D0  58				pop	EAX 
 000002D1  EB 00			jmp	OFFSET $L000488
				;}
 000002D3			$L000488:

 000002D3  5F				pop	EDI
 000002D4  5E				pop	ESI 
 000002D5  5B				pop	EBX 
 000002D6  8B E5			mov	ESP,EBP
 000002D8  5D				pop	EBP 
 000002D9  C2 0008			retn	000000008h
 000002DC			Math_Hyperbolic_HTan ENDP

 000002DC			Math_Hyperbolic_Inverse_HArccos PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArccos(double X);
 000002DC  55				push	EBP
 000002DD  8B EC			mov	EBP,ESP
 000002DF  51				push	ECX 
 000002E0  53				push	EBX 
 000002E1  56				push	ESI 
 000002E2  57				push	EDI 
				;{

				;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
 000002E3  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000002E6  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000002E9  50				push	EAX
 000002EA  52				push	EDX 
 000002EB  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000002EE  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000002F1  50				push	EAX
 000002F2  52				push	EDX 
 000002F3  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000002F6  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000002F9  9B DB E2			fclex
 000002FC  50				push	EAX
 000002FD  52				push	EDX 
 000002FE  DD 04 24			fld	qword ptr [ESP]
 00000301  59				pop	ECX
 00000302  59				pop	ECX 
 00000303  DC 0C 24			fmul	qword ptr [ESP]
 00000306  DD 1C 24			fstp	qword ptr [ESP]
 00000309  B8 00000001			mov	EAX,000000001h
 0000030E  50				push	EAX
 0000030F  E8 00000000 E		call	 FloatingPoint_FromInt
 00000314  50				push	EAX
 00000315  52				push	EDX 
 00000316  DD 04 24			fld	qword ptr [ESP]
 00000319  59				pop	ECX
 0000031A  59				pop	ECX 
 0000031B  DD 04 24			fld	qword ptr [ESP]
 0000031E  D8 E1			fsub	st,st(1)
 00000320  DD 1C 24			fstp	qword ptr [ESP]
 00000323  E8 00000000 E		call	 Math_Sqrt
 00000328  50				push	EAX
 00000329  52				push	EDX 
 0000032A  DD 04 24			fld	qword ptr [ESP]
 0000032D  59				pop	ECX
 0000032E  59				pop	ECX 
 0000032F  DC 04 24			fadd	qword ptr [ESP]
 00000332  DD 1C 24			fstp	qword ptr [ESP]
 00000335  E8 00000000 E		call	 Math_Ln
 0000033A  EB 00			jmp	OFFSET $L000500
				;}
 0000033C			$L000500:

 0000033C  5F				pop	EDI
 0000033D  5E				pop	ESI 
 0000033E  5B				pop	EBX 
 0000033F  8B E5			mov	ESP,EBP
 00000341  5D				pop	EBP 
 00000342  C2 0008			retn	000000008h
 00000345			Math_Hyperbolic_Inverse_HArccos ENDP

 00000345			Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArccosec(double X);
 00000345  55				push	EBP
 00000346  8B EC			mov	EBP,ESP
 00000348  51				push	ECX 
 00000349  53				push	EBX 
 0000034A  56				push	ESI 
 0000034B  57				push	EDI 
				;{

				;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
 0000034C  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000034F  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000352  50				push	EAX
 00000353  52				push	EDX 
 00000354  E8 00000000 E		call	 Math_Sign
 00000359  50				push	EAX
 0000035A  52				push	EDX 
 0000035B  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000035E  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000361  50				push	EAX
 00000362  52				push	EDX 
 00000363  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000366  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000369  9B DB E2			fclex
 0000036C  50				push	EAX
 0000036D  52				push	EDX 
 0000036E  DD 04 24			fld	qword ptr [ESP]
 00000371  59				pop	ECX
 00000372  59				pop	ECX 
 00000373  DC 0C 24			fmul	qword ptr [ESP]
 00000376  DD 1C 24			fstp	qword ptr [ESP]
 00000379  B8 00000001			mov	EAX,000000001h
 0000037E  50				push	EAX
 0000037F  E8 00000000 E		call	 FloatingPoint_FromInt
 00000384  50				push	EAX
 00000385  52				push	EDX 
 00000386  DD 04 24			fld	qword ptr [ESP]
 00000389  59				pop	ECX
 0000038A  59				pop	ECX 
 0000038B  DC 04 24			fadd	qword ptr [ESP]
 0000038E  DD 1C 24			fstp	qword ptr [ESP]
 00000391  E8 00000000 E		call	 Math_Sqrt
 00000396  9B DB E2			fclex
 00000399  50				push	EAX
 0000039A  52				push	EDX 
 0000039B  DD 04 24			fld	qword ptr [ESP]
 0000039E  59				pop	ECX
 0000039F  59				pop	ECX 
 000003A0  DC 0C 24			fmul	qword ptr [ESP]
 000003A3  DD 1C 24			fstp	qword ptr [ESP]
 000003A6  B8 00000001			mov	EAX,000000001h
 000003AB  50				push	EAX
 000003AC  E8 00000000 E		call	 FloatingPoint_FromInt
 000003B1  50				push	EAX
 000003B2  52				push	EDX 
 000003B3  DD 04 24			fld	qword ptr [ESP]
 000003B6  59				pop	ECX
 000003B7  59				pop	ECX 
 000003B8  DC 04 24			fadd	qword ptr [ESP]
 000003BB  DD 1C 24			fstp	qword ptr [ESP]
 000003BE  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000003C1  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000003C4  9B DB E2			fclex
 000003C7  50				push	EAX
 000003C8  52				push	EDX 
 000003C9  DD 04 24			fld	qword ptr [ESP]
 000003CC  59				pop	ECX
 000003CD  59				pop	ECX 
 000003CE  DC 3C 24			fdivr	qword ptr [ESP]
 000003D1  DD 1C 24			fstp	qword ptr [ESP]
 000003D4  E8 00000000 E		call	 Math_Ln
 000003D9  EB 00			jmp	OFFSET $L000506
				;}
 000003DB			$L000506:

 000003DB  5F				pop	EDI
 000003DC  5E				pop	ESI 
 000003DD  5B				pop	EBX 
 000003DE  8B E5			mov	ESP,EBP
 000003E0  5D				pop	EBP 
 000003E1  C2 0008			retn	000000008h
 000003E4			Math_Hyperbolic_Inverse_HArccosec ENDP

 000003E4			Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArccotan(double X);
 000003E4  55				push	EBP
 000003E5  8B EC			mov	EBP,ESP
 000003E7  51				push	ECX 
 000003E8  53				push	EBX 
 000003E9  56				push	ESI 
 000003EA  57				push	EDI 
				;{

				;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
 000003EB  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000003EE  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000003F1  50				push	EAX
 000003F2  52				push	EDX 
 000003F3  B8 00000001			mov	EAX,000000001h
 000003F8  50				push	EAX
 000003F9  E8 00000000 E		call	 FloatingPoint_FromInt
 000003FE  50				push	EAX
 000003FF  52				push	EDX 
 00000400  DD 04 24			fld	qword ptr [ESP]
 00000403  59				pop	ECX
 00000404  59				pop	ECX 
 00000405  DC 04 24			fadd	qword ptr [ESP]
 00000408  DD 1C 24			fstp	qword ptr [ESP]
 0000040B  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000040E  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000411  50				push	EAX
 00000412  52				push	EDX 
 00000413  B8 00000001			mov	EAX,000000001h
 00000418  50				push	EAX
 00000419  E8 00000000 E		call	 FloatingPoint_FromInt
 0000041E  50				push	EAX
 0000041F  52				push	EDX 
 00000420  DD 04 24			fld	qword ptr [ESP]
 00000423  59				pop	ECX
 00000424  59				pop	ECX 
 00000425  DD 04 24			fld	qword ptr [ESP]
 00000428  D8 E1			fsub	st,st(1)
 0000042A  DD 1C 24			fstp	qword ptr [ESP]
 0000042D  9B DB E2			fclex
 00000430  DD 04 24			fld	qword ptr [ESP]
 00000433  59				pop	ECX
 00000434  59				pop	ECX 
 00000435  DC 3C 24			fdivr	qword ptr [ESP]
 00000438  DD 1C 24			fstp	qword ptr [ESP]
 0000043B  E8 00000000 E		call	 Math_Ln
 00000440  50				push	EAX
 00000441  52				push	EDX 
 00000442  B8 00000002			mov	EAX,000000002h
 00000447  9B DB E2			fclex
 0000044A  50				push	EAX
 0000044B  E8 00000000 E		call	 FloatingPoint_FromInt
 00000450  50				push	EAX
 00000451  52				push	EDX 
 00000452  DD 04 24			fld	qword ptr [ESP]
 00000455  59				pop	ECX
 00000456  59				pop	ECX 
 00000457  DC 3C 24			fdivr	qword ptr [ESP]
 0000045A  DD 1C 24			fstp	qword ptr [ESP]
 0000045D  5A				pop	EDX
 0000045E  58				pop	EAX 
 0000045F  EB 00			jmp	OFFSET $L000508
				;}
 00000461			$L000508:

 00000461  5F				pop	EDI
 00000462  5E				pop	ESI 
 00000463  5B				pop	EBX 
 00000464  8B E5			mov	ESP,EBP
 00000466  5D				pop	EBP 
 00000467  C2 0008			retn	000000008h
 0000046A			Math_Hyperbolic_Inverse_HArccotan ENDP

 0000046A			Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArcsec(double X);
 0000046A  55				push	EBP
 0000046B  8B EC			mov	EBP,ESP
 0000046D  51				push	ECX 
 0000046E  53				push	EBX 
 0000046F  56				push	ESI 
 00000470  57				push	EDI 
				;{

				;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
 00000471  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000474  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000477  50				push	EAX
 00000478  52				push	EDX 
 00000479  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000047C  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000047F  9B DB E2			fclex
 00000482  50				push	EAX
 00000483  52				push	EDX 
 00000484  DD 04 24			fld	qword ptr [ESP]
 00000487  59				pop	ECX
 00000488  59				pop	ECX 
 00000489  DC 0C 24			fmul	qword ptr [ESP]
 0000048C  DD 1C 24			fstp	qword ptr [ESP]
 0000048F  DD 04 24			fld	qword ptr [ESP]
 00000492  D9 E0			fchs
 00000494  DD 1C 24			fstp	qword ptr [ESP]
 00000497  B8 00000001			mov	EAX,000000001h
 0000049C  50				push	EAX
 0000049D  E8 00000000 E		call	 FloatingPoint_FromInt
 000004A2  50				push	EAX
 000004A3  52				push	EDX 
 000004A4  DD 04 24			fld	qword ptr [ESP]
 000004A7  59				pop	ECX
 000004A8  59				pop	ECX 
 000004A9  DC 04 24			fadd	qword ptr [ESP]
 000004AC  DD 1C 24			fstp	qword ptr [ESP]
 000004AF  E8 00000000 E		call	 Math_Sqrt
 000004B4  50				push	EAX
 000004B5  52				push	EDX 
 000004B6  B8 00000001			mov	EAX,000000001h
 000004BB  50				push	EAX
 000004BC  E8 00000000 E		call	 FloatingPoint_FromInt
 000004C1  50				push	EAX
 000004C2  52				push	EDX 
 000004C3  DD 04 24			fld	qword ptr [ESP]
 000004C6  59				pop	ECX
 000004C7  59				pop	ECX 
 000004C8  DC 04 24			fadd	qword ptr [ESP]
 000004CB  DD 1C 24			fstp	qword ptr [ESP]
 000004CE  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000004D1  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000004D4  9B DB E2			fclex
 000004D7  50				push	EAX
 000004D8  52				push	EDX 
 000004D9  DD 04 24			fld	qword ptr [ESP]
 000004DC  59				pop	ECX
 000004DD  59				pop	ECX 
 000004DE  DC 3C 24			fdivr	qword ptr [ESP]
 000004E1  DD 1C 24			fstp	qword ptr [ESP]
 000004E4  E8 00000000 E		call	 Math_Ln
 000004E9  EB 00			jmp	OFFSET $L000504
				;}
 000004EB			$L000504:

 000004EB  5F				pop	EDI
 000004EC  5E				pop	ESI 
 000004ED  5B				pop	EBX 
 000004EE  8B E5			mov	ESP,EBP
 000004F0  5D				pop	EBP 
 000004F1  C2 0008			retn	000000008h
 000004F4			Math_Hyperbolic_Inverse_HArcsec ENDP

 000004F4			Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArcsin(double X);
 000004F4  55				push	EBP
 000004F5  8B EC			mov	EBP,ESP
 000004F7  51				push	ECX 
 000004F8  53				push	EBX 
 000004F9  56				push	ESI 
 000004FA  57				push	EDI 
				;{

				;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
 000004FB  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000004FE  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000501  50				push	EAX
 00000502  52				push	EDX 
 00000503  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000506  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000509  50				push	EAX
 0000050A  52				push	EDX 
 0000050B  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000050E  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000511  9B DB E2			fclex
 00000514  50				push	EAX
 00000515  52				push	EDX 
 00000516  DD 04 24			fld	qword ptr [ESP]
 00000519  59				pop	ECX
 0000051A  59				pop	ECX 
 0000051B  DC 0C 24			fmul	qword ptr [ESP]
 0000051E  DD 1C 24			fstp	qword ptr [ESP]
 00000521  B8 00000001			mov	EAX,000000001h
 00000526  50				push	EAX
 00000527  E8 00000000 E		call	 FloatingPoint_FromInt
 0000052C  50				push	EAX
 0000052D  52				push	EDX 
 0000052E  DD 04 24			fld	qword ptr [ESP]
 00000531  59				pop	ECX
 00000532  59				pop	ECX 
 00000533  DC 04 24			fadd	qword ptr [ESP]
 00000536  DD 1C 24			fstp	qword ptr [ESP]
 00000539  E8 00000000 E		call	 Math_Sqrt
 0000053E  50				push	EAX
 0000053F  52				push	EDX 
 00000540  DD 04 24			fld	qword ptr [ESP]
 00000543  59				pop	ECX
 00000544  59				pop	ECX 
 00000545  DC 04 24			fadd	qword ptr [ESP]
 00000548  DD 1C 24			fstp	qword ptr [ESP]
 0000054B  E8 00000000 E		call	 Math_Ln
 00000550  EB 00			jmp	OFFSET $L000497
				;}
 00000552			$L000497:

 00000552  5F				pop	EDI
 00000553  5E				pop	ESI 
 00000554  5B				pop	EBX 
 00000555  8B E5			mov	ESP,EBP
 00000557  5D				pop	EBP 
 00000558  C2 0008			retn	000000008h
 0000055B			Math_Hyperbolic_Inverse_HArcsin ENDP

 0000055B			Math_Hyperbolic_Inverse_HArctan PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArctan(double X);
 0000055B  55				push	EBP
 0000055C  8B EC			mov	EBP,ESP
 0000055E  51				push	ECX 
 0000055F  53				push	EBX 
 00000560  56				push	ESI 
 00000561  57				push	EDI 
				;{

				;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
 00000562  B8 00000001			mov	EAX,000000001h
 00000567  50				push	EAX
 00000568  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000056B  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000056E  50				push	EAX
 0000056F  52				push	EDX 
 00000570  DD 04 24			fld	qword ptr [ESP]
 00000573  59				pop	ECX
 00000574  59				pop	ECX 
 00000575  E8 00000000 E		call	 FloatingPoint_FromInt
 0000057A  50				push	EAX
 0000057B  52				push	EDX 
 0000057C  DC 04 24			fadd	qword ptr [ESP]
 0000057F  DD 1C 24			fstp	qword ptr [ESP]
 00000582  B8 00000001			mov	EAX,000000001h
 00000587  50				push	EAX
 00000588  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000058B  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000058E  50				push	EAX
 0000058F  52				push	EDX 
 00000590  DD 04 24			fld	qword ptr [ESP]
 00000593  59				pop	ECX
 00000594  59				pop	ECX 
 00000595  E8 00000000 E		call	 FloatingPoint_FromInt
 0000059A  50				push	EAX
 0000059B  52				push	EDX 
 0000059C  DD 04 24			fld	qword ptr [ESP]
 0000059F  D8 E1			fsub	st,st(1)
 000005A1  DD 1C 24			fstp	qword ptr [ESP]
 000005A4  9B DB E2			fclex
 000005A7  DD 04 24			fld	qword ptr [ESP]
 000005AA  59				pop	ECX
 000005AB  59				pop	ECX 
 000005AC  DC 3C 24			fdivr	qword ptr [ESP]
 000005AF  DD 1C 24			fstp	qword ptr [ESP]
 000005B2  E8 00000000 E		call	 Math_Ln
 000005B7  50				push	EAX
 000005B8  52				push	EDX 
 000005B9  B8 00000002			mov	EAX,000000002h
 000005BE  9B DB E2			fclex
 000005C1  50				push	EAX
 000005C2  E8 00000000 E		call	 FloatingPoint_FromInt
 000005C7  50				push	EAX
 000005C8  52				push	EDX 
 000005C9  DD 04 24			fld	qword ptr [ESP]
 000005CC  59				pop	ECX
 000005CD  59				pop	ECX 
 000005CE  DC 3C 24			fdivr	qword ptr [ESP]
 000005D1  DD 1C 24			fstp	qword ptr [ESP]
 000005D4  5A				pop	EDX
 000005D5  58				pop	EAX 
 000005D6  EB 00			jmp	OFFSET $L000502
				;}
 000005D8			$L000502:

 000005D8  5F				pop	EDI
 000005D9  5E				pop	ESI 
 000005DA  5B				pop	EBX 
 000005DB  8B E5			mov	ESP,EBP
 000005DD  5D				pop	EBP 
 000005DE  C2 0008			retn	000000008h
 000005E1			Math_Hyperbolic_Inverse_HArctan ENDP

 000005E1			Math_RadiansToDegrees PROC NEAR 
				;double Math::RadiansToDegrees(double rad);
 000005E1  55				push	EBP
 000005E2  8B EC			mov	EBP,ESP
 000005E4  51				push	ECX 
 000005E5  53				push	EBX 
 000005E6  56				push	ESI 
 000005E7  57				push	EDI 
				;{

				;{384}:return (180 / Math::pi()) * rad
 000005E8  B8 000000B4			mov	EAX,0000000B4h
 000005ED  50				push	EAX
 000005EE  E8 00000000 E		call	 Math_pi
 000005F3  9B DB E2			fclex
 000005F6  50				push	EAX
 000005F7  52				push	EDX 
 000005F8  DD 04 24			fld	qword ptr [ESP]
 000005FB  59				pop	ECX
 000005FC  59				pop	ECX 
 000005FD  E8 00000000 E		call	 FloatingPoint_FromInt
 00000602  50				push	EAX
 00000603  52				push	EDX 
 00000604  DC 3C 24			fdivr	qword ptr [ESP]
 00000607  DD 1C 24			fstp	qword ptr [ESP]
 0000060A  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000060D  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000610  9B DB E2			fclex
 00000613  50				push	EAX
 00000614  52				push	EDX 
 00000615  DD 04 24			fld	qword ptr [ESP]
 00000618  59				pop	ECX
 00000619  59				pop	ECX 
 0000061A  DC 0C 24			fmul	qword ptr [ESP]
 0000061D  DD 1C 24			fstp	qword ptr [ESP]
 00000620  5A				pop	EDX
 00000621  58				pop	EAX 
 00000622  EB 00			jmp	OFFSET $L000466
				;}
 00000624			$L000466:

 00000624  5F				pop	EDI
 00000625  5E				pop	ESI 
 00000626  5B				pop	EBX 
 00000627  8B E5			mov	ESP,EBP
 00000629  5D				pop	EBP 
 0000062A  C2 0008			retn	000000008h
 0000062D			Math_RadiansToDegrees ENDP

 0000062D			Program_CalcTrace PROC NEAR 
				;double Program::CalcTrace(double double [] M, int rM, int cM);
 0000062D  55				push	EBP
 0000062E  8B EC			mov	EBP,ESP
 00000630  83 EC 14			sub	ESP,000000014h
 00000633  53				push	EBX 
 00000634  56				push	ESI 
 00000635  57				push	EDI 
				;{

				;{20}:Tr= 0.0;
 00000636  D9 EE			fldz
 00000638  DD 5D F8			fstp	qword ptr [EBP-0008h]

				;{21}:n= min(rM, cM);
 0000063B  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 0000063E  50				push	EAX
 0000063F  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000642  5B				pop	EBX
 00000643  2B D8			sub	EBX,EAX
 00000645  1B C9			sbb	ECX,ECX
 00000647  23 CB			and	ECX,EBX
 00000649  03 C1			add	EAX,ECX
 0000064B  89 45 F4			mov	dword ptr [EBP-000Ch],EAX

				;{22}:for(i= 0; i < n; i++ )
 0000064E  33 C0			xor	EAX,EAX
 00000650  89 45 F0			mov	dword ptr [EBP-0010h],EAX
 00000653  EB 06			jmp	OFFSET $L000633
 00000655			$L000634:
 00000655  8B 45 F0			mov	EAX,dword ptr [EBP-16]
 00000658  FF 45 F0			inc	dword ptr [EBP-16]
 0000065B			$L000633:
 0000065B  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 0000065E  50				push	EAX
 0000065F  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 00000662  5A				pop	EDX
 00000663  3B D0			cmp	EDX,EAX
 00000665  0F 9C C0			setl	AL
 00000668  84 C0			test	AL,AL
 0000066A  0F 84 000000C1		jz	OFFSET $L000635
				;{

				;{23}:Console::WriteLn("M[", i, ",", i, "]= ", M[(i * (n + 1)) * sizeof (double)]);
 00000670  8D 05 00000444 R		lea	EAX,OFFSET $S000541
 00000676  6A 00			push	000000000h
 00000678  50				push	EAX 
 00000679  E8 00000000 E		call	 Console_WriteString
 0000067E  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000681  50				push	EAX 
 00000682  E8 00000000 E		call	 Console_WriteInteger 
 00000687  B8 0000002C			mov	EAX,00000002Ch
 0000068C  50				push	EAX 
 0000068D  E8 00000000 E		call	 Console_WriteChar 
 00000692  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000695  50				push	EAX 
 00000696  E8 00000000 E		call	 Console_WriteInteger 
 0000069B  8D 05 0000054F R		lea	EAX,OFFSET $S000543
 000006A1  6A 00			push	000000000h 
 000006A3  50				push	EAX 
 000006A4  E8 00000000 E		call	 Console_WriteString 
 000006A9  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 000006AC  8B C3			mov	EAX,EBX 
 000006AE  50				push	EAX
 000006AF  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 000006B2  50				push	EAX
 000006B3  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 000006B6  50				push	EAX
 000006B7  B8 00000001			mov	EAX,000000001h
 000006BC  5A				pop	EDX
 000006BD  03 C2			add	EAX,EDX
 000006BF  59				pop	ECX
 000006C0  99				cdq	
 000006C1  0F AF C1			imul	EAX,ECX
 000006C4  50				push	EAX
 000006C5  B8 00000008			mov	EAX,000000008h
 000006CA  59				pop	ECX
 000006CB  99				cdq	
 000006CC  0F AF C1			imul	EAX,ECX
 000006CF  5E				pop	ESI
 000006D0  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 000006D3  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 000006DA  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 000006DD  50				push	EAX 
 000006DE  52				push	EDX 
 000006DF  E8 00000000 E		call	 Console_WriteDouble 
 000006E4  E8 00000000 E		call	 Console_WriteCrLf 

				;{24}:Tr+= M[(i * (n + 1)) * sizeof (double)];
 000006E9  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 000006EC  8B C3			mov	EAX,EBX 
 000006EE  50				push	EAX
 000006EF  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 000006F2  50				push	EAX
 000006F3  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 000006F6  50				push	EAX
 000006F7  B8 00000001			mov	EAX,000000001h
 000006FC  5A				pop	EDX
 000006FD  03 C2			add	EAX,EDX
 000006FF  59				pop	ECX
 00000700  99				cdq	
 00000701  0F AF C1			imul	EAX,ECX
 00000704  50				push	EAX
 00000705  B8 00000008			mov	EAX,000000008h
 0000070A  59				pop	ECX
 0000070B  99				cdq	
 0000070C  0F AF C1			imul	EAX,ECX
 0000070F  5E				pop	ESI
 00000710  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000713  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 0000071A  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 0000071D  F8				clc	
 0000071E  50				push	EAX
 0000071F  52				push	EDX 
 00000720  DD 04 24			fld	qword ptr [ESP]
 00000723  5A				pop	EDX
 00000724  58				pop	EAX 
 00000725  8D 5D F8			lea	EBX,dword ptr [EBP-0008h]
 00000728  DC 03			fadd	qword ptr [EBX]
 0000072A  DD 1B			fstp	qword ptr [EBX]
				;}
 0000072C  E9 FFFFFF24			jmp	OFFSET $L000634 
 00000731			$L000635:

				;{26}:return Tr
 00000731  8B 55 F8			mov	EDX,dword ptr [EBP-0008h]
 00000734  8B 45 FC			mov	EAX,dword ptr [EBP-0004h] 
 00000737  EB 00			jmp	OFFSET $L000533
				;}
 00000739			$L000533:

 00000739  5F				pop	EDI
 0000073A  5E				pop	ESI 
 0000073B  5B				pop	EBX 
 0000073C  8B E5			mov	ESP,EBP
 0000073E  5D				pop	EBP 
 0000073F  C2 000C			retn	00000000Ch
 00000742			Program_CalcTrace ENDP

 00000742			Program_MultiplyMatrices PROC NEAR 
				;void Program::MultiplyMatrices(double double [] A, double double [] B, int rA, int cA, int rB, int cB);
 00000742  55				push	EBP
 00000743  8B EC			mov	EBP,ESP
 00000745  83 EC 10			sub	ESP,000000010h
 00000748  53				push	EBX 
 00000749  56				push	ESI 
 0000074A  57				push	EDI 
				;{

				;{79}:Res= new double[rA * cB];
 0000074B  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 0000074E  50				push	EAX
 0000074F  8B 45 1C			mov	EAX,dword ptr [EBP+001Ch]
 00000752  59				pop	ECX
 00000753  99				cdq	
 00000754  0F AF C1			imul	EAX,ECX
 00000757  6B C0 08			imul	EAX,000000008h
 0000075A  50				push	EAX
 0000075B  8B D8			mov	EBX,EAX
 0000075D  E8 00000000 E		call	 System_Memory_New
 00000762  85 C0			test	EAX,EAX
 00000764  74 04			jz	 $L000636
 00000766  8B F0			mov	ESI,EAX 
 00000768  EB 02			jmp	 $L000637
 0000076A			$L000636:
 0000076A  33 F6			xor	ESI,ESI
 0000076C			$L000637:
 0000076C  89 75 FC			mov	dword ptr [EBP-0004h],ESI 

				;{80}:if(cA == rB)
 0000076F  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000772  50				push	EAX
 00000773  8B 45 18			mov	EAX,dword ptr [EBP+0018h]
 00000776  5A				pop	EDX
 00000777  3B D0			cmp	EDX,EAX
 00000779  0F 94 C0			setz	AL
 0000077C  84 C0			test	AL,AL
 0000077E  0F 84 00000109		jz	OFFSET $L000638
				;{

				;{83}:for(i= 0; i < rA; i++ )
 00000784  33 C0			xor	EAX,EAX
 00000786  89 45 F8			mov	dword ptr [EBP-0008h],EAX
 00000789  EB 06			jmp	OFFSET $L000640
 0000078B			$L000641:
 0000078B  8B 45 F8			mov	EAX,dword ptr [EBP-8]
 0000078E  FF 45 F8			inc	dword ptr [EBP-8]
 00000791			$L000640:
 00000791  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000794  50				push	EAX
 00000795  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000798  5A				pop	EDX
 00000799  3B D0			cmp	EDX,EAX
 0000079B  0F 9C C0			setl	AL
 0000079E  84 C0			test	AL,AL
 000007A0  0F 84 000000D4		jz	OFFSET $L000642

				;{84}:for(j= 0; j < cB; j++ )
 000007A6  33 C0			xor	EAX,EAX
 000007A8  89 45 F4			mov	dword ptr [EBP-000Ch],EAX
 000007AB  EB 06			jmp	OFFSET $L000643
 000007AD			$L000644:
 000007AD  8B 45 F4			mov	EAX,dword ptr [EBP-12]
 000007B0  FF 45 F4			inc	dword ptr [EBP-12]
 000007B3			$L000643:
 000007B3  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 000007B6  50				push	EAX
 000007B7  8B 45 1C			mov	EAX,dword ptr [EBP+001Ch]
 000007BA  5A				pop	EDX
 000007BB  3B D0			cmp	EDX,EAX
 000007BD  0F 9C C0			setl	AL
 000007C0  84 C0			test	AL,AL
 000007C2  0F 84 000000AD		jz	OFFSET $L000645
				;{

				;{85}:Res[(i * cB + j) * sizeof (double)]= 0.0;
 000007C8  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 000007CB  50				push	EAX
 000007CC  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 000007CF  50				push	EAX
 000007D0  8B 45 1C			mov	EAX,dword ptr [EBP+001Ch]
 000007D3  59				pop	ECX
 000007D4  99				cdq	
 000007D5  0F AF C1			imul	EAX,ECX
 000007D8  50				push	EAX
 000007D9  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 000007DC  5A				pop	EDX
 000007DD  03 C2			add	EAX,EDX
 000007DF  50				push	EAX
 000007E0  B8 00000008			mov	EAX,000000008h
 000007E5  59				pop	ECX
 000007E6  99				cdq	
 000007E7  0F AF C1			imul	EAX,ECX
 000007EA  5E				pop	ESI
 000007EB  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 000007EE  50				push	EAX
 000007EF  D9 EE			fldz
 000007F1  5B				pop	EBX
 000007F2  89 13			mov	dword ptr [EBX],EDX
 000007F4  89 43 04			mov	dword ptr [EBX+4],EAX 

				;{86}:Console::WriteLn("Res[", i, ",", i, "]= ", Res[(i * cB + j) * sizeof (double)]);
 000007F7  8D 05 00000469 R		lea	EAX,OFFSET $S000574
 000007FD  6A 00			push	000000000h
 000007FF  50				push	EAX 
 00000800  E8 00000000 E		call	 Console_WriteString
 00000805  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000808  50				push	EAX 
 00000809  E8 00000000 E		call	 Console_WriteInteger 
 0000080E  B8 0000002C			mov	EAX,00000002Ch
 00000813  50				push	EAX 
 00000814  E8 00000000 E		call	 Console_WriteChar 
 00000819  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 0000081C  50				push	EAX 
 0000081D  E8 00000000 E		call	 Console_WriteInteger 
 00000822  8D 05 0000054F R		lea	EAX,OFFSET $S000543
 00000828  6A 00			push	000000000h 
 0000082A  50				push	EAX 
 0000082B  E8 00000000 E		call	 Console_WriteString 
 00000830  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000833  50				push	EAX
 00000834  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000837  51				push	ECX
 00000838  51				push	ECX 
 00000839  DD 1C 24			fstp	qword ptr [ESP]
 0000083C  8B 45 1C			mov	EAX,dword ptr [EBP+001Ch]
 0000083F  59				pop	ECX
 00000840  99				cdq	
 00000841  0F AF C1			imul	EAX,ECX
 00000844  50				push	EAX
 00000845  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 00000848  5A				pop	EDX
 00000849  03 C2			add	EAX,EDX
 0000084B  50				push	EAX
 0000084C  B8 00000008			mov	EAX,000000008h
 00000851  59				pop	ECX
 00000852  99				cdq	
 00000853  0F AF C1			imul	EAX,ECX
 00000856  5E				pop	ESI
 00000857  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 0000085A  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000861  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000864  50				push	EAX 
 00000865  52				push	EDX 
 00000866  E8 00000000 E		call	 Console_WriteDouble 
 0000086B  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 00000870  E9 FFFFFF38			jmp	OFFSET $L000644 
 00000875			$L000645:
 00000875  E9 FFFFFF11			jmp	OFFSET $L000641 
 0000087A			$L000642:

				;{98}:Program::ShowMatrixForm(Res, rA, cB);
 0000087A  8B 45 1C			mov	EAX,dword ptr [EBP+001Ch]
 0000087D  50				push	EAX 
 0000087E  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000881  50				push	EAX 
 00000882  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000885  50				push	EAX
 00000886  E8 00000032			call	 Program_ShowMatrixForm
				;}
 0000088B  EB 13			jmp	OFFSET $L000639

				; else {
 0000088D			$L000638:

				;{100}:Console::WriteLn("El numero de filas de B debe ser igual al numero de filas de A.");
 0000088D  8D 05 00000200 R		lea	EAX,OFFSET $S000575
 00000893  6A 00			push	000000000h
 00000895  50				push	EAX 
 00000896  E8 00000000 E		call	 Console_WriteString
 0000089B  E8 00000000 E		call	 Console_WriteCrLf 
 000008A0			$L000639:

				; }

				;{102}:destroy []Res;
 000008A0  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 000008A3  85 C0			test	EAX,EAX
 000008A5  74 06			jz	OFFSET $L000646
 000008A7  50				push	EAX
 000008A8  E8 00000000 E		call	 System_Memory_Destroy
 000008AD			$L000646:

				;{103}:Res= null;
 000008AD  33 C0			xor	EAX,EAX
 000008AF  8D 5D FC			lea	EBX,dword ptr [EBP-0004h]
 000008B2  89 03			mov	dword ptr [EBX],EAX
				;}
 000008B4			$L000564:

 000008B4  5F				pop	EDI
 000008B5  5E				pop	ESI 
 000008B6  5B				pop	EBX 
 000008B7  8B E5			mov	ESP,EBP
 000008B9  5D				pop	EBP 
 000008BA  C2 0018			retn	000000018h
 000008BD			Program_MultiplyMatrices ENDP

 000008BD			Program_ShowMatrixForm PROC NEAR 
				;void Program::ShowMatrixForm(double double [] M, int rM, int cM);
 000008BD  55				push	EBP
 000008BE  8B EC			mov	EBP,ESP
 000008C0  83 EC 0C			sub	ESP,00000000Ch
 000008C3  53				push	EBX 
 000008C4  56				push	ESI 
 000008C5  57				push	EDI 
				;{

				;{11}:for(i= 0; i < rM; i++ )
 000008C6  33 C0			xor	EAX,EAX
 000008C8  89 45 FC			mov	dword ptr [EBP-0004h],EAX
 000008CB  EB 06			jmp	OFFSET $L000647
 000008CD			$L000648:
 000008CD  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 000008D0  FF 45 FC			inc	dword ptr [EBP-4]
 000008D3			$L000647:
 000008D3  8B 45 FC			mov	EAX,dword ptr [EBP-0004h]
 000008D6  50				push	EAX
 000008D7  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 000008DA  5A				pop	EDX
 000008DB  3B D0			cmp	EDX,EAX
 000008DD  0F 9C C0			setl	AL
 000008E0  84 C0			test	AL,AL
 000008E2  0F 84 00000088		jz	OFFSET $L000649
				;{

				;{12}:Console::Write("\n| ");
 000008E8  8D 05 00000546 R		lea	EAX,OFFSET $S000529
 000008EE  6A 00			push	000000000h
 000008F0  50				push	EAX 
 000008F1  E8 00000000 E		call	 Console_WriteString

				;{13}:for(j= 0; j < cM; j++ )
 000008F6  33 C0			xor	EAX,EAX
 000008F8  89 45 F8			mov	dword ptr [EBP-0008h],EAX
 000008FB  EB 06			jmp	OFFSET $L000650
 000008FD			$L000651:
 000008FD  8B 45 F8			mov	EAX,dword ptr [EBP-8]
 00000900  FF 45 F8			inc	dword ptr [EBP-8]
 00000903			$L000650:
 00000903  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000906  50				push	EAX
 00000907  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 0000090A  5A				pop	EDX
 0000090B  3B D0			cmp	EDX,EAX
 0000090D  0F 9C C0			setl	AL
 00000910  84 C0			test	AL,AL
 00000912  74 49			jz	OFFSET $L000652

				;{14}:Console::Write(M[(i * cM + j) * sizeof (double)], "  ");
 00000914  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000917  8B C3			mov	EAX,EBX 
 00000919  50				push	EAX
 0000091A  8B 45 FC			mov	EAX,dword ptr [EBP-0004h]
 0000091D  50				push	EAX
 0000091E  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000921  59				pop	ECX
 00000922  99				cdq	
 00000923  0F AF C1			imul	EAX,ECX
 00000926  50				push	EAX
 00000927  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 0000092A  5A				pop	EDX
 0000092B  03 C2			add	EAX,EDX
 0000092D  50				push	EAX
 0000092E  B8 00000008			mov	EAX,000000008h
 00000933  59				pop	ECX
 00000934  99				cdq	
 00000935  0F AF C1			imul	EAX,ECX
 00000938  5E				pop	ESI
 00000939  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 0000093C  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000943  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000946  50				push	EAX
 00000947  52				push	EDX 
 00000948  E8 00000000 E		call	 Console_WriteDouble
 0000094D  8D 05 00000000 R		lea	EAX,OFFSET $S000531
 00000953  6A 00			push	000000000h 
 00000955  50				push	EAX 
 00000956  E8 00000000 E		call	 Console_WriteString 
 0000095B  EB A0			jmp	OFFSET $L000651 
 0000095D			$L000652:

				;{15}:Console::Write("| ");
 0000095D  8D 05 00000556 R		lea	EAX,OFFSET $S000532
 00000963  6A 00			push	000000000h
 00000965  50				push	EAX 
 00000966  E8 00000000 E		call	 Console_WriteString
				;}
 0000096B  E9 FFFFFF5D			jmp	OFFSET $L000648 
 00000970			$L000649:
				;}
 00000970			$L000523:

 00000970  5F				pop	EDI
 00000971  5E				pop	ESI 
 00000972  5B				pop	EBX 
 00000973  8B E5			mov	ESP,EBP
 00000975  5D				pop	EBP 
 00000976  C2 000C			retn	00000000Ch
 00000979			Program_ShowMatrixForm ENDP

 00000979			Program_SumMatrices PROC NEAR 
				;void Program::SumMatrices(double double [] A, double double [] B, int rows, int cols, Program::OpType what);
 00000979  55				push	EBP
 0000097A  8B EC			mov	EBP,ESP
 0000097C  83 EC 18			sub	ESP,000000018h
 0000097F  53				push	EBX 
 00000980  56				push	ESI 
 00000981  57				push	EDI 
				;{

				;{54}:Res= new double[rows * cols];
 00000982  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000985  50				push	EAX
 00000986  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000989  59				pop	ECX
 0000098A  99				cdq	
 0000098B  0F AF C1			imul	EAX,ECX
 0000098E  6B C0 08			imul	EAX,000000008h
 00000991  50				push	EAX
 00000992  8B D8			mov	EBX,EAX
 00000994  E8 00000000 E		call	 System_Memory_New
 00000999  85 C0			test	EAX,EAX
 0000099B  74 04			jz	 $L000653
 0000099D  8B F0			mov	ESI,EAX 
 0000099F  EB 02			jmp	 $L000654
 000009A1			$L000653:
 000009A1  33 F6			xor	ESI,ESI
 000009A3			$L000654:
 000009A3  89 75 FC			mov	dword ptr [EBP-0004h],ESI 

				;{55}:Result= 0.0;
 000009A6  D9 EE			fldz
 000009A8  DD 5D F4			fstp	qword ptr [EBP-000Ch]

				;{56}:for(i= 0; i < rows; i++ )
 000009AB  33 C0			xor	EAX,EAX
 000009AD  89 45 F0			mov	dword ptr [EBP-0010h],EAX
 000009B0  EB 06			jmp	OFFSET $L000655
 000009B2			$L000656:
 000009B2  8B 45 F0			mov	EAX,dword ptr [EBP-16]
 000009B5  FF 45 F0			inc	dword ptr [EBP-16]
 000009B8			$L000655:
 000009B8  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 000009BB  50				push	EAX
 000009BC  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 000009BF  5A				pop	EDX
 000009C0  3B D0			cmp	EDX,EAX
 000009C2  0F 9C C0			setl	AL
 000009C5  84 C0			test	AL,AL
 000009C7  0F 84 0000016E		jz	OFFSET $L000657

				;{57}:for(j= 0; j < cols; j++ )
 000009CD  33 C0			xor	EAX,EAX
 000009CF  89 45 EC			mov	dword ptr [EBP-0014h],EAX
 000009D2  EB 06			jmp	OFFSET $L000658
 000009D4			$L000659:
 000009D4  8B 45 EC			mov	EAX,dword ptr [EBP-20]
 000009D7  FF 45 EC			inc	dword ptr [EBP-20]
 000009DA			$L000658:
 000009DA  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 000009DD  50				push	EAX
 000009DE  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 000009E1  5A				pop	EDX
 000009E2  3B D0			cmp	EDX,EAX
 000009E4  0F 9C C0			setl	AL
 000009E7  84 C0			test	AL,AL
 000009E9  0F 84 00000147		jz	OFFSET $L000660
				;{

				;{58}:if(Program::Sum == what)
 000009EF  B8 00000001			mov	EAX,000000001h
 000009F4  50				push	EAX
 000009F5  8B 45 18			mov	EAX,dword ptr [EBP+0018h]
 000009F8  5A				pop	EDX
 000009F9  3B D0			cmp	EDX,EAX
 000009FB  0F 94 C0			setz	AL
 000009FE  84 C0			test	AL,AL
 00000A00  74 7D			jz	OFFSET $L000661

				;{59}:Result= A[(i * cols + j) * sizeof (double)] + B[(i * cols + j) * sizeof (double)];
 00000A02  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000A05  8B C3			mov	EAX,EBX 
 00000A07  50				push	EAX
 00000A08  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000A0B  50				push	EAX
 00000A0C  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000A0F  59				pop	ECX
 00000A10  99				cdq	
 00000A11  0F AF C1			imul	EAX,ECX
 00000A14  50				push	EAX
 00000A15  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000A18  5A				pop	EDX
 00000A19  03 C2			add	EAX,EDX
 00000A1B  50				push	EAX
 00000A1C  B8 00000008			mov	EAX,000000008h
 00000A21  59				pop	ECX
 00000A22  99				cdq	
 00000A23  0F AF C1			imul	EAX,ECX
 00000A26  5E				pop	ESI
 00000A27  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000A2A  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000A31  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000A34  50				push	EAX
 00000A35  52				push	EDX 
 00000A36  8B 5D 0C			mov	EBX,dword ptr [EBP+000Ch]
 00000A39  8B C3			mov	EAX,EBX 
 00000A3B  50				push	EAX
 00000A3C  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000A3F  50				push	EAX
 00000A40  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000A43  59				pop	ECX
 00000A44  99				cdq	
 00000A45  0F AF C1			imul	EAX,ECX
 00000A48  50				push	EAX
 00000A49  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000A4C  5A				pop	EDX
 00000A4D  03 C2			add	EAX,EDX
 00000A4F  50				push	EAX
 00000A50  B8 00000008			mov	EAX,000000008h
 00000A55  59				pop	ECX
 00000A56  99				cdq	
 00000A57  0F AF C1			imul	EAX,ECX
 00000A5A  5E				pop	ESI
 00000A5B  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000A5E  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000A65  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000A68  50				push	EAX
 00000A69  52				push	EDX 
 00000A6A  DD 04 24			fld	qword ptr [ESP]
 00000A6D  59				pop	ECX
 00000A6E  59				pop	ECX 
 00000A6F  DC 04 24			fadd	qword ptr [ESP]
 00000A72  DD 1C 24			fstp	qword ptr [ESP]
 00000A75  DD C0			ffree	st
 00000A77  DD 04 24			fld	qword ptr [ESP]
 00000A7A  DD 5D F4			fstp	qword ptr [EBP-000Ch]
 00000A7D  EB 7D			jmp	OFFSET $L000662

				; else {
 00000A7F			$L000661:

				;{61}:Result= A[(i * cols + j) * sizeof (double)] - B[(i * cols + j) * sizeof (double)];
 00000A7F  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000A82  8B C3			mov	EAX,EBX 
 00000A84  50				push	EAX
 00000A85  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000A88  50				push	EAX
 00000A89  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000A8C  59				pop	ECX
 00000A8D  99				cdq	
 00000A8E  0F AF C1			imul	EAX,ECX
 00000A91  50				push	EAX
 00000A92  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000A95  5A				pop	EDX
 00000A96  03 C2			add	EAX,EDX
 00000A98  50				push	EAX
 00000A99  B8 00000008			mov	EAX,000000008h
 00000A9E  59				pop	ECX
 00000A9F  99				cdq	
 00000AA0  0F AF C1			imul	EAX,ECX
 00000AA3  5E				pop	ESI
 00000AA4  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000AA7  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000AAE  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000AB1  50				push	EAX
 00000AB2  52				push	EDX 
 00000AB3  8B 5D 0C			mov	EBX,dword ptr [EBP+000Ch]
 00000AB6  8B C3			mov	EAX,EBX 
 00000AB8  50				push	EAX
 00000AB9  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000ABC  50				push	EAX
 00000ABD  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000AC0  59				pop	ECX
 00000AC1  99				cdq	
 00000AC2  0F AF C1			imul	EAX,ECX
 00000AC5  50				push	EAX
 00000AC6  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000AC9  5A				pop	EDX
 00000ACA  03 C2			add	EAX,EDX
 00000ACC  50				push	EAX
 00000ACD  B8 00000008			mov	EAX,000000008h
 00000AD2  59				pop	ECX
 00000AD3  99				cdq	
 00000AD4  0F AF C1			imul	EAX,ECX
 00000AD7  5E				pop	ESI
 00000AD8  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000ADB  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000AE2  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000AE5  50				push	EAX
 00000AE6  52				push	EDX 
 00000AE7  DD 04 24			fld	qword ptr [ESP]
 00000AEA  59				pop	ECX
 00000AEB  59				pop	ECX 
 00000AEC  DD 04 24			fld	qword ptr [ESP]
 00000AEF  D8 E1			fsub	st,st(1)
 00000AF1  DD 1C 24			fstp	qword ptr [ESP]
 00000AF4  DD C0			ffree	st
 00000AF6  DD 04 24			fld	qword ptr [ESP]
 00000AF9  DD 5D F4			fstp	qword ptr [EBP-000Ch]
 00000AFC			$L000662:

				; }

				;{63}:Res[(i * cols + j) * sizeof (double)]= Result;
 00000AFC  5A				pop	EDX
 00000AFD  58				pop	EAX 
 00000AFE  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000B01  50				push	EAX
 00000B02  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000B05  50				push	EAX
 00000B06  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000B09  59				pop	ECX
 00000B0A  99				cdq	
 00000B0B  0F AF C1			imul	EAX,ECX
 00000B0E  50				push	EAX
 00000B0F  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000B12  5A				pop	EDX
 00000B13  03 C2			add	EAX,EDX
 00000B15  50				push	EAX
 00000B16  B8 00000008			mov	EAX,000000008h
 00000B1B  59				pop	ECX
 00000B1C  99				cdq	
 00000B1D  0F AF C1			imul	EAX,ECX
 00000B20  5E				pop	ESI
 00000B21  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 00000B24  50				push	EAX
 00000B25  8B 55 F4			mov	EDX,dword ptr [EBP-000Ch]
 00000B28  8B 45 F8			mov	EAX,dword ptr [EBP-0008h] 
 00000B2B  5B				pop	EBX
 00000B2C  89 13			mov	dword ptr [EBX],EDX
 00000B2E  89 43 04			mov	dword ptr [EBX+4],EAX 
				;}
 00000B31  E9 FFFFFE9E			jmp	OFFSET $L000659 
 00000B36			$L000660:
 00000B36  E9 FFFFFE77			jmp	OFFSET $L000656 
 00000B3B			$L000657:

				;{66}:Program::ShowMatrixForm(Res, rows, cols);
 00000B3B  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000B3E  50				push	EAX 
 00000B3F  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000B42  50				push	EAX 
 00000B43  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000B46  50				push	EAX
 00000B47  E8 FFFFFD71			call	 Program_ShowMatrixForm

				;{68}:destroy []Res;
 00000B4C  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000B4F  85 C0			test	EAX,EAX
 00000B51  74 06			jz	OFFSET $L000663
 00000B53  50				push	EAX
 00000B54  E8 00000000 E		call	 System_Memory_Destroy
 00000B59			$L000663:

				;{69}:Res= null;
 00000B59  33 C0			xor	EAX,EAX
 00000B5B  8D 5D FC			lea	EBX,dword ptr [EBP-0004h]
 00000B5E  89 03			mov	dword ptr [EBX],EAX
				;}
 00000B60			$L000554:

 00000B60  5F				pop	EDI
 00000B61  5E				pop	ESI 
 00000B62  5B				pop	EBX 
 00000B63  8B E5			mov	ESP,EBP
 00000B65  5D				pop	EBP 
 00000B66  C2 0014			retn	000000014h
 00000B69			Program_SumMatrices ENDP

 00000B69			Program_Traspose PROC NEAR 
				;void Program::Traspose(double double [] M, int rM, int cM);
 00000B69  55				push	EBP
 00000B6A  8B EC			mov	EBP,ESP
 00000B6C  83 EC 10			sub	ESP,000000010h
 00000B6F  53				push	EBX 
 00000B70  56				push	ESI 
 00000B71  57				push	EDI 
				;{

				;{31}:Res= new double[rM * cM];
 00000B72  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 00000B75  50				push	EAX
 00000B76  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000B79  59				pop	ECX
 00000B7A  99				cdq	
 00000B7B  0F AF C1			imul	EAX,ECX
 00000B7E  6B C0 08			imul	EAX,000000008h
 00000B81  50				push	EAX
 00000B82  8B D8			mov	EBX,EAX
 00000B84  E8 00000000 E		call	 System_Memory_New
 00000B89  85 C0			test	EAX,EAX
 00000B8B  74 04			jz	 $L000664
 00000B8D  8B F0			mov	ESI,EAX 
 00000B8F  EB 02			jmp	 $L000665
 00000B91			$L000664:
 00000B91  33 F6			xor	ESI,ESI
 00000B93			$L000665:
 00000B93  89 75 FC			mov	dword ptr [EBP-0004h],ESI 

				;{33}:for(i= 0; i < rM; i++ )
 00000B96  33 C0			xor	EAX,EAX
 00000B98  89 45 F8			mov	dword ptr [EBP-0008h],EAX
 00000B9B  EB 06			jmp	OFFSET $L000666
 00000B9D			$L000667:
 00000B9D  8B 45 F8			mov	EAX,dword ptr [EBP-8]
 00000BA0  FF 45 F8			inc	dword ptr [EBP-8]
 00000BA3			$L000666:
 00000BA3  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000BA6  50				push	EAX
 00000BA7  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 00000BAA  5A				pop	EDX
 00000BAB  3B D0			cmp	EDX,EAX
 00000BAD  0F 9C C0			setl	AL
 00000BB0  84 C0			test	AL,AL
 00000BB2  0F 84 00000084		jz	OFFSET $L000668

				;{34}:for(j= 0; j < cM; j++ )
 00000BB8  33 C0			xor	EAX,EAX
 00000BBA  89 45 F4			mov	dword ptr [EBP-000Ch],EAX
 00000BBD  EB 06			jmp	OFFSET $L000669
 00000BBF			$L000670:
 00000BBF  8B 45 F4			mov	EAX,dword ptr [EBP-12]
 00000BC2  FF 45 F4			inc	dword ptr [EBP-12]
 00000BC5			$L000669:
 00000BC5  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 00000BC8  50				push	EAX
 00000BC9  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000BCC  5A				pop	EDX
 00000BCD  3B D0			cmp	EDX,EAX
 00000BCF  0F 9C C0			setl	AL
 00000BD2  84 C0			test	AL,AL
 00000BD4  74 61			jz	OFFSET $L000671

				;{35}:Res[(j * cM + i) * sizeof (double)]= M[(i * cM + j) * sizeof (double)];
 00000BD6  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000BD9  50				push	EAX
 00000BDA  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 00000BDD  50				push	EAX
 00000BDE  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000BE1  59				pop	ECX
 00000BE2  99				cdq	
 00000BE3  0F AF C1			imul	EAX,ECX
 00000BE6  50				push	EAX
 00000BE7  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000BEA  5A				pop	EDX
 00000BEB  03 C2			add	EAX,EDX
 00000BED  50				push	EAX
 00000BEE  B8 00000008			mov	EAX,000000008h
 00000BF3  59				pop	ECX
 00000BF4  99				cdq	
 00000BF5  0F AF C1			imul	EAX,ECX
 00000BF8  5E				pop	ESI
 00000BF9  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 00000BFC  50				push	EAX
 00000BFD  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000C00  8B C3			mov	EAX,EBX 
 00000C02  50				push	EAX
 00000C03  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000C06  50				push	EAX
 00000C07  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000C0A  59				pop	ECX
 00000C0B  99				cdq	
 00000C0C  0F AF C1			imul	EAX,ECX
 00000C0F  50				push	EAX
 00000C10  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 00000C13  5A				pop	EDX
 00000C14  03 C2			add	EAX,EDX
 00000C16  50				push	EAX
 00000C17  B8 00000008			mov	EAX,000000008h
 00000C1C  59				pop	ECX
 00000C1D  99				cdq	
 00000C1E  0F AF C1			imul	EAX,ECX
 00000C21  5E				pop	ESI
 00000C22  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000C25  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000C2C  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000C2F  5B				pop	EBX
 00000C30  89 13			mov	dword ptr [EBX],EDX
 00000C32  89 43 04			mov	dword ptr [EBX+4],EAX 
 00000C35  EB 88			jmp	OFFSET $L000670 
 00000C37			$L000671:
 00000C37  E9 FFFFFF61			jmp	OFFSET $L000667 
 00000C3C			$L000668:

				;{37}:Program::ShowMatrixForm(Res, rM, cM);
 00000C3C  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000C3F  50				push	EAX 
 00000C40  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 00000C43  50				push	EAX 
 00000C44  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000C47  50				push	EAX
 00000C48  E8 FFFFFC70			call	 Program_ShowMatrixForm

				;{39}:destroy []Res;
 00000C4D  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000C50  85 C0			test	EAX,EAX
 00000C52  74 06			jz	OFFSET $L000672
 00000C54  50				push	EAX
 00000C55  E8 00000000 E		call	 System_Memory_Destroy
 00000C5A			$L000672:

				;{40}:Res= null;
 00000C5A  33 C0			xor	EAX,EAX
 00000C5C  8D 5D FC			lea	EBX,dword ptr [EBP-0004h]
 00000C5F  89 03			mov	dword ptr [EBX],EAX
				;}
 00000C61			$L000544:

 00000C61  5F				pop	EDI
 00000C62  5E				pop	ESI 
 00000C63  5B				pop	EBX 
 00000C64  8B E5			mov	ESP,EBP
 00000C66  5D				pop	EBP 
 00000C67  C2 000C			retn	00000000Ch
 00000C6A			Program_Traspose ENDP

 00000C6A			Program_main PROC NEAR 
				;void Program::main(void);
 00000C6A  55				push	EBP
 00000C6B  8B EC			mov	EBP,ESP
 00000C6D  83 EC 3C			sub	ESP,00000003Ch
 00000C70  53				push	EBX 
 00000C71  56				push	ESI 
 00000C72  57				push	EDI 
				;{

				;{108}:Tr= 0.0;
 00000C73  D9 EE			fldz
 00000C75  DD 5D F8			fstp	qword ptr [EBP-0008h]

				;{109}:bExitProgram= false;
 00000C78  33 C0			xor	EAX,EAX
 00000C7A  88 45 F4			mov	byte ptr [EBP-000Ch],AL

				;{110}:bReEnterMatrices= false;
 00000C7D  33 C0			xor	EAX,EAX
 00000C7F  88 45 F0			mov	byte ptr [EBP-0010h],AL

				;{111}:while(true)
 00000C82			$L000673:
 00000C82  B8 00000001			mov	EAX,000000001h
 00000C87  84 C0			test	AL,AL
 00000C89  0F 84 000008EF		jz	OFFSET $L000674
				;{

				;{113}:Console::ClearScreen();
 00000C8F  E8 00000000 E		call	 Console_ClearScreen

				;{114}:Console::WriteLn("Programa de Matrices\n\n");
 00000C94  8D 05 00000452 R		lea	EAX,OFFSET $S000580
 00000C9A  6A 00			push	000000000h
 00000C9C  50				push	EAX 
 00000C9D  E8 00000000 E		call	 Console_WriteString
 00000CA2  E8 00000000 E		call	 Console_WriteCrLf 

				;{115}:Console::WriteLn("Entre las dimensiones de dos matrices:\n");
 00000CA7  8D 05 000002F0 R		lea	EAX,OFFSET $S000581
 00000CAD  6A 00			push	000000000h
 00000CAF  50				push	EAX 
 00000CB0  E8 00000000 E		call	 Console_WriteString
 00000CB5  E8 00000000 E		call	 Console_WriteCrLf 

				;{116}:Console::Write("Entre las filas de A: ");
 00000CBA  8D 05 00000318 R		lea	EAX,OFFSET $S000582
 00000CC0  6A 00			push	000000000h
 00000CC2  50				push	EAX 
 00000CC3  E8 00000000 E		call	 Console_WriteString

				;{117}:rA= Console::ReadInteger();
 00000CC8  E8 00000000 E		call	 Console_ReadInteger
 00000CCD  89 45 EC			mov	dword ptr [EBP-0014h],EAX

				;{118}:Console::Write("\nEntre las columnas de A: ");
 00000CD0  8D 05 0000046E R		lea	EAX,OFFSET $S000584
 00000CD6  6A 00			push	000000000h
 00000CD8  50				push	EAX 
 00000CD9  E8 00000000 E		call	 Console_WriteString

				;{119}:cA= Console::ReadInteger();
 00000CDE  E8 00000000 E		call	 Console_ReadInteger
 00000CE3  89 45 E8			mov	dword ptr [EBP-0018h],EAX

				;{121}:Console::Write("\nEntre las filas de B: ");
 00000CE6  8D 05 000004A4 R		lea	EAX,OFFSET $S000586
 00000CEC  6A 00			push	000000000h
 00000CEE  50				push	EAX 
 00000CEF  E8 00000000 E		call	 Console_WriteString

				;{122}:rB= Console::ReadInteger();
 00000CF4  E8 00000000 E		call	 Console_ReadInteger
 00000CF9  89 45 E4			mov	dword ptr [EBP-001Ch],EAX

				;{123}:Console::Write("\nEntre las columnas de B: ");
 00000CFC  8D 05 00000489 R		lea	EAX,OFFSET $S000588
 00000D02  6A 00			push	000000000h
 00000D04  50				push	EAX 
 00000D05  E8 00000000 E		call	 Console_WriteString

				;{124}:cB= Console::ReadInteger();
 00000D0A  E8 00000000 E		call	 Console_ReadInteger
 00000D0F  89 45 E0			mov	dword ptr [EBP-0020h],EAX

				;{126}:Console::ClearScreen();
 00000D12  E8 00000000 E		call	 Console_ClearScreen

				;{128}:x= 'N';
 00000D17  B8 0000004E			mov	EAX,00000004Eh
 00000D1C  88 45 DC			mov	byte ptr [EBP-0024h],AL

				;{129}:if(rA <= 0 || rB <= 0)
 00000D1F  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000D22  50				push	EAX
 00000D23  33 C0			xor	EAX,EAX
 00000D25  5A				pop	EDX
 00000D26  3B D0			cmp	EDX,EAX
 00000D28  0F 9E C0			setle	AL
 00000D2B  84 C0			test	AL,AL
 00000D2D  75 0C			jnz	OFFSET $L000677
 00000D2F  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 00000D32  50				push	EAX
 00000D33  33 C0			xor	EAX,EAX
 00000D35  5A				pop	EDX
 00000D36  3B D0			cmp	EDX,EAX
 00000D38  0F 9E C0			setle	AL
 00000D3B			$L000677:
 00000D3B  84 C0			test	AL,AL
 00000D3D  74 4D			jz	OFFSET $L000675
				;{

				;{131}:Console::WriteLn("El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
 00000D3F  8D 05 00000240 R		lea	EAX,OFFSET $S000592
 00000D45  6A 00			push	000000000h
 00000D47  50				push	EAX 
 00000D48  E8 00000000 E		call	 Console_WriteString
 00000D4D  E8 00000000 E		call	 Console_WriteCrLf 

				;{132}:x= Console::ReadChar();
 00000D52  E8 00000000 E		call	 Console_ReadChar
 00000D57  88 45 DC			mov	byte ptr [EBP-0024h],AL

				;{133}:if(x == 'y' || x == 'Y')
 00000D5A  0F BE 45 DC			movsx	EAX,byte ptr [EBP-0024h]
 00000D5E  50				push	EAX
 00000D5F  B8 00000079			mov	EAX,000000079h
 00000D64  5A				pop	EDX
 00000D65  38 C2			cmp	DL,AL
 00000D67  0F 94 C0			setz	AL
 00000D6A  84 C0			test	AL,AL
 00000D6C  75 10			jnz	OFFSET $L000680
 00000D6E  0F BE 45 DC			movsx	EAX,byte ptr [EBP-0024h]
 00000D72  50				push	EAX
 00000D73  B8 00000059			mov	EAX,000000059h
 00000D78  5A				pop	EDX
 00000D79  38 C2			cmp	DL,AL
 00000D7B  0F 94 C0			setz	AL
 00000D7E			$L000680:
 00000D7E  84 C0			test	AL,AL
 00000D80  74 05			jz	OFFSET $L000678

				;continue;
 00000D82  E9 FFFFFEFB			jmp	OFFSET $L000673
 00000D87			$L000678:

				;break;
 00000D87  E9 000007F2			jmp	OFFSET $L000674
				;}
 00000D8C			$L000675:

				;{138}:if(rA > 10 || rB > 10)
 00000D8C  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000D8F  50				push	EAX
 00000D90  B8 0000000A			mov	EAX,00000000Ah
 00000D95  5A				pop	EDX
 00000D96  3B D0			cmp	EDX,EAX
 00000D98  0F 9F C0			setg	AL
 00000D9B  84 C0			test	AL,AL
 00000D9D  75 0F			jnz	OFFSET $L000683
 00000D9F  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 00000DA2  50				push	EAX
 00000DA3  B8 0000000A			mov	EAX,00000000Ah
 00000DA8  5A				pop	EDX
 00000DA9  3B D0			cmp	EDX,EAX
 00000DAB  0F 9F C0			setg	AL
 00000DAE			$L000683:
 00000DAE  84 C0			test	AL,AL
 00000DB0  74 4D			jz	OFFSET $L000681
				;{

				;{140}:Console::WriteLn("El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
 00000DB2  8D 05 00000240 R		lea	EAX,OFFSET $S000592
 00000DB8  6A 00			push	000000000h
 00000DBA  50				push	EAX 
 00000DBB  E8 00000000 E		call	 Console_WriteString
 00000DC0  E8 00000000 E		call	 Console_WriteCrLf 

				;{141}:x= Console::ReadChar();
 00000DC5  E8 00000000 E		call	 Console_ReadChar
 00000DCA  88 45 DC			mov	byte ptr [EBP-0024h],AL

				;{142}:if(x == 'y' || x == 'Y')
 00000DCD  0F BE 45 DC			movsx	EAX,byte ptr [EBP-0024h]
 00000DD1  50				push	EAX
 00000DD2  B8 00000079			mov	EAX,000000079h
 00000DD7  5A				pop	EDX
 00000DD8  38 C2			cmp	DL,AL
 00000DDA  0F 94 C0			setz	AL
 00000DDD  84 C0			test	AL,AL
 00000DDF  75 10			jnz	OFFSET $L000686
 00000DE1  0F BE 45 DC			movsx	EAX,byte ptr [EBP-0024h]
 00000DE5  50				push	EAX
 00000DE6  B8 00000059			mov	EAX,000000059h
 00000DEB  5A				pop	EDX
 00000DEC  38 C2			cmp	DL,AL
 00000DEE  0F 94 C0			setz	AL
 00000DF1			$L000686:
 00000DF1  84 C0			test	AL,AL
 00000DF3  74 05			jz	OFFSET $L000684

				;continue;
 00000DF5  E9 FFFFFE88			jmp	OFFSET $L000673
 00000DFA			$L000684:

				;break;
 00000DFA  E9 0000077F			jmp	OFFSET $L000674
				;}
 00000DFF			$L000681:

				;{147}:if(cA <= 0 || cB <= 0)
 00000DFF  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00000E02  50				push	EAX
 00000E03  33 C0			xor	EAX,EAX
 00000E05  5A				pop	EDX
 00000E06  3B D0			cmp	EDX,EAX
 00000E08  0F 9E C0			setle	AL
 00000E0B  84 C0			test	AL,AL
 00000E0D  75 0C			jnz	OFFSET $L000689
 00000E0F  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00000E12  50				push	EAX
 00000E13  33 C0			xor	EAX,EAX
 00000E15  5A				pop	EDX
 00000E16  3B D0			cmp	EDX,EAX
 00000E18  0F 9E C0			setle	AL
 00000E1B			$L000689:
 00000E1B  84 C0			test	AL,AL
 00000E1D  74 4D			jz	OFFSET $L000687
				;{

				;{149}:Console::WriteLn("El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
 00000E1F  8D 05 00000118 R		lea	EAX,OFFSET $S000596
 00000E25  6A 00			push	000000000h
 00000E27  50				push	EAX 
 00000E28  E8 00000000 E		call	 Console_WriteString
 00000E2D  E8 00000000 E		call	 Console_WriteCrLf 

				;{150}:x= Console::ReadChar();
 00000E32  E8 00000000 E		call	 Console_ReadChar
 00000E37  88 45 DC			mov	byte ptr [EBP-0024h],AL

				;{151}:if(x == 'y' || x == 'Y')
 00000E3A  0F BE 45 DC			movsx	EAX,byte ptr [EBP-0024h]
 00000E3E  50				push	EAX
 00000E3F  B8 00000079			mov	EAX,000000079h
 00000E44  5A				pop	EDX
 00000E45  38 C2			cmp	DL,AL
 00000E47  0F 94 C0			setz	AL
 00000E4A  84 C0			test	AL,AL
 00000E4C  75 10			jnz	OFFSET $L000692
 00000E4E  0F BE 45 DC			movsx	EAX,byte ptr [EBP-0024h]
 00000E52  50				push	EAX
 00000E53  B8 00000059			mov	EAX,000000059h
 00000E58  5A				pop	EDX
 00000E59  38 C2			cmp	DL,AL
 00000E5B  0F 94 C0			setz	AL
 00000E5E			$L000692:
 00000E5E  84 C0			test	AL,AL
 00000E60  74 05			jz	OFFSET $L000690

				;continue;
 00000E62  E9 FFFFFE1B			jmp	OFFSET $L000673
 00000E67			$L000690:

				;break;
 00000E67  E9 00000712			jmp	OFFSET $L000674
				;}
 00000E6C			$L000687:

				;{156}:if(cA > 10 || cB > 10)
 00000E6C  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00000E6F  50				push	EAX
 00000E70  B8 0000000A			mov	EAX,00000000Ah
 00000E75  5A				pop	EDX
 00000E76  3B D0			cmp	EDX,EAX
 00000E78  0F 9F C0			setg	AL
 00000E7B  84 C0			test	AL,AL
 00000E7D  75 0F			jnz	OFFSET $L000695
 00000E7F  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00000E82  50				push	EAX
 00000E83  B8 0000000A			mov	EAX,00000000Ah
 00000E88  5A				pop	EDX
 00000E89  3B D0			cmp	EDX,EAX
 00000E8B  0F 9F C0			setg	AL
 00000E8E			$L000695:
 00000E8E  84 C0			test	AL,AL
 00000E90  74 4D			jz	OFFSET $L000693
				;{

				;{158}:Console::WriteLn("El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
 00000E92  8D 05 00000118 R		lea	EAX,OFFSET $S000596
 00000E98  6A 00			push	000000000h
 00000E9A  50				push	EAX 
 00000E9B  E8 00000000 E		call	 Console_WriteString
 00000EA0  E8 00000000 E		call	 Console_WriteCrLf 

				;{159}:x= Console::ReadChar();
 00000EA5  E8 00000000 E		call	 Console_ReadChar
 00000EAA  88 45 DC			mov	byte ptr [EBP-0024h],AL

				;{160}:if(x == 'y' || x == 'Y')
 00000EAD  0F BE 45 DC			movsx	EAX,byte ptr [EBP-0024h]
 00000EB1  50				push	EAX
 00000EB2  B8 00000079			mov	EAX,000000079h
 00000EB7  5A				pop	EDX
 00000EB8  38 C2			cmp	DL,AL
 00000EBA  0F 94 C0			setz	AL
 00000EBD  84 C0			test	AL,AL
 00000EBF  75 10			jnz	OFFSET $L000698
 00000EC1  0F BE 45 DC			movsx	EAX,byte ptr [EBP-0024h]
 00000EC5  50				push	EAX
 00000EC6  B8 00000059			mov	EAX,000000059h
 00000ECB  5A				pop	EDX
 00000ECC  38 C2			cmp	DL,AL
 00000ECE  0F 94 C0			setz	AL
 00000ED1			$L000698:
 00000ED1  84 C0			test	AL,AL
 00000ED3  74 05			jz	OFFSET $L000696

				;continue;
 00000ED5  E9 FFFFFDA8			jmp	OFFSET $L000673
 00000EDA			$L000696:

				;break;
 00000EDA  E9 0000069F			jmp	OFFSET $L000674
				;}
 00000EDF			$L000693:

				;{165}:A= new double[rA * cA];
 00000EDF  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000EE2  50				push	EAX
 00000EE3  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00000EE6  59				pop	ECX
 00000EE7  99				cdq	
 00000EE8  0F AF C1			imul	EAX,ECX
 00000EEB  6B C0 08			imul	EAX,000000008h
 00000EEE  50				push	EAX
 00000EEF  8B D8			mov	EBX,EAX
 00000EF1  E8 00000000 E		call	 System_Memory_New
 00000EF6  85 C0			test	EAX,EAX
 00000EF8  74 04			jz	 $L000699
 00000EFA  8B F0			mov	ESI,EAX 
 00000EFC  EB 02			jmp	 $L000700
 00000EFE			$L000699:
 00000EFE  33 F6			xor	ESI,ESI
 00000F00			$L000700:
 00000F00  89 75 D8			mov	dword ptr [EBP-0028h],ESI 

				;{166}:B= new double[rB * cB];
 00000F03  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 00000F06  50				push	EAX
 00000F07  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00000F0A  59				pop	ECX
 00000F0B  99				cdq	
 00000F0C  0F AF C1			imul	EAX,ECX
 00000F0F  6B C0 08			imul	EAX,000000008h
 00000F12  50				push	EAX
 00000F13  8B D8			mov	EBX,EAX
 00000F15  E8 00000000 E		call	 System_Memory_New
 00000F1A  85 C0			test	EAX,EAX
 00000F1C  74 04			jz	 $L000701
 00000F1E  8B F0			mov	ESI,EAX 
 00000F20  EB 02			jmp	 $L000702
 00000F22			$L000701:
 00000F22  33 F6			xor	ESI,ESI
 00000F24			$L000702:
 00000F24  89 75 D4			mov	dword ptr [EBP-002Ch],ESI 

				;{168}:Console::WriteLn("Entre los valores para la matriz A[", rA, "][", cA, "]");
 00000F27  8D 05 0000032F R		lea	EAX,OFFSET $S000599
 00000F2D  6A 00			push	000000000h
 00000F2F  50				push	EAX 
 00000F30  E8 00000000 E		call	 Console_WriteString
 00000F35  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000F38  50				push	EAX 
 00000F39  E8 00000000 E		call	 Console_WriteInteger 
 00000F3E  8D 05 00000553 R		lea	EAX,OFFSET $S000600
 00000F44  6A 00			push	000000000h 
 00000F46  50				push	EAX 
 00000F47  E8 00000000 E		call	 Console_WriteString 
 00000F4C  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00000F4F  50				push	EAX 
 00000F50  E8 00000000 E		call	 Console_WriteInteger 
 00000F55  B8 0000005D			mov	EAX,00000005Dh
 00000F5A  50				push	EAX 
 00000F5B  E8 00000000 E		call	 Console_WriteChar 
 00000F60  E8 00000000 E		call	 Console_WriteCrLf 

				;{169}:for(i= 0; i < rA; i++ )
 00000F65  33 C0			xor	EAX,EAX
 00000F67  89 45 D0			mov	dword ptr [EBP-0030h],EAX
 00000F6A  EB 06			jmp	OFFSET $L000703
 00000F6C			$L000704:
 00000F6C  8B 45 D0			mov	EAX,dword ptr [EBP-48]
 00000F6F  FF 45 D0			inc	dword ptr [EBP-48]
 00000F72			$L000703:
 00000F72  8B 45 D0			mov	EAX,dword ptr [EBP-0030h]
 00000F75  50				push	EAX
 00000F76  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00000F79  5A				pop	EDX
 00000F7A  3B D0			cmp	EDX,EAX
 00000F7C  0F 9C C0			setl	AL
 00000F7F  84 C0			test	AL,AL
 00000F81  0F 84 00000093		jz	OFFSET $L000705

				;{170}:for(j= 0; j < cA; j++ )
 00000F87  33 C0			xor	EAX,EAX
 00000F89  89 45 CC			mov	dword ptr [EBP-0034h],EAX
 00000F8C  EB 06			jmp	OFFSET $L000706
 00000F8E			$L000707:
 00000F8E  8B 45 CC			mov	EAX,dword ptr [EBP-52]
 00000F91  FF 45 CC			inc	dword ptr [EBP-52]
 00000F94			$L000706:
 00000F94  8B 45 CC			mov	EAX,dword ptr [EBP-0034h]
 00000F97  50				push	EAX
 00000F98  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00000F9B  5A				pop	EDX
 00000F9C  3B D0			cmp	EDX,EAX
 00000F9E  0F 9C C0			setl	AL
 00000FA1  84 C0			test	AL,AL
 00000FA3  74 70			jz	OFFSET $L000708
				;{

				;{172}:Console::Write("Elemento en A[", i, ",", j, "] = ");
 00000FA5  8D 05 0000029F R		lea	EAX,OFFSET $S000604
 00000FAB  6A 00			push	000000000h
 00000FAD  50				push	EAX 
 00000FAE  E8 00000000 E		call	 Console_WriteString
 00000FB3  8B 45 D0			mov	EAX,dword ptr [EBP-0030h]
 00000FB6  50				push	EAX 
 00000FB7  E8 00000000 E		call	 Console_WriteInteger 
 00000FBC  B8 0000002C			mov	EAX,00000002Ch
 00000FC1  50				push	EAX 
 00000FC2  E8 00000000 E		call	 Console_WriteChar 
 00000FC7  8B 45 CC			mov	EAX,dword ptr [EBP-0034h]
 00000FCA  50				push	EAX 
 00000FCB  E8 00000000 E		call	 Console_WriteInteger 
 00000FD0  8D 05 0000054A R		lea	EAX,OFFSET $S000605
 00000FD6  6A 00			push	000000000h 
 00000FD8  50				push	EAX 
 00000FD9  E8 00000000 E		call	 Console_WriteString 

				;{173}:A[(i * cA + j) * sizeof (double)]= Console::ReadDouble();
 00000FDE  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 00000FE1  50				push	EAX
 00000FE2  8B 45 D0			mov	EAX,dword ptr [EBP-0030h]
 00000FE5  50				push	EAX
 00000FE6  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00000FE9  59				pop	ECX
 00000FEA  99				cdq	
 00000FEB  0F AF C1			imul	EAX,ECX
 00000FEE  50				push	EAX
 00000FEF  8B 45 CC			mov	EAX,dword ptr [EBP-0034h]
 00000FF2  5A				pop	EDX
 00000FF3  03 C2			add	EAX,EDX
 00000FF5  50				push	EAX
 00000FF6  B8 00000008			mov	EAX,000000008h
 00000FFB  59				pop	ECX
 00000FFC  99				cdq	
 00000FFD  0F AF C1			imul	EAX,ECX
 00001000  5E				pop	ESI
 00001001  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 00001004  50				push	EAX
 00001005  E8 00000000 E		call	 Console_ReadDouble
 0000100A  5B				pop	EBX
 0000100B  89 13			mov	dword ptr [EBX],EDX
 0000100D  89 43 04			mov	dword ptr [EBX+4],EAX 
				;}
 00001010  E9 FFFFFF79			jmp	OFFSET $L000707 
 00001015			$L000708:
 00001015  E9 FFFFFF52			jmp	OFFSET $L000704 
 0000101A			$L000705:

				;{176}:Console::WriteLn("\nEntre los valores para la matriz B[", rB, "][", cB, "]");
 0000101A  8D 05 000004BC R		lea	EAX,OFFSET $S000606
 00001020  6A 00			push	000000000h
 00001022  50				push	EAX 
 00001023  E8 00000000 E		call	 Console_WriteString
 00001028  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 0000102B  50				push	EAX 
 0000102C  E8 00000000 E		call	 Console_WriteInteger 
 00001031  8D 05 00000553 R		lea	EAX,OFFSET $S000600
 00001037  6A 00			push	000000000h 
 00001039  50				push	EAX 
 0000103A  E8 00000000 E		call	 Console_WriteString 
 0000103F  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00001042  50				push	EAX 
 00001043  E8 00000000 E		call	 Console_WriteInteger 
 00001048  B8 0000005D			mov	EAX,00000005Dh
 0000104D  50				push	EAX 
 0000104E  E8 00000000 E		call	 Console_WriteChar 
 00001053  E8 00000000 E		call	 Console_WriteCrLf 

				;{177}:for(i= 0; i < rB; i++ )
 00001058  33 C0			xor	EAX,EAX
 0000105A  89 45 D0			mov	dword ptr [EBP-0030h],EAX
 0000105D  EB 06			jmp	OFFSET $L000709
 0000105F			$L000710:
 0000105F  8B 45 D0			mov	EAX,dword ptr [EBP-48]
 00001062  FF 45 D0			inc	dword ptr [EBP-48]
 00001065			$L000709:
 00001065  8B 45 D0			mov	EAX,dword ptr [EBP-0030h]
 00001068  50				push	EAX
 00001069  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 0000106C  5A				pop	EDX
 0000106D  3B D0			cmp	EDX,EAX
 0000106F  0F 9C C0			setl	AL
 00001072  84 C0			test	AL,AL
 00001074  0F 84 00000093		jz	OFFSET $L000711

				;{178}:for(j= 0; j < cB; j++ )
 0000107A  33 C0			xor	EAX,EAX
 0000107C  89 45 CC			mov	dword ptr [EBP-0034h],EAX
 0000107F  EB 06			jmp	OFFSET $L000712
 00001081			$L000713:
 00001081  8B 45 CC			mov	EAX,dword ptr [EBP-52]
 00001084  FF 45 CC			inc	dword ptr [EBP-52]
 00001087			$L000712:
 00001087  8B 45 CC			mov	EAX,dword ptr [EBP-0034h]
 0000108A  50				push	EAX
 0000108B  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 0000108E  5A				pop	EDX
 0000108F  3B D0			cmp	EDX,EAX
 00001091  0F 9C C0			setl	AL
 00001094  84 C0			test	AL,AL
 00001096  74 70			jz	OFFSET $L000714
				;{

				;{180}:Console::Write("Elemento en B[", i, ",", j, "] = ");
 00001098  8D 05 000002AE R		lea	EAX,OFFSET $S000607
 0000109E  6A 00			push	000000000h
 000010A0  50				push	EAX 
 000010A1  E8 00000000 E		call	 Console_WriteString
 000010A6  8B 45 D0			mov	EAX,dword ptr [EBP-0030h]
 000010A9  50				push	EAX 
 000010AA  E8 00000000 E		call	 Console_WriteInteger 
 000010AF  B8 0000002C			mov	EAX,00000002Ch
 000010B4  50				push	EAX 
 000010B5  E8 00000000 E		call	 Console_WriteChar 
 000010BA  8B 45 CC			mov	EAX,dword ptr [EBP-0034h]
 000010BD  50				push	EAX 
 000010BE  E8 00000000 E		call	 Console_WriteInteger 
 000010C3  8D 05 0000054A R		lea	EAX,OFFSET $S000605
 000010C9  6A 00			push	000000000h 
 000010CB  50				push	EAX 
 000010CC  E8 00000000 E		call	 Console_WriteString 

				;{181}:B[(i * cB + j) * sizeof (double)]= Console::ReadDouble();
 000010D1  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 000010D4  50				push	EAX
 000010D5  8B 45 D0			mov	EAX,dword ptr [EBP-0030h]
 000010D8  50				push	EAX
 000010D9  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 000010DC  59				pop	ECX
 000010DD  99				cdq	
 000010DE  0F AF C1			imul	EAX,ECX
 000010E1  50				push	EAX
 000010E2  8B 45 CC			mov	EAX,dword ptr [EBP-0034h]
 000010E5  5A				pop	EDX
 000010E6  03 C2			add	EAX,EDX
 000010E8  50				push	EAX
 000010E9  B8 00000008			mov	EAX,000000008h
 000010EE  59				pop	ECX
 000010EF  99				cdq	
 000010F0  0F AF C1			imul	EAX,ECX
 000010F3  5E				pop	ESI
 000010F4  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 000010F7  50				push	EAX
 000010F8  E8 00000000 E		call	 Console_ReadDouble
 000010FD  5B				pop	EBX
 000010FE  89 13			mov	dword ptr [EBX],EDX
 00001100  89 43 04			mov	dword ptr [EBX+4],EAX 
				;}
 00001103  E9 FFFFFF79			jmp	OFFSET $L000713 
 00001108			$L000714:
 00001108  E9 FFFFFF52			jmp	OFFSET $L000710 
 0000110D			$L000711:

				;{185}:Console::WriteLn("Matriz A:\n");
 0000110D  8D 05 00000447 R		lea	EAX,OFFSET $S000608
 00001113  6A 00			push	000000000h
 00001115  50				push	EAX 
 00001116  E8 00000000 E		call	 Console_WriteString
 0000111B  E8 00000000 E		call	 Console_WriteCrLf 

				;{186}:Program::ShowMatrixForm(A, rA, cA);
 00001120  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00001123  50				push	EAX 
 00001124  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00001127  50				push	EAX 
 00001128  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 0000112B  50				push	EAX
 0000112C  E8 FFFFF78C			call	 Program_ShowMatrixForm

				;{187}:Console::WriteLn("\n\nMatriz B:\n");
 00001131  8D 05 000004FE R		lea	EAX,OFFSET $S000609
 00001137  6A 00			push	000000000h
 00001139  50				push	EAX 
 0000113A  E8 00000000 E		call	 Console_WriteString
 0000113F  E8 00000000 E		call	 Console_WriteCrLf 

				;{188}:Program::ShowMatrixForm(B, rB, cB);
 00001144  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00001147  50				push	EAX 
 00001148  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 0000114B  50				push	EAX 
 0000114C  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 0000114F  50				push	EAX
 00001150  E8 FFFFF768			call	 Program_ShowMatrixForm

				;do
 00001155			$L000715:
				;{

				;{191}:Console::WriteLn("\n\nQue deseas hacer?\n");
 00001155  8D 05 00000531 R		lea	EAX,OFFSET $S000610
 0000115B  6A 00			push	000000000h
 0000115D  50				push	EAX 
 0000115E  E8 00000000 E		call	 Console_WriteString
 00001163  E8 00000000 E		call	 Console_WriteCrLf 

				;{192}:Console::WriteLn("0. Mostrar las Matrices\n1. Sumar las matrices.\n2. Restar las matrices.\n3. Multiplicar las matrices (A*B).\n4. Multiplicar las matrices (B*A).\n5. Calcular la traza de A\n6. Calcular la traza de B.\n7. Trasponer matriz A.\n8. Trasponer matriz B.\n9. Re-Entrar Matrices\n10. Salir\n\n");
 00001168  8D 05 00000003 R		lea	EAX,OFFSET $S000611
 0000116E  6A 00			push	000000000h
 00001170  50				push	EAX 
 00001171  E8 00000000 E		call	 Console_WriteString
 00001176  E8 00000000 E		call	 Console_WriteCrLf 

				;{193}:Console::Write(">:");
 0000117B  8D 05 00000115 R		lea	EAX,OFFSET $S000612
 00001181  6A 00			push	000000000h
 00001183  50				push	EAX 
 00001184  E8 00000000 E		call	 Console_WriteString

				;{194}:nOption= Console::ReadInteger();
 00001189  E8 00000000 E		call	 Console_ReadInteger
 0000118E  89 45 C8			mov	dword ptr [EBP-0038h],EAX

				;{195}:switch(nOption)
 00001191  8B 45 C8			mov	EAX,dword ptr [EBP-0038h]
 00001194  8B F0			mov	ESI,EAX
 00001196  33 C0			xor	EAX,EAX
 00001198  3B C6			cmp	EAX,ESI
 0000119A  0F 84 00000087		jz	OFFSET $L000719
 000011A0  B8 00000001			mov	EAX,000000001h
 000011A5  3B C6			cmp	EAX,ESI
 000011A7  0F 84 000000C7		jz	OFFSET $L000720
 000011AD  B8 00000002			mov	EAX,000000002h
 000011B2  3B C6			cmp	EAX,ESI 
 000011B4  0F 84 000000BA		jz	OFFSET $L000721 
 000011BA  B8 00000003			mov	EAX,000000003h
 000011BF  3B C6			cmp	EAX,ESI
 000011C1  0F 84 00000131		jz	OFFSET $L000727
 000011C7  B8 00000004			mov	EAX,000000004h
 000011CC  3B C6			cmp	EAX,ESI
 000011CE  0F 84 0000017F		jz	OFFSET $L000730
 000011D4  B8 00000005			mov	EAX,000000005h
 000011D9  3B C6			cmp	EAX,ESI
 000011DB  0F 84 000001CD		jz	OFFSET $L000733
 000011E1  B8 00000006			mov	EAX,000000006h
 000011E6  3B C6			cmp	EAX,ESI
 000011E8  0F 84 00000202		jz	OFFSET $L000734
 000011EE  B8 00000007			mov	EAX,000000007h
 000011F3  3B C6			cmp	EAX,ESI
 000011F5  0F 84 00000237		jz	OFFSET $L000735
 000011FB  B8 00000008			mov	EAX,000000008h
 00001200  3B C6			cmp	EAX,ESI
 00001202  0F 84 00000276		jz	OFFSET $L000738
 00001208  B8 00000009			mov	EAX,000000009h
 0000120D  3B C6			cmp	EAX,ESI
 0000120F  0F 84 000002B5		jz	OFFSET $L000741
 00001215  B8 0000000A			mov	EAX,00000000Ah
 0000121A  3B C6			cmp	EAX,ESI
 0000121C  0F 84 000002B2		jz	OFFSET $L000742
 00001222  E9 000002B7			jmp	OFFSET $L000743
 00001227			$L000719:
				;{

				;{198}:Console::WriteLn("Matriz A:\n");
 00001227  8D 05 00000447 R		lea	EAX,OFFSET $S000608
 0000122D  6A 00			push	000000000h
 0000122F  50				push	EAX 
 00001230  E8 00000000 E		call	 Console_WriteString
 00001235  E8 00000000 E		call	 Console_WriteCrLf 

				;{199}:Program::ShowMatrixForm(A, rA, cA);
 0000123A  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 0000123D  50				push	EAX 
 0000123E  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00001241  50				push	EAX 
 00001242  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 00001245  50				push	EAX
 00001246  E8 FFFFF672			call	 Program_ShowMatrixForm

				;{200}:Console::WriteLn("\n\nMatriz B:\n");
 0000124B  8D 05 000004FE R		lea	EAX,OFFSET $S000609
 00001251  6A 00			push	000000000h
 00001253  50				push	EAX 
 00001254  E8 00000000 E		call	 Console_WriteString
 00001259  E8 00000000 E		call	 Console_WriteCrLf 

				;{201}:Program::ShowMatrixForm(B, rB, cB);
 0000125E  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00001261  50				push	EAX 
 00001262  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 00001265  50				push	EAX 
 00001266  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 00001269  50				push	EAX
 0000126A  E8 FFFFF64E			call	 Program_ShowMatrixForm
				;}
 0000126F  E9 0000027D			jmp	OFFSET $L000718
 00001274			$L000720:
 00001274			$L000721:
				;{

				;{207}:if(rA != rB || cA != cB)
 00001274  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00001277  50				push	EAX
 00001278  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 0000127B  5A				pop	EDX
 0000127C  3B D0			cmp	EDX,EAX
 0000127E  0F 95 C0			setnz	AL
 00001281  84 C0			test	AL,AL
 00001283  75 0D			jnz	OFFSET $L000724
 00001285  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00001288  50				push	EAX
 00001289  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 0000128C  5A				pop	EDX
 0000128D  3B D0			cmp	EDX,EAX
 0000128F  0F 95 C0			setnz	AL
 00001292			$L000724:
 00001292  84 C0			test	AL,AL
 00001294  74 15			jz	OFFSET $L000722
				;{

				;{209}:Console::WriteLn("Las matrices deben tener las mismas dimensiones para ser sumadas.");
 00001296  8D 05 00000402 R		lea	EAX,OFFSET $S000614
 0000129C  6A 00			push	000000000h
 0000129E  50				push	EAX 
 0000129F  E8 00000000 E		call	 Console_WriteString
 000012A4  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 000012A9  EB 48			jmp	OFFSET $L000723

				; else {
 000012AB			$L000722:
				;{

				;{211}:Console::WriteLn("La matriz resultado:");
 000012AB  8D 05 000003ED R		lea	EAX,OFFSET $S000615
 000012B1  6A 00			push	000000000h
 000012B3  50				push	EAX 
 000012B4  E8 00000000 E		call	 Console_WriteString
 000012B9  E8 00000000 E		call	 Console_WriteCrLf 

				;{212}:Program::SumMatrices(A, B, rA, rB, nOption == 1 ? Program::Sum : Program::Substract);
 000012BE  8B 45 C8			mov	EAX,dword ptr [EBP-0038h]
 000012C1  50				push	EAX
 000012C2  B8 00000001			mov	EAX,000000001h
 000012C7  5A				pop	EDX
 000012C8  3B D0			cmp	EDX,EAX
 000012CA  0F 94 C0			setz	AL
 000012CD  84 C0			test	AL,AL
 000012CF  74 07			jz	 $L000725
 000012D1  B8 00000001			mov	EAX,000000001h
 000012D6  EB 05			jmp	 $L000726
 000012D8			$L000725:
 000012D8  B8 00000002			mov	EAX,000000002h
 000012DD			$L000726:
 000012DD  50				push	EAX 
 000012DE  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 000012E1  50				push	EAX 
 000012E2  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 000012E5  50				push	EAX 
 000012E6  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 000012E9  50				push	EAX 
 000012EA  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 000012ED  50				push	EAX
 000012EE  E8 FFFFF686			call	 Program_SumMatrices
				;}
 000012F3			$L000723:

				; }
				;}
 000012F3  E9 000001F9			jmp	OFFSET $L000718
 000012F8			$L000727:
				;{

				;{218}:if(cA == rB)
 000012F8  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 000012FB  50				push	EAX
 000012FC  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 000012FF  5A				pop	EDX
 00001300  3B D0			cmp	EDX,EAX
 00001302  0F 94 C0			setz	AL
 00001305  84 C0			test	AL,AL
 00001307  74 32			jz	OFFSET $L000728
				;{

				;{220}:Console::WriteLn("La matriz resultado C = A*B es:\n");
 00001309  8D 05 000003AB R		lea	EAX,OFFSET $S000617
 0000130F  6A 00			push	000000000h
 00001311  50				push	EAX 
 00001312  E8 00000000 E		call	 Console_WriteString
 00001317  E8 00000000 E		call	 Console_WriteCrLf 

				;{221}:Program::MultiplyMatrices(A, B, rA, cA, rB, cB);
 0000131C  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 0000131F  50				push	EAX 
 00001320  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 00001323  50				push	EAX 
 00001324  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00001327  50				push	EAX 
 00001328  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 0000132B  50				push	EAX 
 0000132C  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 0000132F  50				push	EAX 
 00001330  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 00001333  50				push	EAX
 00001334  E8 FFFFF409			call	 Program_MultiplyMatrices
				;}
 00001339  EB 13			jmp	OFFSET $L000729

				; else {
 0000133B			$L000728:

				;{223}:Console::WriteLn("El numero de filas de B debe ser igual al numero de columnas de A.");
 0000133B  8D 05 000001BD R		lea	EAX,OFFSET $S000618
 00001341  6A 00			push	000000000h
 00001343  50				push	EAX 
 00001344  E8 00000000 E		call	 Console_WriteString
 00001349  E8 00000000 E		call	 Console_WriteCrLf 
 0000134E			$L000729:

				; }
				;}
 0000134E  E9 0000019E			jmp	OFFSET $L000718
 00001353			$L000730:
				;{

				;{228}:if(cB == rA)
 00001353  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00001356  50				push	EAX
 00001357  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 0000135A  5A				pop	EDX
 0000135B  3B D0			cmp	EDX,EAX
 0000135D  0F 94 C0			setz	AL
 00001360  84 C0			test	AL,AL
 00001362  74 32			jz	OFFSET $L000731
				;{

				;{230}:Console::WriteLn("La matriz resultado C = B*A es:\n");
 00001364  8D 05 000003CC R		lea	EAX,OFFSET $S000620
 0000136A  6A 00			push	000000000h
 0000136C  50				push	EAX 
 0000136D  E8 00000000 E		call	 Console_WriteString
 00001372  E8 00000000 E		call	 Console_WriteCrLf 

				;{231}:Program::MultiplyMatrices(B, A, rB, cB, rA, cA);
 00001377  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 0000137A  50				push	EAX 
 0000137B  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 0000137E  50				push	EAX 
 0000137F  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00001382  50				push	EAX 
 00001383  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 00001386  50				push	EAX 
 00001387  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 0000138A  50				push	EAX 
 0000138B  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 0000138E  50				push	EAX
 0000138F  E8 FFFFF3AE			call	 Program_MultiplyMatrices
				;}
 00001394  EB 13			jmp	OFFSET $L000732

				; else {
 00001396			$L000731:

				;{233}:Console::WriteLn("El numero de filas de A debe ser igual al numero de columnas de B.");
 00001396  8D 05 0000017A R		lea	EAX,OFFSET $S000621
 0000139C  6A 00			push	000000000h
 0000139E  50				push	EAX 
 0000139F  E8 00000000 E		call	 Console_WriteString
 000013A4  E8 00000000 E		call	 Console_WriteCrLf 
 000013A9			$L000732:

				; }
				;}
 000013A9  E9 00000143			jmp	OFFSET $L000718
 000013AE			$L000733:
				;{

				;{237}:Tr= Program::CalcTrace(A, rA, cA);
 000013AE  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 000013B1  50				push	EAX 
 000013B2  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 000013B5  50				push	EAX 
 000013B6  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 000013B9  50				push	EAX
 000013BA  E8 FFFFF26E			call	 Program_CalcTrace
 000013BF  50				push	EAX
 000013C0  52				push	EDX 
 000013C1  DD C0			ffree	st
 000013C3  DD 04 24			fld	qword ptr [ESP]
 000013C6  DD 5D F8			fstp	qword ptr [EBP-0008h]

				;{238}:Console::WriteLn("\nLa Traza de la matriz es = ", Tr);
 000013C9  5A				pop	EDX
 000013CA  58				pop	EAX 
 000013CB  8D 05 000004E1 R		lea	EAX,OFFSET $S000623
 000013D1  6A 00			push	000000000h
 000013D3  50				push	EAX 
 000013D4  E8 00000000 E		call	 Console_WriteString
 000013D9  8B 55 F8			mov	EDX,dword ptr [EBP-0008h]
 000013DC  8B 45 FC			mov	EAX,dword ptr [EBP-0004h] 
 000013DF  50				push	EAX 
 000013E0  52				push	EDX 
 000013E1  E8 00000000 E		call	 Console_WriteDouble 
 000013E6  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 000013EB  E9 00000101			jmp	OFFSET $L000718
 000013F0			$L000734:
				;{

				;{242}:Tr= Program::CalcTrace(B, rB, cB);
 000013F0  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 000013F3  50				push	EAX 
 000013F4  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 000013F7  50				push	EAX 
 000013F8  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 000013FB  50				push	EAX
 000013FC  E8 FFFFF22C			call	 Program_CalcTrace
 00001401  50				push	EAX
 00001402  52				push	EDX 
 00001403  DD C0			ffree	st
 00001405  DD 04 24			fld	qword ptr [ESP]
 00001408  DD 5D F8			fstp	qword ptr [EBP-0008h]

				;{243}:Console::WriteLn("\nLa Traza de la matriz es = ", Tr);
 0000140B  5A				pop	EDX
 0000140C  58				pop	EAX 
 0000140D  8D 05 000004E1 R		lea	EAX,OFFSET $S000623
 00001413  6A 00			push	000000000h
 00001415  50				push	EAX 
 00001416  E8 00000000 E		call	 Console_WriteString
 0000141B  8B 55 F8			mov	EDX,dword ptr [EBP-0008h]
 0000141E  8B 45 FC			mov	EAX,dword ptr [EBP-0004h] 
 00001421  50				push	EAX 
 00001422  52				push	EDX 
 00001423  E8 00000000 E		call	 Console_WriteDouble 
 00001428  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 0000142D  E9 000000BF			jmp	OFFSET $L000718
 00001432			$L000735:
				;{

				;{247}:if(rA == cA)
 00001432  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 00001435  50				push	EAX
 00001436  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00001439  5A				pop	EDX
 0000143A  3B D0			cmp	EDX,EAX
 0000143C  0F 94 C0			setz	AL
 0000143F  84 C0			test	AL,AL
 00001441  74 26			jz	OFFSET $L000736
				;{

				;{249}:Console::WriteLn("La Traspuesta de la matriz es:");
 00001443  8D 05 0000038C R		lea	EAX,OFFSET $S000626
 00001449  6A 00			push	000000000h
 0000144B  50				push	EAX 
 0000144C  E8 00000000 E		call	 Console_WriteString
 00001451  E8 00000000 E		call	 Console_WriteCrLf 

				;{250}:Program::Traspose(A, rA, cA);
 00001456  8B 45 E8			mov	EAX,dword ptr [EBP-0018h]
 00001459  50				push	EAX 
 0000145A  8B 45 EC			mov	EAX,dword ptr [EBP-0014h]
 0000145D  50				push	EAX 
 0000145E  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 00001461  50				push	EAX
 00001462  E8 FFFFF702			call	 Program_Traspose
				;}
 00001467  EB 13			jmp	OFFSET $L000737

				; else {
 00001469			$L000736:

				;{252}:Console::WriteLn("Esta matriz no se puede trasponer ya que no es cuadrada.");
 00001469  8D 05 00000353 R		lea	EAX,OFFSET $S000627
 0000146F  6A 00			push	000000000h
 00001471  50				push	EAX 
 00001472  E8 00000000 E		call	 Console_WriteString
 00001477  E8 00000000 E		call	 Console_WriteCrLf 
 0000147C			$L000737:

				; }
				;}
 0000147C  EB 73			jmp	OFFSET $L000718
 0000147E			$L000738:
				;{

				;{256}:if(rB == cB)
 0000147E  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 00001481  50				push	EAX
 00001482  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 00001485  5A				pop	EDX
 00001486  3B D0			cmp	EDX,EAX
 00001488  0F 94 C0			setz	AL
 0000148B  84 C0			test	AL,AL
 0000148D  74 26			jz	OFFSET $L000739
				;{

				;{258}:Console::WriteLn("La Traspuesta de la matriz es:");
 0000148F  8D 05 0000038C R		lea	EAX,OFFSET $S000626
 00001495  6A 00			push	000000000h
 00001497  50				push	EAX 
 00001498  E8 00000000 E		call	 Console_WriteString
 0000149D  E8 00000000 E		call	 Console_WriteCrLf 

				;{259}:Program::Traspose(B, rB, cB);
 000014A2  8B 45 E0			mov	EAX,dword ptr [EBP-0020h]
 000014A5  50				push	EAX 
 000014A6  8B 45 E4			mov	EAX,dword ptr [EBP-001Ch]
 000014A9  50				push	EAX 
 000014AA  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 000014AD  50				push	EAX
 000014AE  E8 FFFFF6B6			call	 Program_Traspose
				;}
 000014B3  EB 13			jmp	OFFSET $L000740

				; else {
 000014B5			$L000739:

				;{261}:Console::WriteLn("Esta matriz no se puede trasponer ya que no es cuadrada.");
 000014B5  8D 05 00000353 R		lea	EAX,OFFSET $S000627
 000014BB  6A 00			push	000000000h
 000014BD  50				push	EAX 
 000014BE  E8 00000000 E		call	 Console_WriteString
 000014C3  E8 00000000 E		call	 Console_WriteCrLf 
 000014C8			$L000740:

				; }
				;}
 000014C8  EB 27			jmp	OFFSET $L000718
 000014CA			$L000741:
				;{

				;{266}:bReEnterMatrices= true;
 000014CA  B8 00000001			mov	EAX,000000001h
 000014CF  88 45 F0			mov	byte ptr [EBP-0010h],AL
				;}
 000014D2  EB 1D			jmp	OFFSET $L000718
 000014D4			$L000742:
				;{

				;{271}:bExitProgram= true;
 000014D4  B8 00000001			mov	EAX,000000001h
 000014D9  88 45 F4			mov	byte ptr [EBP-000Ch],AL
				;}
 000014DC  EB 13			jmp	OFFSET $L000718
 000014DE			$L000743:
				;{

				;{276}:Console::WriteLn("Entrada desconocida. Favor seleccionar una opcion.");
 000014DE  8D 05 000002BD R		lea	EAX,OFFSET $S000630
 000014E4  6A 00			push	000000000h
 000014E6  50				push	EAX 
 000014E7  E8 00000000 E		call	 Console_WriteString
 000014EC  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 000014F1			$L000718:

				;{280}:if(false == bExitProgram)
 000014F1  33 C0			xor	EAX,EAX
 000014F3  50				push	EAX
 000014F4  0F B6 45 F4			movzx	EAX,byte ptr [EBP-000Ch]
 000014F8  5A				pop	EDX
 000014F9  38 C2			cmp	DL,AL
 000014FB  0F 94 C0			setz	AL
 000014FE  84 C0			test	AL,AL
 00001500  74 1B			jz	OFFSET $L000744
				;{

				;{282}:Console::WriteLn("\n\nPresione una tecla para regresar...");
 00001502  8D 05 0000050B R		lea	EAX,OFFSET $S000631
 00001508  6A 00			push	000000000h
 0000150A  50				push	EAX 
 0000150B  E8 00000000 E		call	 Console_WriteString
 00001510  E8 00000000 E		call	 Console_WriteCrLf 

				;{283}:ch= Console::ReadChar();
 00001515  E8 00000000 E		call	 Console_ReadChar
 0000151A  88 45 C4			mov	byte ptr [EBP-003Ch],AL
				;}
 0000151D			$L000744:
				;}
 0000151D			$L000716:

				;{283}:while(false == bExitProgram && false == bReEnterMatrices)
 0000151D  33 C0			xor	EAX,EAX
 0000151F  50				push	EAX
 00001520  0F B6 45 F4			movzx	EAX,byte ptr [EBP-000Ch]
 00001524  5A				pop	EDX
 00001525  38 C2			cmp	DL,AL
 00001527  0F 94 C0			setz	AL
 0000152A  84 C0			test	AL,AL
 0000152C  74 0D			jz	OFFSET $L000746
 0000152E  33 C0			xor	EAX,EAX
 00001530  50				push	EAX
 00001531  0F B6 45 F0			movzx	EAX,byte ptr [EBP-0010h]
 00001535  5A				pop	EDX
 00001536  38 C2			cmp	DL,AL
 00001538  0F 94 C0			setz	AL
 0000153B			$L000746:
 0000153B  84 C0			test	AL,AL
 0000153D  0F 85 FFFFFC12		jne	OFFSET $L000715
 00001543			$L000717:

				;{288}:destroy []A;
 00001543  8B 45 D8			mov	EAX,dword ptr [EBP-40]
 00001546  85 C0			test	EAX,EAX
 00001548  74 06			jz	OFFSET $L000747
 0000154A  50				push	EAX
 0000154B  E8 00000000 E		call	 System_Memory_Destroy
 00001550			$L000747:

				;{289}:destroy []B;
 00001550  8B 45 D4			mov	EAX,dword ptr [EBP-44]
 00001553  85 C0			test	EAX,EAX
 00001555  74 06			jz	OFFSET $L000748
 00001557  50				push	EAX
 00001558  E8 00000000 E		call	 System_Memory_Destroy
 0000155D			$L000748:

				;{291}:if(bExitProgram)
 0000155D  0F B6 45 F4			movzx	EAX,byte ptr [EBP-000Ch]
 00001561  84 C0			test	AL,AL
 00001563  74 02			jz	OFFSET $L000749

				;break;
 00001565  EB 17			jmp	OFFSET $L000674
 00001567			$L000749:

				;{293}:if(bReEnterMatrices)
 00001567  0F B6 45 F0			movzx	EAX,byte ptr [EBP-0010h]
 0000156B  84 C0			test	AL,AL
 0000156D  74 0A			jz	OFFSET $L000751
				;{

				;{294}:bReEnterMatrices= false;
 0000156F  33 C0			xor	EAX,EAX
 00001571  88 45 F0			mov	byte ptr [EBP-0010h],AL

				;continue;
 00001574  E9 FFFFF709			jmp	OFFSET $L000673
				;}
 00001579			$L000751:
				;}
 00001579  E9 FFFFF704			jmp	OFFSET $L000673
 0000157E			$L000674:
				;}
 0000157E			$L000576:

 0000157E  5F				pop	EDI
 0000157F  5E				pop	ESI 
 00001580  5B				pop	EBX 
 00001581  8B E5			mov	ESP,EBP
 00001583  5D				pop	EBP 
 00001584  C3				ret	
 00001585			Program_main ENDP

 00001585			__System_Hpp_Runtime_Init PROC

 00001585  55				push	EBP
 00001586  8B EC			mov	EBP,ESP
 00001588  51				push	ECX 
 00001589  53				push	EBX 
 0000158A  56				push	ESI 
 0000158B  57				push	EDI 
 0000158C  E8 00000000 E		call	 GetVersion
 00001591  A3 00000559 R		mov	 __osver,EAX ;os version
 00001596  A1 00000559 R		mov	EAX, __osver 
 0000159B  C1 E8 08			shr	EAX,000000008h
 0000159E  25 000000FF			and	EAX,0000000FFh
 000015A3  A3 0000055D R		mov	 __winminor,EAX ;windows minor
 000015A8  8B 0D 00000559 R		mov	ECX, __osver 
 000015AE  81 E1 000000FF		and	ECX,0000000FFh 
 000015B4  89 0D 00000561 R		mov	 __winmajor,ECX ;windows major
 000015BA  8B 15 00000561 R		mov	EDX,dword ptr __winmajor 
 000015C0  C1 E2 08			shl	EDX,000000008h
 000015C3  03 15 0000055D R		add	EDX,dword ptr __winminor
 000015C9  89 15 00000565 R		mov	dword ptr __winver,EDX ;windows version
 000015CF  A1 00000559 R		mov	EAX, __osver 
 000015D4  C1 E8 10			shr	EAX,000000010h 
 000015D7  25 0000FFFF			and	EAX,00000FFFFh 
 000015DC  A3 00000559 R		mov	 __osver,EAX 
 000015E1  E8 FFFFF684			call	 Program_main ;user entry point (stdcall calling convention)
 000015E6  50				push	EAX
 000015E7  E8 00000000 E		call	 System_Exit 

 000015EC  5F				pop	EDI
 000015ED  5E				pop	ESI 
 000015EE  5B				pop	EBX 
 000015EF  8B E5			mov	ESP,EBP
 000015F1  5D				pop	EBP 
 000015F2  C3				ret	
 000015F3			__System_Hpp_Runtime_Init ENDP

 00000000			.DATA ;data segment
 = FFFFFFFF			File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
 = FFFFFFFF			File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

 00000000 20 20 00		$S000531 		BYTE 	"  ",0
 00000003 30 2E 20 4D 6F	$S000611 		BYTE 	"0. Mostrar las Matrices",0Ah,"1. Sumar las matrices.",0Ah,"2. Restar las matrices.",0Ah,"3. Multiplicar las matrices (A*B).",0Ah,"4. Multiplicar las matrices (B*A).",0Ah,"5. Calcular la traza de A",0Ah,"6. Calcular la traza de B.",0Ah,"7. Trasponer matriz A.",0Ah,"8. Trasponer matriz B.",0Ah,"9. Re-Entrar Matrices",0Ah,"10. Salir",0Ah,0Ah,0
	   73 74 72 61 72
	   20 6C 61 73 20
	   4D 61 74 72 69
	   63 65 73 0A 31
	   2E 20 53 75 6D
	   61 72 20 6C 61
	   73 20 6D 61 74
	   72 69 63 65 73
	   2E 0A 32 2E 20
	   52 65 73 74 61
	   72 20 6C 61 73
	   20 6D 61 74 72
	   69 63 65 73 2E
	   0A 33 2E 20 4D
	   75 6C 74 69 70
	   6C 69 63 61 72
	   20 6C 61 73 20
	   6D 61 74 72 69
	   63 65 73 20 28
	   41 2A 42 29 2E
	   0A 34 2E 20 4D
	   75 6C 74 69 70
	   6C 69 63 61 72
	   20 6C 61 73 20
	   6D 61 74 72 69
	   63 65 73 20 28
	   42 2A 41 29 2E
	   0A 35 2E 20 43
	   61 6C 63 75 6C
	   61 72 20 6C 61
	   20 74 72 61 7A
	   61 20 64 65 20
	   41 0A 36 2E 20
	   43 61 6C 63 75
	   6C 61 72 20 6C
	   61 20 74 72 61
	   7A 61 20 64 65
	   20 42 2E 0A 37
	   2E 20 54 72 61
	   73 70 6F 6E 65
	   72 20 6D 61 74
	   72 69 7A 20 41
	   2E 0A 38 2E 20
	   54 72 61 73 70
	   6F 6E 65 72 20
	   6D 61 74 72 69
	   7A 20 42 2E 0A
	   39 2E 20 52 65
	   2D 45 6E 74 72
	   61 72 20 4D 61
	   74 72 69 63 65
	   73 0A 31 30 2E
	   20 53 61 6C 69
	   72 0A 0A 00
 00000115 3E 3A 00		$S000612 		BYTE 	">:",0
 00000118 45 6C 20 6E 75	$S000596 		BYTE 	"El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?",0
	   6D 65 72 6F 20
	   64 65 20 63 6F
	   6C 75 6D 6E 61
	   73 20 64 65 62
	   65 20 65 73 74
	   61 72 20 65 6E
	   20 30 20 3C 20
	   63 20 3C 20 31
	   30 20 70 61 72
	   61 20 61 6D 62
	   61 73 20 6D 61
	   74 72 69 63 65
	   73 2E 20 44 65
	   73 65 61 20 65
	   6D 70 65 7A 61
	   72 20 64 65 20
	   6E 75 65 76 6F
	   20 28 59 2F 4E
	   29 3F 00
 0000017A 45 6C 20 6E 75	$S000621 		BYTE 	"El numero de filas de A debe ser igual al numero de columnas de B.",0
	   6D 65 72 6F 20
	   64 65 20 66 69
	   6C 61 73 20 64
	   65 20 41 20 64
	   65 62 65 20 73
	   65 72 20 69 67
	   75 61 6C 20 61
	   6C 20 6E 75 6D
	   65 72 6F 20 64
	   65 20 63 6F 6C
	   75 6D 6E 61 73
	   20 64 65 20 42
	   2E 00
 000001BD 45 6C 20 6E 75	$S000618 		BYTE 	"El numero de filas de B debe ser igual al numero de columnas de A.",0
	   6D 65 72 6F 20
	   64 65 20 66 69
	   6C 61 73 20 64
	   65 20 42 20 64
	   65 62 65 20 73
	   65 72 20 69 67
	   75 61 6C 20 61
	   6C 20 6E 75 6D
	   65 72 6F 20 64
	   65 20 63 6F 6C
	   75 6D 6E 61 73
	   20 64 65 20 41
	   2E 00
 00000200 45 6C 20 6E 75	$S000575 		BYTE 	"El numero de filas de B debe ser igual al numero de filas de A.",0
	   6D 65 72 6F 20
	   64 65 20 66 69
	   6C 61 73 20 64
	   65 20 42 20 64
	   65 62 65 20 73
	   65 72 20 69 67
	   75 61 6C 20 61
	   6C 20 6E 75 6D
	   65 72 6F 20 64
	   65 20 66 69 6C
	   61 73 20 64 65
	   20 41 2E 00
 00000240 45 6C 20 6E 75	$S000592 		BYTE 	"El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?",0
	   6D 65 72 6F 20
	   64 65 20 66 69
	   6C 61 73 20 64
	   65 62 65 20 65
	   73 74 61 72 20
	   65 6E 20 30 20
	   3C 20 72 20 3C
	   20 31 30 20 70
	   61 72 61 20 61
	   6D 62 61 73 20
	   6D 61 74 72 69
	   63 65 73 2E 20
	   44 65 73 65 61
	   20 65 6D 70 65
	   7A 61 72 20 64
	   65 20 6E 75 65
	   76 6F 20 28 59
	   2F 4E 29 3F 00
 0000029F 45 6C 65 6D 65	$S000604 		BYTE 	"Elemento en A[",0
	   6E 74 6F 20 65
	   6E 20 41 5B 00
 000002AE 45 6C 65 6D 65	$S000607 		BYTE 	"Elemento en B[",0
	   6E 74 6F 20 65
	   6E 20 42 5B 00
 000002BD 45 6E 74 72 61	$S000630 		BYTE 	"Entrada desconocida. Favor seleccionar una opcion.",0
	   64 61 20 64 65
	   73 63 6F 6E 6F
	   63 69 64 61 2E
	   20 46 61 76 6F
	   72 20 73 65 6C
	   65 63 63 69 6F
	   6E 61 72 20 75
	   6E 61 20 6F 70
	   63 69 6F 6E 2E
	   00
 000002F0 45 6E 74 72 65	$S000581 		BYTE 	"Entre las dimensiones de dos matrices:",0Ah,0
	   20 6C 61 73 20
	   64 69 6D 65 6E
	   73 69 6F 6E 65
	   73 20 64 65 20
	   64 6F 73 20 6D
	   61 74 72 69 63
	   65 73 3A 0A 00
 00000318 45 6E 74 72 65	$S000582 		BYTE 	"Entre las filas de A: ",0
	   20 6C 61 73 20
	   66 69 6C 61 73
	   20 64 65 20 41
	   3A 20 00
 0000032F 45 6E 74 72 65	$S000599 		BYTE 	"Entre los valores para la matriz A[",0
	   20 6C 6F 73 20
	   76 61 6C 6F 72
	   65 73 20 70 61
	   72 61 20 6C 61
	   20 6D 61 74 72
	   69 7A 20 41 5B
	   00
 00000353 45 73 74 61 20	$S000627 		BYTE 	"Esta matriz no se puede trasponer ya que no es cuadrada.",0
	   6D 61 74 72 69
	   7A 20 6E 6F 20
	   73 65 20 70 75
	   65 64 65 20 74
	   72 61 73 70 6F
	   6E 65 72 20 79
	   61 20 71 75 65
	   20 6E 6F 20 65
	   73 20 63 75 61
	   64 72 61 64 61
	   2E 00
 0000038C 4C 61 20 54 72	$S000626 		BYTE 	"La Traspuesta de la matriz es:",0
	   61 73 70 75 65
	   73 74 61 20 64
	   65 20 6C 61 20
	   6D 61 74 72 69
	   7A 20 65 73 3A
	   00
 000003AB 4C 61 20 6D 61	$S000617 		BYTE 	"La matriz resultado C = A*B es:",0Ah,0
	   74 72 69 7A 20
	   72 65 73 75 6C
	   74 61 64 6F 20
	   43 20 3D 20 41
	   2A 42 20 65 73
	   3A 0A 00
 000003CC 4C 61 20 6D 61	$S000620 		BYTE 	"La matriz resultado C = B*A es:",0Ah,0
	   74 72 69 7A 20
	   72 65 73 75 6C
	   74 61 64 6F 20
	   43 20 3D 20 42
	   2A 41 20 65 73
	   3A 0A 00
 000003ED 4C 61 20 6D 61	$S000615 		BYTE 	"La matriz resultado:",0
	   74 72 69 7A 20
	   72 65 73 75 6C
	   74 61 64 6F 3A
	   00
 00000402 4C 61 73 20 6D	$S000614 		BYTE 	"Las matrices deben tener las mismas dimensiones para ser sumadas.",0
	   61 74 72 69 63
	   65 73 20 64 65
	   62 65 6E 20 74
	   65 6E 65 72 20
	   6C 61 73 20 6D
	   69 73 6D 61 73
	   20 64 69 6D 65
	   6E 73 69 6F 6E
	   65 73 20 70 61
	   72 61 20 73 65
	   72 20 73 75 6D
	   61 64 61 73 2E
	   00
 00000444 4D 5B 00		$S000541 		BYTE 	"M[",0
 00000447 4D 61 74 72 69	$S000608 		BYTE 	"Matriz A:",0Ah,0
	   7A 20 41 3A 0A
	   00
 00000452 50 72 6F 67 72	$S000580 		BYTE 	"Programa de Matrices",0Ah,0Ah,0
	   61 6D 61 20 64
	   65 20 4D 61 74
	   72 69 63 65 73
	   0A 0A 00
 00000469 52 65 73 5B 00	$S000574 		BYTE 	"Res[",0
 0000046E 0A 45 6E 74 72	$S000584 		BYTE 	0Ah,"Entre las columnas de A: ",0
	   65 20 6C 61 73
	   20 63 6F 6C 75
	   6D 6E 61 73 20
	   64 65 20 41 3A
	   20 00
 00000489 0A 45 6E 74 72	$S000588 		BYTE 	0Ah,"Entre las columnas de B: ",0
	   65 20 6C 61 73
	   20 63 6F 6C 75
	   6D 6E 61 73 20
	   64 65 20 42 3A
	   20 00
 000004A4 0A 45 6E 74 72	$S000586 		BYTE 	0Ah,"Entre las filas de B: ",0
	   65 20 6C 61 73
	   20 66 69 6C 61
	   73 20 64 65 20
	   42 3A 20 00
 000004BC 0A 45 6E 74 72	$S000606 		BYTE 	0Ah,"Entre los valores para la matriz B[",0
	   65 20 6C 6F 73
	   20 76 61 6C 6F
	   72 65 73 20 70
	   61 72 61 20 6C
	   61 20 6D 61 74
	   72 69 7A 20 42
	   5B 00
 000004E1 0A 4C 61 20 54	$S000623 		BYTE 	0Ah,"La Traza de la matriz es = ",0
	   72 61 7A 61 20
	   64 65 20 6C 61
	   20 6D 61 74 72
	   69 7A 20 65 73
	   20 3D 20 00
 000004FE 0A 0A 4D 61 74	$S000609 		BYTE 	0Ah,0Ah,"Matriz B:",0Ah,0
	   72 69 7A 20 42
	   3A 0A 00
 0000050B 0A 0A 50 72 65	$S000631 		BYTE 	0Ah,0Ah,"Presione una tecla para regresar...",0
	   73 69 6F 6E 65
	   20 75 6E 61 20
	   74 65 63 6C 61
	   20 70 61 72 61
	   20 72 65 67 72
	   65 73 61 72 2E
	   2E 2E 00
 00000531 0A 0A 51 75 65	$S000610 		BYTE 	0Ah,0Ah,"Que deseas hacer?",0Ah,0
	   20 64 65 73 65
	   61 73 20 68 61
	   63 65 72 3F 0A
	   00
 00000546 0A 7C 20 00		$S000529 		BYTE 	0Ah,"| ",0
 0000054A 5D 20 3D 20 00	$S000605 		BYTE 	"] = ",0
 0000054F 5D 3D 20 00		$S000543 		BYTE 	"]= ",0
 00000553 5D 5B 00		$S000600 		BYTE 	"][",0
 00000556 7C 20 00		$S000532 		BYTE 	"| ",0

 00000559 00000000		__osver 		DWORD 	0;Windows OS version
 0000055D 00000000		__winminor 		DWORD 	0;Windows minor version
 00000561 00000000		__winmajor 		DWORD 	0;Windows major version
 00000565 00000000		__winver 		DWORD 	0;Windows version
 00000569  00000020 [		__computer 		BYTE 	000000020h DUP(?);Computer name
	    00
	   ]
 00000589 00000000		___argv 		DWORD 	0;Array of argument values
 0000058D 00000000		___argc 		DWORD 	0;Argument count

				END __System_Hpp_Runtime_Init

Microsoft (R) Macro Assembler Version 6.15.8803		    11/24/11 23:49:49
TestMatrices2.hpp					     Symbols 2 - 1
This file was automatically generated by the 32-bit H++ Comp



Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPos  . . . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  maxWinSize . . . . . . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00100000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000591 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000015F3 Para	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ClearScreen  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_GetTitle . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_MoveWindow . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ReadChar . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ReadDouble . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ReadInteger  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ReadString . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_SetConsoleSize . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_SetCursorPos . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_SetTextColor . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_SetTitle . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteBoolean . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteChar  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteCrlf  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteDouble  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteInteger64 . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteInteger . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteString  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Close . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_FileSize  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Open  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Read  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Seek  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Write . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_CompareToInteger .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_Compare  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_FromInt64  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_FromInt  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_ToInt64  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_ToInt  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_fromString . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_toStringEx . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_toString . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVersion . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Integer_fromString . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Integer_toStringEx . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Integer_toString . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Abs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_ArcTan  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_ChangeSign  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Cosec . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Cos . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Cotan . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_DegreesToRadians  . . . . .	P Near	 00000000 _TEXT	Length= 0000004C Public STDCALL
  $L000469 . . . . . . . . . . .	L Near	 00000043 _TEXT	
Math_Even  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Exp . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Gcd . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_GetNumberFrom . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Hyperbolic_HCosec . . . . .	P Near	 000000AC _TEXT	Length= 00000062 Public STDCALL
  $L000492 . . . . . . . . . . .	L Near	 00000105 _TEXT	
Math_Hyperbolic_HCos . . . . . .	P Near	 0000004C _TEXT	Length= 00000060 Public STDCALL
  $L000486 . . . . . . . . . . .	L Near	 000000A3 _TEXT	
Math_Hyperbolic_HCotan . . . . .	P Near	 0000010E _TEXT	Length= 00000086 Public STDCALL
  $L000494 . . . . . . . . . . .	L Near	 0000018B _TEXT	
Math_Hyperbolic_HSec . . . . . .	P Near	 00000194 _TEXT	Length= 00000060 Public STDCALL
  $L000490 . . . . . . . . . . .	L Near	 000001EB _TEXT	
Math_Hyperbolic_HSin . . . . . .	P Near	 000001F4 _TEXT	Length= 00000062 Public STDCALL
  $L000483 . . . . . . . . . . .	L Near	 0000024D _TEXT	
Math_Hyperbolic_HTan . . . . . .	P Near	 00000256 _TEXT	Length= 00000086 Public STDCALL
  $L000488 . . . . . . . . . . .	L Near	 000002D3 _TEXT	
Math_Hyperbolic_Inverse_HArccosec 	P Near	 00000345 _TEXT	Length= 0000009F Public STDCALL
  $L000506 . . . . . . . . . . .	L Near	 000003DB _TEXT	
Math_Hyperbolic_Inverse_HArccos 	P Near	 000002DC _TEXT	Length= 00000069 Public STDCALL
  $L000500 . . . . . . . . . . .	L Near	 0000033C _TEXT	
Math_Hyperbolic_Inverse_HArccotan 	P Near	 000003E4 _TEXT	Length= 00000086 Public STDCALL
  $L000508 . . . . . . . . . . .	L Near	 00000461 _TEXT	
Math_Hyperbolic_Inverse_HArcsec 	P Near	 0000046A _TEXT	Length= 0000008A Public STDCALL
  $L000504 . . . . . . . . . . .	L Near	 000004EB _TEXT	
Math_Hyperbolic_Inverse_HArcsin 	P Near	 000004F4 _TEXT	Length= 00000067 Public STDCALL
  $L000497 . . . . . . . . . . .	L Near	 00000552 _TEXT	
Math_Hyperbolic_Inverse_HArctan 	P Near	 0000055B _TEXT	Length= 00000086 Public STDCALL
  $L000502 . . . . . . . . . . .	L Near	 000005D8 _TEXT	
Math_IEEEModulus . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Init  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arccosec  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arccos  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arccotan  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arcsec  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arcsin  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Ln  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_LogN_base . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_MantissaOf  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Max . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Min . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_ModulusTruncateDivisor  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Modulus . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Odd . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Pow2  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Pow . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_RadiansToDegrees  . . . . .	P Near	 000005E1 _TEXT	Length= 0000004C Public STDCALL
  $L000466 . . . . . . . . . . .	L Near	 00000624 _TEXT	
Math_Round . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sign  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sqrt  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sqr . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Tan . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Trunc . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log10 . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log2  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log_10_base2  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log_2_base10  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log_2_base_e  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log_e_base2 . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_pi  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Program_CalcTrace  . . . . . . .	P Near	 0000062D _TEXT	Length= 00000115 Public STDCALL
  $L000634 . . . . . . . . . . .	L Near	 00000655 _TEXT	
  $L000633 . . . . . . . . . . .	L Near	 0000065B _TEXT	
  $L000635 . . . . . . . . . . .	L Near	 00000731 _TEXT	
  $L000533 . . . . . . . . . . .	L Near	 00000739 _TEXT	
Program_MultiplyMatrices . . . .	P Near	 00000742 _TEXT	Length= 0000017B Public STDCALL
  $L000636 . . . . . . . . . . .	L Near	 0000076A _TEXT	
  $L000637 . . . . . . . . . . .	L Near	 0000076C _TEXT	
  $L000641 . . . . . . . . . . .	L Near	 0000078B _TEXT	
  $L000640 . . . . . . . . . . .	L Near	 00000791 _TEXT	
  $L000644 . . . . . . . . . . .	L Near	 000007AD _TEXT	
  $L000643 . . . . . . . . . . .	L Near	 000007B3 _TEXT	
  $L000645 . . . . . . . . . . .	L Near	 00000875 _TEXT	
  $L000642 . . . . . . . . . . .	L Near	 0000087A _TEXT	
  $L000638 . . . . . . . . . . .	L Near	 0000088D _TEXT	
  $L000639 . . . . . . . . . . .	L Near	 000008A0 _TEXT	
  $L000646 . . . . . . . . . . .	L Near	 000008AD _TEXT	
  $L000564 . . . . . . . . . . .	L Near	 000008B4 _TEXT	
Program_ShowMatrixForm . . . . .	P Near	 000008BD _TEXT	Length= 000000BC Public STDCALL
  $L000648 . . . . . . . . . . .	L Near	 000008CD _TEXT	
  $L000647 . . . . . . . . . . .	L Near	 000008D3 _TEXT	
  $L000651 . . . . . . . . . . .	L Near	 000008FD _TEXT	
  $L000650 . . . . . . . . . . .	L Near	 00000903 _TEXT	
  $L000652 . . . . . . . . . . .	L Near	 0000095D _TEXT	
  $L000649 . . . . . . . . . . .	L Near	 00000970 _TEXT	
  $L000523 . . . . . . . . . . .	L Near	 00000970 _TEXT	
Program_SumMatrices  . . . . . .	P Near	 00000979 _TEXT	Length= 000001F0 Public STDCALL
  $L000653 . . . . . . . . . . .	L Near	 000009A1 _TEXT	
  $L000654 . . . . . . . . . . .	L Near	 000009A3 _TEXT	
  $L000656 . . . . . . . . . . .	L Near	 000009B2 _TEXT	
  $L000655 . . . . . . . . . . .	L Near	 000009B8 _TEXT	
  $L000659 . . . . . . . . . . .	L Near	 000009D4 _TEXT	
  $L000658 . . . . . . . . . . .	L Near	 000009DA _TEXT	
  $L000661 . . . . . . . . . . .	L Near	 00000A7F _TEXT	
  $L000662 . . . . . . . . . . .	L Near	 00000AFC _TEXT	
  $L000660 . . . . . . . . . . .	L Near	 00000B36 _TEXT	
  $L000657 . . . . . . . . . . .	L Near	 00000B3B _TEXT	
  $L000663 . . . . . . . . . . .	L Near	 00000B59 _TEXT	
  $L000554 . . . . . . . . . . .	L Near	 00000B60 _TEXT	
Program_Traspose . . . . . . . .	P Near	 00000B69 _TEXT	Length= 00000101 Public STDCALL
  $L000664 . . . . . . . . . . .	L Near	 00000B91 _TEXT	
  $L000665 . . . . . . . . . . .	L Near	 00000B93 _TEXT	
  $L000667 . . . . . . . . . . .	L Near	 00000B9D _TEXT	
  $L000666 . . . . . . . . . . .	L Near	 00000BA3 _TEXT	
  $L000670 . . . . . . . . . . .	L Near	 00000BBF _TEXT	
  $L000669 . . . . . . . . . . .	L Near	 00000BC5 _TEXT	
  $L000671 . . . . . . . . . . .	L Near	 00000C37 _TEXT	
  $L000668 . . . . . . . . . . .	L Near	 00000C3C _TEXT	
  $L000672 . . . . . . . . . . .	L Near	 00000C5A _TEXT	
  $L000544 . . . . . . . . . . .	L Near	 00000C61 _TEXT	
Program_main . . . . . . . . . .	P Near	 00000C6A _TEXT	Length= 0000091B Public STDCALL
  $L000673 . . . . . . . . . . .	L Near	 00000C82 _TEXT	
  $L000677 . . . . . . . . . . .	L Near	 00000D3B _TEXT	
  $L000680 . . . . . . . . . . .	L Near	 00000D7E _TEXT	
  $L000678 . . . . . . . . . . .	L Near	 00000D87 _TEXT	
  $L000675 . . . . . . . . . . .	L Near	 00000D8C _TEXT	
  $L000683 . . . . . . . . . . .	L Near	 00000DAE _TEXT	
  $L000686 . . . . . . . . . . .	L Near	 00000DF1 _TEXT	
  $L000684 . . . . . . . . . . .	L Near	 00000DFA _TEXT	
  $L000681 . . . . . . . . . . .	L Near	 00000DFF _TEXT	
  $L000689 . . . . . . . . . . .	L Near	 00000E1B _TEXT	
  $L000692 . . . . . . . . . . .	L Near	 00000E5E _TEXT	
  $L000690 . . . . . . . . . . .	L Near	 00000E67 _TEXT	
  $L000687 . . . . . . . . . . .	L Near	 00000E6C _TEXT	
  $L000695 . . . . . . . . . . .	L Near	 00000E8E _TEXT	
  $L000698 . . . . . . . . . . .	L Near	 00000ED1 _TEXT	
  $L000696 . . . . . . . . . . .	L Near	 00000EDA _TEXT	
  $L000693 . . . . . . . . . . .	L Near	 00000EDF _TEXT	
  $L000699 . . . . . . . . . . .	L Near	 00000EFE _TEXT	
  $L000700 . . . . . . . . . . .	L Near	 00000F00 _TEXT	
  $L000701 . . . . . . . . . . .	L Near	 00000F22 _TEXT	
  $L000702 . . . . . . . . . . .	L Near	 00000F24 _TEXT	
  $L000704 . . . . . . . . . . .	L Near	 00000F6C _TEXT	
  $L000703 . . . . . . . . . . .	L Near	 00000F72 _TEXT	
  $L000707 . . . . . . . . . . .	L Near	 00000F8E _TEXT	
  $L000706 . . . . . . . . . . .	L Near	 00000F94 _TEXT	
  $L000708 . . . . . . . . . . .	L Near	 00001015 _TEXT	
  $L000705 . . . . . . . . . . .	L Near	 0000101A _TEXT	
  $L000710 . . . . . . . . . . .	L Near	 0000105F _TEXT	
  $L000709 . . . . . . . . . . .	L Near	 00001065 _TEXT	
  $L000713 . . . . . . . . . . .	L Near	 00001081 _TEXT	
  $L000712 . . . . . . . . . . .	L Near	 00001087 _TEXT	
  $L000714 . . . . . . . . . . .	L Near	 00001108 _TEXT	
  $L000711 . . . . . . . . . . .	L Near	 0000110D _TEXT	
  $L000715 . . . . . . . . . . .	L Near	 00001155 _TEXT	
  $L000719 . . . . . . . . . . .	L Near	 00001227 _TEXT	
  $L000720 . . . . . . . . . . .	L Near	 00001274 _TEXT	
  $L000721 . . . . . . . . . . .	L Near	 00001274 _TEXT	
  $L000724 . . . . . . . . . . .	L Near	 00001292 _TEXT	
  $L000722 . . . . . . . . . . .	L Near	 000012AB _TEXT	
  $L000725 . . . . . . . . . . .	L Near	 000012D8 _TEXT	
  $L000726 . . . . . . . . . . .	L Near	 000012DD _TEXT	
  $L000723 . . . . . . . . . . .	L Near	 000012F3 _TEXT	
  $L000727 . . . . . . . . . . .	L Near	 000012F8 _TEXT	
  $L000728 . . . . . . . . . . .	L Near	 0000133B _TEXT	
  $L000729 . . . . . . . . . . .	L Near	 0000134E _TEXT	
  $L000730 . . . . . . . . . . .	L Near	 00001353 _TEXT	
  $L000731 . . . . . . . . . . .	L Near	 00001396 _TEXT	
  $L000732 . . . . . . . . . . .	L Near	 000013A9 _TEXT	
  $L000733 . . . . . . . . . . .	L Near	 000013AE _TEXT	
  $L000734 . . . . . . . . . . .	L Near	 000013F0 _TEXT	
  $L000735 . . . . . . . . . . .	L Near	 00001432 _TEXT	
  $L000736 . . . . . . . . . . .	L Near	 00001469 _TEXT	
  $L000737 . . . . . . . . . . .	L Near	 0000147C _TEXT	
  $L000738 . . . . . . . . . . .	L Near	 0000147E _TEXT	
  $L000739 . . . . . . . . . . .	L Near	 000014B5 _TEXT	
  $L000740 . . . . . . . . . . .	L Near	 000014C8 _TEXT	
  $L000741 . . . . . . . . . . .	L Near	 000014CA _TEXT	
  $L000742 . . . . . . . . . . .	L Near	 000014D4 _TEXT	
  $L000743 . . . . . . . . . . .	L Near	 000014DE _TEXT	
  $L000718 . . . . . . . . . . .	L Near	 000014F1 _TEXT	
  $L000744 . . . . . . . . . . .	L Near	 0000151D _TEXT	
  $L000716 . . . . . . . . . . .	L Near	 0000151D _TEXT	
  $L000746 . . . . . . . . . . .	L Near	 0000153B _TEXT	
  $L000717 . . . . . . . . . . .	L Near	 00001543 _TEXT	
  $L000747 . . . . . . . . . . .	L Near	 00001550 _TEXT	
  $L000748 . . . . . . . . . . .	L Near	 0000155D _TEXT	
  $L000749 . . . . . . . . . . .	L Near	 00001567 _TEXT	
  $L000751 . . . . . . . . . . .	L Near	 00001579 _TEXT	
  $L000674 . . . . . . . . . . .	L Near	 0000157E _TEXT	
  $L000576 . . . . . . . . . . .	L Near	 0000157E _TEXT	
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringCompare . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringCopy  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringLCase . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringLength2 . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringLength  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringSet . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringUCase . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_BreakPoint  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_CommandLineArgs . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Debug_OutputString  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Execute . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Exit  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_GetCommandLineArgv  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_GetTickCount  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_IsDebuggerPresent . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_LastError . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Alloc  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Destroy  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Free . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_GetProcessHeap . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Memset . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_New  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_SizeFor  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Size . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_ShowMessage . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Sleep . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
__System_Hpp_Runtime_Init  . . .	P Near	 00001585 _TEXT	Length= 0000006E Public STDCALL
__purecall . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

$S000529 . . . . . . . . . . . .	Byte	 00000546 _DATA	
$S000531 . . . . . . . . . . . .	Byte	 00000000 _DATA	
$S000532 . . . . . . . . . . . .	Byte	 00000556 _DATA	
$S000541 . . . . . . . . . . . .	Byte	 00000444 _DATA	
$S000543 . . . . . . . . . . . .	Byte	 0000054F _DATA	
$S000574 . . . . . . . . . . . .	Byte	 00000469 _DATA	
$S000575 . . . . . . . . . . . .	Byte	 00000200 _DATA	
$S000580 . . . . . . . . . . . .	Byte	 00000452 _DATA	
$S000581 . . . . . . . . . . . .	Byte	 000002F0 _DATA	
$S000582 . . . . . . . . . . . .	Byte	 00000318 _DATA	
$S000584 . . . . . . . . . . . .	Byte	 0000046E _DATA	
$S000586 . . . . . . . . . . . .	Byte	 000004A4 _DATA	
$S000588 . . . . . . . . . . . .	Byte	 00000489 _DATA	
$S000592 . . . . . . . . . . . .	Byte	 00000240 _DATA	
$S000596 . . . . . . . . . . . .	Byte	 00000118 _DATA	
$S000599 . . . . . . . . . . . .	Byte	 0000032F _DATA	
$S000600 . . . . . . . . . . . .	Byte	 00000553 _DATA	
$S000604 . . . . . . . . . . . .	Byte	 0000029F _DATA	
$S000605 . . . . . . . . . . . .	Byte	 0000054A _DATA	
$S000606 . . . . . . . . . . . .	Byte	 000004BC _DATA	
$S000607 . . . . . . . . . . . .	Byte	 000002AE _DATA	
$S000608 . . . . . . . . . . . .	Byte	 00000447 _DATA	
$S000609 . . . . . . . . . . . .	Byte	 000004FE _DATA	
$S000610 . . . . . . . . . . . .	Byte	 00000531 _DATA	
$S000611 . . . . . . . . . . . .	Byte	 00000003 _DATA	
$S000612 . . . . . . . . . . . .	Byte	 00000115 _DATA	
$S000614 . . . . . . . . . . . .	Byte	 00000402 _DATA	
$S000615 . . . . . . . . . . . .	Byte	 000003ED _DATA	
$S000617 . . . . . . . . . . . .	Byte	 000003AB _DATA	
$S000618 . . . . . . . . . . . .	Byte	 000001BD _DATA	
$S000620 . . . . . . . . . . . .	Byte	 000003CC _DATA	
$S000621 . . . . . . . . . . . .	Byte	 0000017A _DATA	
$S000623 . . . . . . . . . . . .	Byte	 000004E1 _DATA	
$S000626 . . . . . . . . . . . .	Byte	 0000038C _DATA	
$S000627 . . . . . . . . . . . .	Byte	 00000353 _DATA	
$S000630 . . . . . . . . . . . .	Byte	 000002BD _DATA	
$S000631 . . . . . . . . . . . .	Byte	 0000050B _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
ConsoleHandle  . . . . . . . . .	DWord	 00000000 FLAT	External STDCALL
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
File_INVALID_HANDLE_VALUE  . . .	Number	 FFFFFFFFh   
File_INVALID_SET_FILE_POINTER  .	Number	 FFFFFFFFh   
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
___argc  . . . . . . . . . . . .	DWord	 0000058D _DATA	
___argv  . . . . . . . . . . . .	DWord	 00000589 _DATA	
__computer . . . . . . . . . . .	Byte	 00000569 _DATA	
__osver  . . . . . . . . . . . .	DWord	 00000559 _DATA	
__winmajor . . . . . . . . . . .	DWord	 00000561 _DATA	
__winminor . . . . . . . . . . .	DWord	 0000055D _DATA	
__winver . . . . . . . . . . . .	DWord	 00000565 _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0

	   0 Warnings
	   0 Errors
