TITLE	 TestSorting.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE stdhpp\hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Algorithms_Sorting_BinaryInsertionSort_Sort PROC NEAR 
;void Sort(double double [] array, unsigned size);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000020h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0020h],ECX
;{

;{333}:for(i= 1; i < size; ++i)
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000932
$L000933:
	inc	dword ptr [EBP-4]
	mov	EAX,dword ptr [EBP-4]
$L000932:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000934
;{

;{335}:tmp= array[i];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]

;{336}:_F= 0;
	pop	EDX
	pop	EAX 
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX

;{337}:_L= i;
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP-0014h],EAX

;{338}:while(_F < _L)
$L000935:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000936
;{

;{340}:_M= (_F + _L) div 2;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0018h],EAX

;{341}:if(tmp >= array[_M])
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0018h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L000937

;{342}:_F= _M + 1;
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000938

; else {
$L000937:

;{344}:_L= _M;
	mov	EAX,dword ptr [EBP-0018h]
	mov	dword ptr [EBP-0014h],EAX
$L000938:

; }
;}
	jmp	OFFSET $L000935
$L000936:

;{346}:for(j= i; j > _F; --j)
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP-001Ch],EAX
	jmp	OFFSET $L000939
$L000940:
	dec	dword ptr [EBP-28]
	mov	EAX,dword ptr [EBP-28]
$L000939:
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L000941

;{347}:SwapValues(array[j - 1], array[j]);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0020h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	jmp	OFFSET $L000940 
$L000941:
;}
	jmp	OFFSET $L000933 
$L000934:
;}
$L000627:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_BinaryInsertionSort_Sort ENDP

Algorithms_Sorting_BinaryInsertionSort PROC NEAR 
;void Algorithms::Sorting::BinaryInsertionSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Sorter ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_BinaryInsertionSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_BinaryInsertionSort ENDP

Algorithms_Sorting_BubbleSort_Sort PROC NEAR 
;void Sort(double double [] array, unsigned size);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
;{

;{68}:for(i= (size - 1); i >= 0; i-- )
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000943
$L000944:
	mov	EAX,dword ptr [EBP-4]
	dec	dword ptr [EBP-4]
$L000943:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L000945
;{

;{70}:for(j= 1; j <= i; j++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L000946
$L000947:
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]
$L000946:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000948
;{

;{72}:if(array[j] < array[j - 1])
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000949
;{

;{79}:Swap(array, j - 1, j);
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-000Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
;}
$L000949:
;}
	jmp	OFFSET $L000947 
$L000948:
;}
	jmp	OFFSET $L000944 
$L000945:
;}
$L000550:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_BubbleSort_Sort ENDP

Algorithms_Sorting_BubbleSort PROC NEAR 
;void Algorithms::Sorting::BubbleSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Sorter ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_BubbleSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_BubbleSort ENDP

Algorithms_Sorting_HeapSort_Sort PROC NEAR 
;void Sort(double double [] array, unsigned size);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{311}:for(i= (size div 2) - 1; i >= 0; i-- )
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000952
$L000953:
	mov	EAX,dword ptr [EBP-4]
	dec	dword ptr [EBP-4]
$L000952:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L000954

;{312}:siftDown(array, i, size);
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_HeapSort_siftDown
	jmp	OFFSET $L000953 
$L000954:

;{314}:for(i= size - 1; i >= 1; i-- )
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000955
$L000956:
	mov	EAX,dword ptr [EBP-4]
	dec	dword ptr [EBP-4]
$L000955:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L000957
;{

;{322}:SwapValues(array[0], array[i]);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	xor	EAX,EAX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]

;{324}:siftDown(array, 0, i - 1);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	xor	EAX,EAX
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_HeapSort_siftDown
;}
	jmp	OFFSET $L000956 
$L000957:
;}
$L000621:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_HeapSort_Sort ENDP

Algorithms_Sorting_HeapSort_siftDown PROC NEAR 
;void siftDown(double double [] array, Algorithms::Sorting::__uint _Root, Algorithms::Sorting::__uint _Bottom);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{281}:maxChild= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{283}:while(_Root * 2 <= _Bottom)
$L000958:
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000959
;{

;{285}:if(_Root * 2 == _Bottom)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000960

;{286}:maxChild= _Root * 2;
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000961

; else {
$L000960:

;{287}:if(array[_Root * 2] > array[_Root * 2 + 1])
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L000962

;{288}:maxChild= _Root * 2;
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000963

; else {
$L000962:

;{290}:maxChild= _Root * 2 + 1;
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
$L000963:

; }
$L000961:

; }

;{292}:if(array[_Root] < array[maxChild])
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000964
;{

;{300}:Swap(array, _Root, maxChild);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]

;{301}:_Root= maxChild;
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP+000Ch],EAX

;continue;
	jmp	OFFSET $L000958
;}
$L000964:

;break;
	jmp	OFFSET $L000959
;}
	jmp	OFFSET $L000958
$L000959:
;}
$L000616:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_HeapSort_siftDown ENDP

Algorithms_Sorting_HeapSort PROC NEAR 
;void Algorithms::Sorting::HeapSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Sorter ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_HeapSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_HeapSort ENDP

Algorithms_Sorting_InsertionSort_Sort PROC NEAR 
;void Sort(double double [] array, unsigned size);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
;{

;{96}:for(i= 1; i < size; i++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000967
$L000968:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L000967:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000969
;{

;{98}:dIndex= array[i];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-000Ch]

;{99}:j= i;
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP-0010h],EAX

;{100}:while(j > 0 && array[j - 1] > dIndex)
$L000970:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L000972
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setg	AL
$L000972:
	test	AL,AL
	jz	OFFSET $L000971
;{

;{102}:array[j]= array[j - 1];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{103}:j-- ;
	mov	EAX,dword ptr [EBP-16]
	dec	dword ptr [EBP-16]
;}
	jmp	OFFSET $L000970
$L000971:

;{105}:array[j]= dIndex;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [EBP-0008h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L000968 
$L000969:
;}
$L000557:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_InsertionSort_Sort ENDP

Algorithms_Sorting_InsertionSort PROC NEAR 
;void Algorithms::Sorting::InsertionSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Sorter ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_InsertionSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_InsertionSort ENDP

Algorithms_Sorting_MergeSort_Sort PROC NEAR 
;void Sort(double double [] array, unsigned size);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{265}:temp= new double[size];
	mov	EAX,dword ptr [EBP+000Ch]
	imul	EAX,000000008h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000974
	mov	ESI,EAX 
	jmp	 $L000975
$L000974:
	xor	ESI,ESI
$L000975:
	mov	dword ptr [EBP-0004h],ESI 

;{266}:mergeSort(array, temp, 0, size - 1);
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	xor	EAX,EAX
	push	EAX 
	mov	EAX,dword ptr [EBP-4]
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_MergeSort_mergeSort

;{267}:destroy []temp;
	mov	EAX,dword ptr [EBP-4]
	test	EAX,EAX
	jz	OFFSET $L000976
	push	EAX
	call	 System_Memory_Destroy
$L000976:
;}
$L000610:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_MergeSort_Sort ENDP

Algorithms_Sorting_MergeSort_doMerge PROC NEAR 
;void doMerge(double double [] array, double double [] temp, Algorithms::Sorting::__uint _F, Algorithms::Sorting::__uint _M, Algorithms::Sorting::__uint _L);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
;{

;{216}:_F_End= _M - 1, tmp_pos= _F, item_count= _L - _F + 1;
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
	mov	EAX,dword ptr [EBP+0010h]
	mov	dword ptr [EBP-0008h],EAX
	mov	EAX,dword ptr [EBP+0018h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	pop	EDX 
	add	EAX,EDX
	mov	dword ptr [EBP-000Ch],EAX

;{220}:while(_F <= _F_End && _M <= _L)
$L000977:
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000979
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX
	mov	EAX,dword ptr [EBP+0018h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
$L000979:
	test	AL,AL
	jz	OFFSET $L000978
;{

;{222}:if(array[_F] <= array[_M])
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000980
;{

;{223}:temp[tmp_pos]= array[_F];
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{224}:tmp_pos++ ;
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]

;{225}:_F++ ;
	mov	EAX,dword ptr [EBP+16]
	inc	dword ptr [EBP+16]
;}
	jmp	OFFSET $L000981

; else {
$L000980:
;{

;{227}:temp[tmp_pos]= array[_M];
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{228}:tmp_pos++ ;
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]

;{229}:_M++ ;
	mov	EAX,dword ptr [EBP+20]
	inc	dword ptr [EBP+20]
;}
$L000981:

; }
;}
	jmp	OFFSET $L000977
$L000978:

;{232}:while(_F <= _F_End)
$L000982:
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000983
;{

;{233}:temp[tmp_pos]= array[_F];
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{234}:tmp_pos++ ;
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]

;{235}:_F++ ;
	mov	EAX,dword ptr [EBP+16]
	inc	dword ptr [EBP+16]
;}
	jmp	OFFSET $L000982
$L000983:

;{237}:while(_M <= _L)
$L000984:
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX
	mov	EAX,dword ptr [EBP+0018h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000985
;{

;{238}:temp[tmp_pos]= array[_M];
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{239}:tmp_pos++ ;
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]

;{240}:_M++ ;
	mov	EAX,dword ptr [EBP+20]
	inc	dword ptr [EBP+20]
;}
	jmp	OFFSET $L000984
$L000985:

;{243}:for(index= 0; index < item_count; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000986
$L000987:
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
$L000986:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000988
;{

;{245}:array[_L]= temp[_L];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0018h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0018h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{246}:_L-- ;
	mov	EAX,dword ptr [EBP+24]
	dec	dword ptr [EBP+24]
;}
	jmp	OFFSET $L000987 
$L000988:
;}
$L000594:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000014h
Algorithms_Sorting_MergeSort_doMerge ENDP

Algorithms_Sorting_MergeSort_mergeSort PROC NEAR 
;void mergeSort(double double [] array, double double [] temp, Algorithms::Sorting::__uint _F, Algorithms::Sorting::__uint _L);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{252}:if(_L > _F)
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L000989
;{

;{254}:_M= (_L + _F) div 2;
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0004h],EAX

;{255}:mergeSort(array, temp, _F, _M);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_MergeSort_mergeSort

;{256}:mergeSort(array, temp, _M + 1, _L);
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_MergeSort_mergeSort

;{258}:doMerge(array, temp, _F, _M + 1, _L);
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX 
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_MergeSort_doMerge
;}
$L000989:

;{260}:return 
	jmp	OFFSET $L000604
;}
$L000604:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000010h
Algorithms_Sorting_MergeSort_mergeSort ENDP

Algorithms_Sorting_MergeSort PROC NEAR 
;void Algorithms::Sorting::MergeSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Sorter ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_MergeSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_MergeSort ENDP

Algorithms_Sorting_Proxy_Array_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{380}:if(array != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L000992
;{

;{382}:destroy []array;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	test	EAX,EAX
	jz	OFFSET $L000994
	mov	ESI,EAX
	mov	ECX,dword ptr [ESI-0004h]
	lea	EDI,dword ptr [ESI+ECX]
	mov	EBX,ESI 
$L000995:
	mov	ECX,EBX 
	test	ECX,ECX
	jz	OFFSET $L000996
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0004h]
$L000996:
	add	EBX,000000012h
	cmp	EBX,EDI
	jnz	OFFSET $L000995

	add	ESI,0FFFFFFFCh
	push	ESI
	call	 System_Memory_Destroy
$L000994:

;{383}:array= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX
;}
$L000992:
;}
$L000663:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Array_Destructor ENDP

Algorithms_Sorting_Proxy_Array_get_item_size PROC NEAR 
;unsigned get::item_size(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{370}:return _item_size
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	jmp	OFFSET $L000648
;}
$L000648:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Array_get_item_size ENDP

Algorithms_Sorting_Proxy_Array_get_length PROC NEAR 
;unsigned get::length(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{368}:return _length
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	jmp	OFFSET $L000646
;}
$L000646:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Array_get_length ENDP

Algorithms_Sorting_Proxy_Array PROC NEAR 
;void Algorithms::Sorting::Proxy::Array(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+000Ch],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_Array 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@Algorithms_Sorting_Proxy_Array

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Array ENDP

Algorithms_Sorting_Proxy_ArrayOfAutomobile PROC NEAR 
;void Algorithms::Sorting::Proxy::ArrayOfAutomobile(Algorithms::Sorting::__uint len);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_Array ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+000Ch],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_ArrayOfAutomobile 
;{

;{438}:_item_size= sizeof (Algorithms::Sorting::Proxy::Automobile);
	mov	EAX,000000012h
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0008h],EAX

;{439}:array= new Algorithms::Sorting::Proxy::Automobile[_length= len];
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],EAX
	imul	EAX,000000012h
	lea	EBX,dword ptr [EAX+4]
	push	EBX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000998
	mov	ESI,EAX 
	mov	dword ptr [ESI],EBX 
	add	ESI,000000004h
	jmp	 $L000999
$L000998:
	xor	ESI,ESI
$L000999:
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],ESI 
	mov	ECX,dword ptr [ESI-0004h] 
	lea	EDI,dword ptr [ESI+ECX] 
	mov	EBX,ESI 
$L001000:
	mov	ECX,EBX 
	call	 Algorithms_Sorting_Proxy_Automobile
	add	EBX,000000012h 
	cmp	EBX,EDI
	jnz	OFFSET $L001000
	mov	EAX,ESI 
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_ArrayOfAutomobile ENDP

Algorithms_Sorting_Proxy_ArrayOfAutomobile_CopyFrom PROC NEAR 
;void CopyFrom(Algorithms::Sorting::Proxy::Array ref fromArray, Algorithms::Sorting::__uint from, Algorithms::Sorting::__uint to);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
;{

;{483}:fromObject= fromArray.getAt(from);
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{484}:fromAuto= dynamic_cast(fromObject);
	mov	EAX,dword ptr [EBP-4]
	lea	EBX,dword ptr [EBP-0008h]
	mov	dword ptr [EBX],EAX

;{486}:array[to].Cost= fromAuto.Cost;
	mov	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	ECX,dword ptr [EBP-8]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Cost
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	ECX
	push	EAX
	push	EDX 
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{487}:array[to].Year= fromAuto.Year;
	mov	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	ECX,dword ptr [EBP-8]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Year
	pop	ECX
	push	EAX
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{488}:array[to].Model= fromAuto.Model;
	mov	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	ECX,dword ptr [EBP-8]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Model
	pop	ECX
	push	EAX
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model
;}
$L000707:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_Proxy_ArrayOfAutomobile_CopyFrom ENDP

Algorithms_Sorting_Proxy_ArrayOfAutomobile_CopyTo PROC NEAR 
;void CopyTo(Algorithms::Sorting::Proxy::Array ref toArray, Algorithms::Sorting::__uint to, Algorithms::Sorting::__uint from);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
;{

;{474}:toObject= toArray.getAt(to);
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{475}:toAuto= dynamic_cast(toObject);
	mov	EAX,dword ptr [EBP-4]
	lea	EBX,dword ptr [EBP-0008h]
	mov	dword ptr [EBX],EAX

;{477}:toAuto.Cost= array[from].Cost;
	mov	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Cost
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-8]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{478}:toAuto.Year= array[from].Year;
	mov	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Year
	push	EAX
	mov	ECX,dword ptr [EBP-8]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{479}:toAuto.Model= array[from].Model;
	mov	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Model
	push	EAX
	mov	ECX,dword ptr [EBP-8]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model
;}
$L000701:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_Proxy_ArrayOfAutomobile_CopyTo ENDP

Algorithms_Sorting_Proxy_ArrayOfAutomobile_Swap PROC NEAR 
;void Swap(Algorithms::Sorting::__uint left, Algorithms::Sorting::__uint right);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
;{

;{449}:cost= array[left].Cost;
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Cost
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{450}:year= array[left].Year;
	pop	EDX
	pop	EAX 
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Year
	mov	word ptr [EBP-000Ch],AX

;{451}:model= array[left].Model;
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Model
	mov	dword ptr [EBP-0010h],EAX

;{453}:array[left].Cost= array[right].Cost;
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Cost
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	ECX
	push	EAX
	push	EDX 
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{454}:array[left].Year= array[right].Year;
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Year
	pop	ECX
	push	EAX
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{455}:array[left].Model= array[right].Model;
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Model
	pop	ECX
	push	EAX
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{458}:array[right].Cost= cost;
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	ECX
	push	EAX
	push	EDX 
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{459}:array[right].Year= year;
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	movsx	EAX,word ptr [EBP-000Ch]
	pop	ECX
	push	EAX
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{460}:array[right].Model= model;
	mov	ECX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	EAX,dword ptr [EBP-0010h]
	pop	ECX
	push	EAX
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model
;}
$L000693:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_Proxy_ArrayOfAutomobile_Swap ENDP

Algorithms_Sorting_Proxy_ArrayOfAutomobile_getAt PROC NEAR 
;Algorithms::Sorting::Proxy::ProxyObject getAt(Algorithms::Sorting::__uint pos);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{466}:if(pos > _length)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001001

;{467}:return null
	xor	EAX,EAX
	jmp	OFFSET $L000699
$L001001:

;{469}:return &array[pos]
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,000000012h
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,ECX
	jmp	OFFSET $L000699
;}
$L000699:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_ArrayOfAutomobile_getAt ENDP

Algorithms_Sorting_Proxy_Automobile PROC NEAR 
;void Algorithms::Sorting::Proxy::Automobile(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_ProxyObject ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_Automobile 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@Algorithms_Sorting_Proxy_Automobile 
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Automobile ENDP

Algorithms_Sorting_Proxy_Automobile_Compare PROC NEAR 
;int Compare(Algorithms::Sorting::Proxy::ProxyObject ^ obj);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{413}:pobj= dynamic_cast(obj);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{415}:if(_year < pobj._year && _cost <= pobj._cost)
	mov	ECX,dword ptr [EBP-0008h]
	movzx	EAX,word ptr [ECX+0010h]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	movzx	EAX,word ptr [ECX+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001005
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setle	AL
$L001005:
	test	AL,AL
	jz	OFFSET $L001003

;{416}:return -1
	mov	EAX,000000001h
	neg	EAX
	jmp	OFFSET $L000684

; else {
$L001003:

;{417}:if(_year > pobj._year && _cost >= pobj._cost)
	mov	ECX,dword ptr [EBP-0008h]
	movzx	EAX,word ptr [ECX+0010h]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	movzx	EAX,word ptr [ECX+0010h]
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001008
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setge	AL
$L001008:
	test	AL,AL
	jz	OFFSET $L001006

;{418}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L000684
$L001006:
$L001004:

; }

;{420}:if(_cost < pobj._cost)
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001009

;{421}:return -1
	mov	EAX,000000001h
	neg	EAX
	jmp	OFFSET $L000684

; else {
$L001009:

;{422}:if(_cost > pobj._cost)
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001011

;{423}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L000684
$L001011:
$L001010:

; }

;{425}:return 0
	xor	EAX,EAX
	jmp	OFFSET $L000684
;}
$L000684:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_Automobile_Compare ENDP

Algorithms_Sorting_Proxy_Automobile_get_Cost PROC NEAR 
;double get::Cost(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{395}:return _cost
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000672
;}
$L000672:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Automobile_get_Cost ENDP

Algorithms_Sorting_Proxy_Automobile_put_Cost PROC NEAR 
;void put::Cost(double val);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{397}:_cost= val;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]
;}
$L000673:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_Proxy_Automobile_put_Cost ENDP

Algorithms_Sorting_Proxy_Automobile_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{430}:Console::WriteLn("Destroying an auto...");
	lea	EAX,OFFSET $S000688
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000687:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Automobile_Destructor ENDP

Algorithms_Sorting_Proxy_Automobile_get_Model PROC NEAR 
;string get::Model(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{400}:return _model
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+000Ch]
	jmp	OFFSET $L000676
;}
$L000676:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Automobile_get_Model ENDP

Algorithms_Sorting_Proxy_Automobile_put_Model PROC NEAR 
;void put::Model(string model);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{402}:_model= model;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+000Ch],EAX
;}
$L000677:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_Automobile_put_Model ENDP

Algorithms_Sorting_Proxy_Automobile_get_Year PROC NEAR 
;unsigned short get::Year(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{405}:return _year
	mov	ECX,dword ptr [EBP-0004h]
	movzx	EAX,word ptr [ECX+0010h]
	jmp	OFFSET $L000680
;}
$L000680:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_Automobile_get_Year ENDP

Algorithms_Sorting_Proxy_Automobile_put_Year PROC NEAR 
;void put::Year(unsigned short year);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{407}:_year= year;
	movzx	EAX,word ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	mov	word ptr [ECX+0010h],AX
;}
$L000681:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_Automobile_put_Year ENDP

Algorithms_Sorting_Proxy_BinaryInsertionSortEx_Sort PROC NEAR 
;void Sort(Algorithms::Sorting::Proxy::Array ref array);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000020h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0020h],ECX
;{

;{530}:_array= &array;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0020h]
	mov	dword ptr [ECX],EAX

;{531}:n= array.length;
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	mov	dword ptr [EBP-0004h],EAX

;{532}:for(i= 1; i < n; ++i)
	mov	EAX,000000001h
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001013
$L001014:
	inc	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001013:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001015
;{

;{534}:tmp= array.getAt(i);
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-000Ch]
	mov	dword ptr [EBX],EAX

;{535}:_F= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX

;{536}:_L= i;
	mov	EAX,dword ptr [EBP-0008h]
	mov	dword ptr [EBP-0014h],EAX

;{537}:while(_F < _L)
$L001016:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001017
;{

;{539}:_M= (_F + _L) div 2;
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0018h],EAX

;{540}:if(tmp.Compare(array.getAt(_M)) >= 0)
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [EBP-12]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001018

;{541}:_F= _M + 1;
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L001019

; else {
$L001018:

;{543}:_L= _M;
	mov	EAX,dword ptr [EBP-0018h]
	mov	dword ptr [EBP-0014h],EAX
$L001019:

; }
;}
	jmp	OFFSET $L001016
$L001017:

;{545}:for(j= i; j > _F; --j)
	mov	EAX,dword ptr [EBP-0008h]
	mov	dword ptr [EBP-001Ch],EAX
	jmp	OFFSET $L001020
$L001021:
	dec	dword ptr [EBP-28]
	mov	EAX,dword ptr [EBP-28]
$L001020:
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001022

;{546}:Swap(j - 1, j);
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-0020h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
	jmp	OFFSET $L001021 
$L001022:
;}
	jmp	OFFSET $L001014 
$L001015:
;}
$L000730:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_BinaryInsertionSortEx_Sort ENDP

Algorithms_Sorting_Proxy_BinaryInsertionSortEx PROC NEAR 
;void Algorithms::Sorting::Proxy::BinaryInsertionSortEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_SorterEx ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_BinaryInsertionSortEx 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_BinaryInsertionSortEx ENDP

Algorithms_Sorting_Proxy_BubbleSortEx_Sort PROC NEAR 
;void Sort(Algorithms::Sorting::Proxy::Array ref array);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{556}:_array= &array;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0010h]
	mov	dword ptr [ECX],EAX

;{557}:n= array.length;
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	mov	dword ptr [EBP-0004h],EAX

;{558}:for(i= n; i > 1; --i)
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001024
$L001025:
	dec	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001024:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001026

;{559}:for(j= 0; j < i - 1; ++j)
	xor	EAX,EAX
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L001027
$L001028:
	inc	dword ptr [EBP-12]
	mov	EAX,dword ptr [EBP-12]
$L001027:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001029

;{560}:if(array.getAt(j).Compare(array.getAt(j + 1)) > 0)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001030

;{561}:Swap(j, j + 1);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX 
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
$L001030:
	jmp	OFFSET $L001028 
$L001029:
	jmp	OFFSET $L001025 
$L001026:
;}
$L000741:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_BubbleSortEx_Sort ENDP

Algorithms_Sorting_Proxy_BubbleSortEx PROC NEAR 
;void Algorithms::Sorting::Proxy::BubbleSortEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_SorterEx ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_BubbleSortEx 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_BubbleSortEx ENDP

Algorithms_Sorting_Proxy_HeapSortEx_Sort PROC NEAR 
;void Sort(Algorithms::Sorting::Proxy::Array ref array);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{666}:_array= &array;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0008h]
	mov	dword ptr [ECX],EAX

;{668}:for(i= (array.length div 2) - 1; i >= 0; i-- )
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001033
$L001034:
	mov	EAX,dword ptr [EBP-4]
	dec	dword ptr [EBP-4]
$L001033:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001035

;{669}:siftDown(array, i, array.length);
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_HeapSortEx_siftDown
	jmp	OFFSET $L001034 
$L001035:

;{671}:for(i= array.length - 1; i >= 1; i-- )
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001036
$L001037:
	mov	EAX,dword ptr [EBP-4]
	dec	dword ptr [EBP-4]
$L001036:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001038
;{

;{674}:Swap(0, i);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	xor	EAX,EAX
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]

;{675}:siftDown(array, 0, i - 1);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	xor	EAX,EAX
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_HeapSortEx_siftDown
;}
	jmp	OFFSET $L001037 
$L001038:
;}
$L000785:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_HeapSortEx_Sort ENDP

Algorithms_Sorting_Proxy_HeapSortEx_siftDown PROC NEAR 
;void siftDown(Algorithms::Sorting::Proxy::Array ref array, Algorithms::Sorting::__uint _Root, Algorithms::Sorting::__uint _Bottom);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{641}:maxChild= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{643}:while(_Root * 2 <= _Bottom)
$L001039:
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001040
;{

;{645}:if(_Root * 2 == _Bottom)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001041

;{646}:maxChild= _Root * 2;
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001042

; else {
$L001041:

;{647}:if(array.getAt(_Root * 2).Compare(array.getAt(_Root * 2 + 1)) > 0)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001043

;{648}:maxChild= _Root * 2;
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001044

; else {
$L001043:

;{650}:maxChild= _Root * 2 + 1;
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000002h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
$L001044:

; }
$L001042:

; }

;{652}:if(array.getAt(_Root).Compare(array.getAt(maxChild)) < 0)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001045
;{

;{655}:Swap(_Root, maxChild);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]

;{656}:_Root= maxChild;
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP+000Ch],EAX

;continue;
	jmp	OFFSET $L001039
;}
$L001045:

;break;
	jmp	OFFSET $L001040
;}
	jmp	OFFSET $L001039
$L001040:
;}
$L000780:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_Proxy_HeapSortEx_siftDown ENDP

Algorithms_Sorting_Proxy_HeapSortEx PROC NEAR 
;void Algorithms::Sorting::Proxy::HeapSortEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_SorterEx ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_HeapSortEx 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_HeapSortEx ENDP

Algorithms_Sorting_Proxy_InsertionSortEx_Sort PROC NEAR 
;void Sort(Algorithms::Sorting::Proxy::Array ref array);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{510}:_array= &array;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0010h]
	mov	dword ptr [ECX],EAX

;{511}:n= array.length;
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	mov	dword ptr [EBP-0004h],EAX

;{513}:for(i= 1; i < n; ++i)
	mov	EAX,000000001h
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001048
$L001049:
	inc	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001048:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001050

;{514}:for(j= i; j > 0; --j)
	mov	EAX,dword ptr [EBP-0008h]
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L001051
$L001052:
	dec	dword ptr [EBP-12]
	mov	EAX,dword ptr [EBP-12]
$L001051:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001053
;{

;{516}:if(array.getAt(j - 1).Compare(array.getAt(j)) > 0)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001054

;{517}:Swap(j, j - 1);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
$L001054:
;}
	jmp	OFFSET $L001052 
$L001053:
	jmp	OFFSET $L001049 
$L001050:
;}
$L000723:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_InsertionSortEx_Sort ENDP

Algorithms_Sorting_Proxy_InsertionSortEx PROC NEAR 
;void Algorithms::Sorting::Proxy::InsertionSortEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_SorterEx ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_InsertionSortEx 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_InsertionSortEx ENDP

Algorithms_Sorting_Proxy_MedianOfThreeQuickSort_selectPivot PROC NEAR 
;unsigned selectPivot(Algorithms::Sorting::Proxy::Array ref array, Algorithms::Sorting::__uint _F, Algorithms::Sorting::__uint _L);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{608}:_M= (_F + _L) div 2;
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0004h],EAX

;{609}:if(array.getAt(_F).Compare(array.getAt(_M)) > 0)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001057

;{610}:Swap(_F, _M);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
$L001057:

;{611}:if(array.getAt(_M).Compare(array.getAt(_L)) > 0)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001059

;{612}:Swap(_M, _L);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
$L001059:

;{613}:if(array.getAt(_F).Compare(array.getAt(_L)) > 0)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001061

;{614}:Swap(_F, _L);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
$L001061:

;{615}:return _M
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000766
;}
$L000766:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_Proxy_MedianOfThreeQuickSort_selectPivot ENDP

Algorithms_Sorting_Proxy_MedianOfThreeQuickSort PROC NEAR 
;void Algorithms::Sorting::Proxy::MedianOfThreeQuickSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_QuickSortEx ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_MedianOfThreeQuickSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_MedianOfThreeQuickSort ENDP

Algorithms_Sorting_Proxy_ProxyObject PROC NEAR 
;void Algorithms::Sorting::Proxy::ProxyObject(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_ProxyObject 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_ProxyObject ENDP

Algorithms_Sorting_Proxy_QuickSortEx_Sort PROC NEAR 
;void Sort(Algorithms::Sorting::Proxy::Array ref array);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
;{

;{597}:_array= &array;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-000Ch]
	mov	dword ptr [ECX],EAX

;{598}:doSort(array, 0, array.length - 1);
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	xor	EAX,EAX
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-000Ch]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+000Ch]

;{599}:sorter;
	lea	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_InsertionSortEx

;{600}:sorter.Sort(array);
	push	dword ptr [EBP+0008h]
	lea	ECX,dword ptr [EBP-0008h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX]
;}
$L000761:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_QuickSortEx_Sort ENDP

Algorithms_Sorting_Proxy_QuickSortEx_doSort PROC NEAR 
;void doSort(Algorithms::Sorting::Proxy::Array ref array, Algorithms::Sorting::__uint _F, Algorithms::Sorting::__uint _L);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
;{

;{572}:if(_L - _F + 1 > Algorithms::Sorting::Proxy::QuickSortEx::cutOff)
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	pop	EDX 
	add	EAX,EDX
	push	EAX
	lea	EBX,OFFSET Algorithms_Sorting_Proxy_QuickSortEx_cutOff
	mov	EAX,dword ptr [EBX]
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001066
;{

;{574}:_Piv= selectPivot(array, _F, _L);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0014h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0008h]
	mov	dword ptr [EBP-0004h],EAX

;{575}:Swap(_Piv, _L);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	ECX,dword ptr [EBP-0014h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]

;{576}:_Piv= _L;
	mov	EAX,dword ptr [EBP+0010h]
	mov	dword ptr [EBP-0004h],EAX

;{577}:pivot= array.getAt(_Piv);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0008h]
	mov	dword ptr [EBX],EAX

;{578}:i= _F;
	mov	EAX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBP-000Ch],EAX

;{579}:j= _L - 1;
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0010h],EAX

;{580}:for(; ; )
	jmp	OFFSET $L001068
$L001069:
$L001068:
;{

;{582}:while(i < j && array.getAt(i).Compare(pivot) < 0)
$L001071:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001073
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-8]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
$L001073:
	test	AL,AL
	jz	OFFSET $L001072

;{582}:++i;
	inc	dword ptr [EBP-12]
	mov	EAX,dword ptr [EBP-12]
	jmp	OFFSET $L001071
$L001072:

;{583}:while(i < j && array.getAt(i).Compare(pivot) > 0)
$L001074:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001076
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-8]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
$L001076:
	test	AL,AL
	jz	OFFSET $L001075

;{583}:--j;
	dec	dword ptr [EBP-16]
	mov	EAX,dword ptr [EBP-16]
	jmp	OFFSET $L001074
$L001075:

;{584}:if(i >= j)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001077

;break;
	jmp	OFFSET $L001070
$L001077:

;{585}:Swap(i++ , j-- );
	mov	EAX,dword ptr [EBP-16]
	dec	dword ptr [EBP-16]
	push	EAX 
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
	push	EAX
	mov	ECX,dword ptr [EBP-0014h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
;}
	jmp	OFFSET $L001069 
$L001070:

;{587}:if(array.getAt(i).Compare(pivot) > 0)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-8]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001079

;{588}:Swap(i, _Piv);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP-0014h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
$L001079:

;{589}:if(_F < i)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001081

;{590}:doSort(array, _F, i - 1);
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0014h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+000Ch]
$L001081:

;{591}:if(_L > i)
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001083

;{592}:doSort(array, i + 1, _L);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0014h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+000Ch]
$L001083:
;}
$L001066:
;}
$L000753:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_Proxy_QuickSortEx_doSort ENDP

Algorithms_Sorting_Proxy_QuickSortEx PROC NEAR 
;void Algorithms::Sorting::Proxy::QuickSortEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_SorterEx ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_QuickSortEx 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@Algorithms_Sorting_Proxy_QuickSortEx 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_QuickSortEx ENDP

Algorithms_Sorting_Proxy_SelectionSortEx_Sort PROC NEAR 
;void Sort(Algorithms::Sorting::Proxy::Array ref array);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{624}:_array= &array;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0010h]
	mov	dword ptr [ECX],EAX

;{625}:for(i= array.length; i > 1; --i)
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001086
$L001087:
	dec	dword ptr [EBP-4]
	mov	EAX,dword ptr [EBP-4]
$L001086:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001088
;{

;{627}:max= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX

;{628}:for(j= 1; j < i; ++j)
	mov	EAX,000000001h
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L001089
$L001090:
	inc	dword ptr [EBP-12]
	mov	EAX,dword ptr [EBP-12]
$L001089:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001091

;{629}:if(array.getAt(j).Compare(array.getAt(max)) > 0)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001092

;{630}:max= j;
	mov	EAX,dword ptr [EBP-000Ch]
	mov	dword ptr [EBP-0008h],EAX
$L001092:
	jmp	OFFSET $L001090 
$L001091:

;{631}:Swap(i - 1, max);
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX+0004h]
;}
	jmp	OFFSET $L001087 
$L001088:
;}
$L000773:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_SelectionSortEx_Sort ENDP

Algorithms_Sorting_Proxy_SelectionSortEx PROC NEAR 
;void Algorithms::Sorting::Proxy::SelectionSortEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_SorterEx ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_SelectionSortEx 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_SelectionSortEx ENDP

Algorithms_Sorting_Proxy_SorterEx_Swap PROC NEAR 
;void Swap(Algorithms::Sorting::__uint left, Algorithms::Sorting::__uint right);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{499}:if(_array != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	ECX
	xor	EAX,EAX
	pop	EBX
	cmp	EBX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001095

;{500}:_array.Swap(left, right);
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX]
$L001095:
;}
$L000718:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_Proxy_SorterEx_Swap ENDP

Algorithms_Sorting_Proxy_SorterEx PROC NEAR 
;void Algorithms::Sorting::Proxy::SorterEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_SorterEx 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@Algorithms_Sorting_Proxy_SorterEx

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_SorterEx ENDP

Algorithms_Sorting_Proxy_TwoWayMergeSort_Merge PROC NEAR 
;void Merge(Algorithms::Sorting::Proxy::Array ref array, Algorithms::Sorting::__uint _F, Algorithms::Sorting::__uint _M, Algorithms::Sorting::__uint _L);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{686}:i= _F;
	mov	EAX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBP-0004h],EAX

;{687}:j= _F;
	mov	EAX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBP-0008h],EAX

;{688}:k= _M + 1;
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-000Ch],EAX

;{689}:while(j <= _M && k <= _L)
$L001098:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001100
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
$L001100:
	test	AL,AL
	jz	OFFSET $L001099
;{

;{691}:if(array.getAt(j).Compare(array.getAt(k)) <= 0)
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	mov	ECX,EAX
	push	ECX
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	push	EAX
	mov	ECX,dword ptr [ESP+0004h]
	mov	EDX,dword ptr [ECX] 
	call	dword ptr [EDX]
	pop	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001101

;{692}:array.CopyTo(tmpArray, i++ , j++ );
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]
	push	EAX 
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	push	dword ptr [ECX+0008h]
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0008h]
	jmp	OFFSET $L001102

; else {
$L001101:

;{694}:array.CopyTo(tmpArray, i++ , k++ );
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
	push	EAX 
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	push	dword ptr [ECX+0008h]
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0008h]
$L001102:

; }
;}
	jmp	OFFSET $L001098
$L001099:

;{696}:while(j <= _M)
$L001103:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001104

;{697}:array.CopyTo(tmpArray, i++ , j++ );
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]
	push	EAX 
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	push	dword ptr [ECX+0008h]
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0008h]
	jmp	OFFSET $L001103
$L001104:

;{698}:while(k <= _L)
$L001105:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001106

;{699}:array.CopyTo(tmpArray, i++ , k++ );
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
	push	EAX 
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	push	dword ptr [ECX+0008h]
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0008h]
	jmp	OFFSET $L001105
$L001106:

;{700}:for(i= _F; i <= _L; ++i)
	mov	EAX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001107
$L001108:
	inc	dword ptr [EBP-4]
	mov	EAX,dword ptr [EBP-4]
$L001107:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001109

;{701}:array.CopyFrom(tmpArray, i, i);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	push	dword ptr [ECX+0008h]
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+000Ch]
	jmp	OFFSET $L001108 
$L001109:
;}
$L000791:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000010h
Algorithms_Sorting_Proxy_TwoWayMergeSort_Merge ENDP

Algorithms_Sorting_Proxy_TwoWayMergeSort_Sort PROC NEAR 
;void Sort(Algorithms::Sorting::Proxy::Array ref array);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{717}:tmpArray= new Algorithms::Sorting::Proxy::ArrayOfAutomobile(array.length);
	push	000000010h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001110
	mov	ESI,EAX
	jmp	 $L001111
$L001110:
	xor	ESI,ESI
$L001111:
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0008h],ESI 
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	push	EAX
	mov	ECX,ESI
	call	 Algorithms_Sorting_Proxy_ArrayOfAutomobile
	mov	EAX,ESI 

;{719}:doSort(array, 0, array.length - 1);
	mov	ECX,dword ptr [EBP+0008h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	xor	EAX,EAX
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_TwoWayMergeSort_doSort

;{720}:destroy tmpArray;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	ECX,EAX 
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001113
	mov	EAX,dword ptr [ECX+000Ch] 
	call	dword ptr [EAX+0010h]
$L001113:
	push	ESI
	call	 System_Memory_Destroy

;{721}:tmpArray= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0008h],EAX
;}
$L000804:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Algorithms_Sorting_Proxy_TwoWayMergeSort_Sort ENDP

Algorithms_Sorting_Proxy_TwoWayMergeSort_doSort PROC NEAR 
;void doSort(Algorithms::Sorting::Proxy::Array ref array, Algorithms::Sorting::__uint _F, Algorithms::Sorting::__uint _L);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
;{

;{706}:if(_F < _L)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001114
;{

;{708}:_M= (_F + _L) div 2;
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0004h],EAX

;{709}:doSort(array, _F, _M);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_TwoWayMergeSort_doSort

;{710}:doSort(array, _M + 1, _L);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_TwoWayMergeSort_doSort

;{711}:Merge(array, _F, _M, _L);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_TwoWayMergeSort_Merge
;}
$L001114:
;}
$L000799:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_Proxy_TwoWayMergeSort_doSort ENDP

Algorithms_Sorting_Proxy_TwoWayMergeSort PROC NEAR 
;void Algorithms::Sorting::Proxy::TwoWayMergeSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Proxy_SorterEx ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0004h],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_TwoWayMergeSort 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@Algorithms_Sorting_Proxy_TwoWayMergeSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Proxy_TwoWayMergeSort ENDP

Algorithms_Sorting_QuickSort_Partition PROC NEAR 
;void Partition(double double [] array, Algorithms::Sorting::__uint ref _F, Algorithms::Sorting::__uint ref _L, double dPivot, bool bPartitionRight);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{153}:if(bPartitionRight)
	movzx	EAX,byte ptr [EBP+001Ch]
	test	AL,AL
	jz	OFFSET $L001117
;{

;{155}:while(array[_L] >= dPivot && (_F < _L))
$L001119:
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0014h]
	mov	EAX,dword ptr [EBP+0018h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001121
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
$L001121:
	test	AL,AL
	jz	OFFSET $L001120

;{156}:_L-- ;
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	dec	dword ptr [EBX]
	jmp	OFFSET $L001119
$L001120:
;}
	jmp	OFFSET $L001118

; else {
$L001117:
;{

;{158}:while(array[_F] <= dPivot && _F < _L)
$L001122:
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0014h]
	mov	EAX,dword ptr [EBP+0018h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001124
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
$L001124:
	test	AL,AL
	jz	OFFSET $L001123

;{159}:_F++ ;
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	inc	dword ptr [EBX]
	jmp	OFFSET $L001122
$L001123:
;}
$L001118:

; }

;{162}:if(_F != _L)
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001125
;{

;{164}:if(bPartitionRight)
	movzx	EAX,byte ptr [EBP+001Ch]
	test	AL,AL
	jz	OFFSET $L001127
;{

;{166}:array[_F]= array[_L];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{167}:_F++ ;
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	inc	dword ptr [EBX]
;}
	jmp	OFFSET $L001128

; else {
$L001127:
;{

;{169}:array[_L]= array[_F];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{170}:_L-- ;
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	dec	dword ptr [EBX]
;}
$L001128:

; }
;}
$L001125:
;}
$L000575:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000018h
Algorithms_Sorting_QuickSort_Partition ENDP

Algorithms_Sorting_QuickSort_Sort PROC NEAR 
;void Sort(double double [] array, unsigned size);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{198}:quickSort(array, 0, size - 1);
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	xor	EAX,EAX
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_QuickSort_quickSort

;{199}:return 
	jmp	OFFSET $L000589
;}
$L000589:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_QuickSort_Sort ENDP

Algorithms_Sorting_QuickSort_quickSort PROC NEAR 
;void quickSort(double double [] array, Algorithms::Sorting::__uint _F, Algorithms::Sorting::__uint _L);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000018h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0018h],ECX
;{

;{177}:F_Hold= _F;
	mov	EAX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBP-0004h],EAX

;{178}:L_Hold= _L;
	mov	EAX,dword ptr [EBP+0010h]
	mov	dword ptr [EBP-0008h],EAX

;{179}:dPivot= array[_F];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0010h]

;{180}:while(_F < _L)
$L001129:
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001130
;{

;{182}:Partition(array, _F, _L, dPivot, true);
	mov	EAX,000000001h
	push	EAX 
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX 
	push	EDX 
	lea	EAX,dword ptr [EBP+0010h]
	push	EAX
	lea	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0018h]
	call	 Algorithms_Sorting_QuickSort_Partition

;{183}:Partition(array, _F, _L, dPivot, false);
	xor	EAX,EAX
	push	EAX 
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX 
	push	EDX 
	lea	EAX,dword ptr [EBP+0010h]
	push	EAX
	lea	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0018h]
	call	 Algorithms_Sorting_QuickSort_Partition
;}
	jmp	OFFSET $L001129
$L001130:

;{185}:array[_F]= dPivot;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{186}:pivot= _F;
	mov	EAX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBP-0014h],EAX

;{187}:_F= F_Hold;
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP+000Ch],EAX

;{188}:_L= L_Hold;
	mov	EAX,dword ptr [EBP-0008h]
	mov	dword ptr [EBP+0010h],EAX

;{189}:if(_F < pivot)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001131

;{190}:quickSort(array, _F, pivot - 1);
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0018h]
	call	 Algorithms_Sorting_QuickSort_quickSort
$L001131:

;{191}:if(_L > pivot)
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001133

;{192}:quickSort(array, pivot + 1, _L);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0018h]
	call	 Algorithms_Sorting_QuickSort_quickSort
$L001133:
;}
$L000581:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_QuickSort_quickSort ENDP

Algorithms_Sorting_QuickSort PROC NEAR 
;void Algorithms::Sorting::QuickSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Sorter ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_QuickSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_QuickSort ENDP

Algorithms_Sorting_SelectionSort_Sort PROC NEAR 
;void Sort(double double [] array, unsigned size);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
;{

;{40}:for(i= 0; i < size; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001136
$L001137:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L001136:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001138
;{

;{42}:_min= i;
	mov	EAX,dword ptr [EBP-0004h]
	mov	dword ptr [EBP-0008h],EAX

;{44}:for(j= i + 1; j < size; j++ )
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L001139
$L001140:
	mov	EAX,dword ptr [EBP-12]
	inc	dword ptr [EBP-12]
$L001139:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001141
;{

;{46}:if(array[j] < array[_min])
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001142

;{47}:_min= j;
	mov	EAX,dword ptr [EBP-000Ch]
	mov	dword ptr [EBP-0008h],EAX
$L001142:
;}
	jmp	OFFSET $L001140 
$L001141:

;{54}:Swap(array, i, _min);
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
;}
	jmp	OFFSET $L001137 
$L001138:
;}
$L000541:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_SelectionSort_Sort ENDP

Algorithms_Sorting_SelectionSort PROC NEAR 
;void Algorithms::Sorting::SelectionSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Sorter ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_SelectionSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_SelectionSort ENDP

Algorithms_Sorting_ShellSort_Sort PROC NEAR 
;void Sort(double double [] array, unsigned size);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000018h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0018h],ECX
;{

;{119}:inc= 3;
	mov	EAX,000000003h
	mov	dword ptr [EBP-0004h],EAX

;{120}:while(inc > 0)
$L001145:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001146
;{

;{122}:for(i= 0; i < size; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001147
$L001148:
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]
$L001147:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001149
;{

;{124}:j= i;
	mov	EAX,dword ptr [EBP-0008h]
	mov	dword ptr [EBP-000Ch],EAX

;{125}:tmp= array[i];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0014h]

;{126}:while((j >= inc) && (array[j - inc] > tmp))
$L001150:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001152
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setg	AL
$L001152:
	test	AL,AL
	jz	OFFSET $L001151
;{

;{128}:array[j]= array[j - inc];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{129}:j= j - inc;
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-000Ch],EAX
;}
	jmp	OFFSET $L001150
$L001151:

;{131}:array[j]= tmp;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,dword ptr [EBP-0014h]
	mov	EAX,dword ptr [EBP-0010h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L001148 
$L001149:

;{133}:if(inc div 2 != 0)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001153

;{134}:inc= inc div 2;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001154

; else {
$L001153:

;{135}:if(inc == 1)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001155

;{136}:inc= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001156

; else {
$L001155:

;{138}:inc= 1;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX
$L001156:

; }
$L001154:

; }
;}
	jmp	OFFSET $L001145
$L001146:
;}
$L000565:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_ShellSort_Sort ENDP

Algorithms_Sorting_ShellSort PROC NEAR 
;void Algorithms::Sorting::ShellSort(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_Sorter ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_ShellSort 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_ShellSort ENDP

Algorithms_Sorting_Sorter_Swap PROC NEAR 
;void Swap(double double [] array, Algorithms::Sorting::__uint a, Algorithms::Sorting::__uint b);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
;{

;{16}:tmp= array[a];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{17}:array[a]= array[b];
	pop	EDX
	pop	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{18}:array[b]= tmp;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
$L000526:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Algorithms_Sorting_Sorter_Swap ENDP

Algorithms_Sorting_Sorter_SwapValues PROC NEAR 
;void SwapValues(double ref _A, double ref _B);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
;{

;{22}:tmp= _A;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX+4]
	mov	EDX,dword ptr [EBX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{23}:_A= _B;
	pop	EDX
	pop	EAX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX+4]
	mov	EDX,dword ptr [EBX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	EBX,dword ptr [EBP+0008h]
	fstp	qword ptr [EBX]

;{24}:_B= tmp;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	EBX,dword ptr [EBP+000Ch]
	fstp	qword ptr [EBX]
;}
$L000532:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Algorithms_Sorting_Sorter_SwapValues ENDP

Algorithms_Sorting_Sorter PROC NEAR 
;void Algorithms::Sorting::Sorter(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__Algorithms_Sorting_Sorter 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Algorithms_Sorting_Sorter ENDP

Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{389}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000469
;}
$L000469:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000486
;}
$L000486:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000492
;}
$L000492:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000490
;}
$L000490:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000483
;}
$L000483:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000500
;}
$L000500:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000506
;}
$L000506:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000497
;}
$L000497:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000502
;}
$L000502:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{384}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_RadiansToDegrees ENDP

Program_TestBinaryInsertionSort PROC NEAR 
;void Program::TestBinaryInsertionSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{178}:sorter;
	lea	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_BinaryInsertionSort

;{179}:Program::TestSortingAlgorithm(sorter, "\nTesting BINARY INSERTION SORT Algorithm: worst: O(n^2), best: O(n lg n)");
	lea	EAX,OFFSET $S000906
	push	EAX
	lea	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Program_TestSortingAlgorithm
;}
$L000904:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestBinaryInsertionSort ENDP

Program_TestBubbleSort PROC NEAR 
;void Program::TestBubbleSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{142}:sorter;
	lea	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_BubbleSort

;{143}:Program::TestSortingAlgorithm(sorter, "\nTesting BUBBLE SORT Algorithm: O(n^2)");
	lea	EAX,OFFSET $S000888
	push	EAX
	lea	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Program_TestSortingAlgorithm
;}
$L000886:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestBubbleSort ENDP

Program_TestHeapSort PROC NEAR 
;void Program::TestHeapSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{172}:sorter;
	lea	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_HeapSort

;{173}:Program::TestSortingAlgorithm(sorter, "\nTesting HEAP SORT Algorithm: O(n lg n)");
	lea	EAX,OFFSET $S000903
	push	EAX
	lea	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Program_TestSortingAlgorithm
;}
$L000901:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestHeapSort ENDP

Program_TestInsertionSort PROC NEAR 
;void Program::TestInsertionSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{148}:sorter;
	lea	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_InsertionSort

;{149}:Program::TestSortingAlgorithm(sorter, "\nTesting INSERTION SORT Algorithm: O(n^2) - faster");
	lea	EAX,OFFSET $S000891
	push	EAX
	lea	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Program_TestSortingAlgorithm
;}
$L000889:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestInsertionSort ENDP

Program_TestMergeSort PROC NEAR 
;void Program::TestMergeSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{166}:sorter;
	lea	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_MergeSort

;{167}:Program::TestSortingAlgorithm(sorter, "\nTesting MERGE SORT Algorithm: O(n lg n)");
	lea	EAX,OFFSET $S000900
	push	EAX
	lea	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Program_TestSortingAlgorithm
;}
$L000898:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestMergeSort ENDP

Program_TestOOBinaryInsertionSort PROC NEAR 
;void Program::TestOOBinaryInsertionSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{204}:sorter;
	lea	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_BinaryInsertionSortEx

;{205}:Program::TestSortingEx(sorter, "\nTesting BINARY INSERTION SORT Algorithm: worst: O(n^2), best: O(n lg n)");
	lea	EAX,OFFSET $S000906
	push	EAX
	lea	EAX,dword ptr [EBP-0008h]
	push	EAX
	call	 Program_TestSortingEx
;}
$L000913:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestOOBinaryInsertionSort ENDP

Program_TestOOBubbleSort PROC NEAR 
;void Program::TestOOBubbleSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{198}:sorter;
	lea	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_BubbleSortEx

;{199}:Program::TestSortingEx(sorter, "\nTesting BUBBLE SORT Algorithm: O(n^2)");
	lea	EAX,OFFSET $S000888
	push	EAX
	lea	EAX,dword ptr [EBP-0008h]
	push	EAX
	call	 Program_TestSortingEx
;}
$L000911:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestOOBubbleSort ENDP

Program_TestOOHeapSort PROC NEAR 
;void Program::TestOOHeapSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{216}:sorter;
	lea	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_HeapSortEx

;{217}:Program::TestSortingEx(sorter, "\nTesting HEAP SORT Algorithm: O(n lg n)");
	lea	EAX,OFFSET $S000903
	push	EAX
	lea	EAX,dword ptr [EBP-0008h]
	push	EAX
	call	 Program_TestSortingEx
;}
$L000917:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestOOHeapSort ENDP

Program_TestOOInsertionSort PROC NEAR 
;void Program::TestOOInsertionSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{186}:sorter;
	lea	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_InsertionSortEx

;{187}:Program::TestSortingEx(sorter, "\nTesting INSERTION SORT Algorithm: O(n^2) - faster");
	lea	EAX,OFFSET $S000891
	push	EAX
	lea	EAX,dword ptr [EBP-0008h]
	push	EAX
	call	 Program_TestSortingEx
;}
$L000907:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestOOInsertionSort ENDP

Program_TestOOMergeSort PROC NEAR 
;void Program::TestOOMergeSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{222}:sorter;
	lea	ECX,dword ptr [EBP-000Ch]
	call	 Algorithms_Sorting_Proxy_TwoWayMergeSort

;{223}:Program::TestSortingEx(sorter, "\nTesting MERGE SORT Algorithm: O(n lg n)");
	lea	EAX,OFFSET $S000900
	push	EAX
	lea	EAX,dword ptr [EBP-000Ch]
	push	EAX
	call	 Program_TestSortingEx
;}
$L000919:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestOOMergeSort ENDP

Program_TestOOQuickSort PROC NEAR 
;void Program::TestOOQuickSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{210}:sorter;
	lea	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_MedianOfThreeQuickSort

;{211}:Program::TestSortingEx(sorter, "\nTesting QUICK SORT Algorithm: worst: O(n^2), best: O(n lg n)");
	lea	EAX,OFFSET $S000897
	push	EAX
	lea	EAX,dword ptr [EBP-0008h]
	push	EAX
	call	 Program_TestSortingEx
;}
$L000915:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestOOQuickSort ENDP

Program_TestOOSelectionSort PROC NEAR 
;void Program::TestOOSelectionSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{192}:sorter;
	lea	ECX,dword ptr [EBP-0008h]
	call	 Algorithms_Sorting_Proxy_SelectionSortEx

;{193}:Program::TestSortingEx(sorter, "\nTesting SELECTION SORT Algorithm: O(n^2)");
	lea	EAX,OFFSET $S000885
	push	EAX
	lea	EAX,dword ptr [EBP-0008h]
	push	EAX
	call	 Program_TestSortingEx
;}
$L000909:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestOOSelectionSort ENDP

Program_TestQuickSort PROC NEAR 
;void Program::TestQuickSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{160}:sorter;
	lea	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_QuickSort

;{161}:Program::TestSortingAlgorithm(sorter, "\nTesting QUICK SORT Algorithm: worst: O(n^2), best: O(n lg n)");
	lea	EAX,OFFSET $S000897
	push	EAX
	lea	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Program_TestSortingAlgorithm
;}
$L000895:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestQuickSort ENDP

Program_TestSelectionSort PROC NEAR 
;void Program::TestSelectionSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{136}:sorter;
	lea	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_SelectionSort

;{137}:Program::TestSortingAlgorithm(sorter, "\nTesting SELECTION SORT Algorithm: O(n^2)");
	lea	EAX,OFFSET $S000885
	push	EAX
	lea	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Program_TestSortingAlgorithm
;}
$L000883:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestSelectionSort ENDP

Program_TestShellSort PROC NEAR 
;void Program::TestShellSort(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{154}:sorter;
	lea	ECX,dword ptr [EBP-0004h]
	call	 Algorithms_Sorting_ShellSort

;{155}:Program::TestSortingAlgorithm(sorter, "\nTesting SHELL SORT Algorithm: O(n^2) - fastest");
	lea	EAX,OFFSET $S000894
	push	EAX
	lea	EAX,dword ptr [EBP-0004h]
	push	EAX
	call	 Program_TestSortingAlgorithm
;}
$L000892:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_TestShellSort ENDP

Program_TestSortingAlgorithm PROC NEAR 
;void Program::TestSortingAlgorithm(Algorithms::Sorting::Sorter ref sorter, string title);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000008Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{100}:Console::WriteLn(title);
	mov	EAX,dword ptr [EBP+000Ch]
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{101}:array;
	lea	EAX,dword ptr [EBP-0080h]

;{103}:array[0]= 203.78;
	xor	EAX,EAX
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0C28F5C29h
	mov	EAX,0406978F5h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{104}:array[1]= 12.345;
	mov	EAX,000000001h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0D70A3D71h
	mov	EAX,04028B0A3h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{105}:array[2]= 10.4567;
	mov	EAX,000000002h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,095182A99h
	mov	EAX,04024E9D4h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{106}:array[3]= 687.35;
	mov	EAX,000000003h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0CCCCCCCDh
	mov	EAX,040857ACCh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{107}:array[4]= 5.7556789;
	mov	EAX,000000004h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0B0871BE8h
	mov	EAX,0401705D0h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{108}:array[5]= 9.985;
	mov	EAX,000000005h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0EB851EB8h
	mov	EAX,04023F851h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{109}:array[6]= 3.389;
	mov	EAX,000000006h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0083126EAh
	mov	EAX,0400B1CACh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{110}:array[7]= 478.2345;
	mov	EAX,000000007h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,083126E98h
	mov	EAX,0407DE3C0h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{111}:array[8]= 0.98754;
	mov	EAX,000000008h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,07C6FBD28h
	mov	EAX,03FEF99EDh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{112}:array[9]= 356.2345;
	mov	EAX,000000009h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,083126E98h
	mov	EAX,0407643C0h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{114}:array[0xA]= -1.75;
	mov	EAX,00000000Ah
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	xor	EDX,EDX
	mov	EAX,03FFC0000h
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{115}:array[0xB]= 47.977;
	mov	EAX,00000000Bh
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,056041894h
	mov	EAX,04047FD0Eh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{116}:array[0xC]= -0.67;
	mov	EAX,00000000Ch
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0D70A3D71h
	mov	EAX,03FE570A3h 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{117}:array[0xD]= 4.758;
	mov	EAX,00000000Dh
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,026E978D5h
	mov	EAX,040130831h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{118}:array[0xE]= 1.2345;
	mov	EAX,00000000Eh
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0126E978Eh
	mov	EAX,03FF3C083h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{119}:array[0xF]= 2.8789;
	mov	EAX,00000000Fh
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0080h]
	push	EAX
	mov	EDX,0B923A29Dh
	mov	EAX,0400707FCh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{121}:n= sizeof (array) / sizeof (double);
	mov	EAX,000000080h
	push	EAX
	mov	EAX,000000008h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	mov	dword ptr [EBP-0084h],EAX

;{123}:Console::WriteLn("\nBefore sorting...");
	lea	EAX,OFFSET $S000878
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{124}:for(x= 0; x < n; x++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0088h],EAX
	jmp	OFFSET $L001174
$L001175:
	mov	EAX,dword ptr [EBP-136]
	inc	dword ptr [EBP-136]
$L001174:
	mov	EAX,dword ptr [EBP-0088h]
	push	EAX
	mov	EAX,dword ptr [EBP-0084h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001176

;{125}:Console::WriteLn("array[", x, "] = ", array[x]);
	lea	EAX,OFFSET $S000880
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0088h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000881
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0088h]
	imul	EAX,EAX,000000008h
	mov	EDX,dword ptr [EBP+EAX-0080h]
	add	EAX,000000004h ;low part
	mov	EAX,dword ptr [EBP+EAX-0080h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001175 
$L001176:

;{127}:sorter.Sort(array, n);
	mov	EAX,dword ptr [EBP-0084h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0080h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0008h]

;{129}:Console::WriteLn("\nAfter sorting...");
	lea	EAX,OFFSET $S000882
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{130}:for(x= 0; x < n; x++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0088h],EAX
	jmp	OFFSET $L001177
$L001178:
	mov	EAX,dword ptr [EBP-136]
	inc	dword ptr [EBP-136]
$L001177:
	mov	EAX,dword ptr [EBP-0088h]
	push	EAX
	mov	EAX,dword ptr [EBP-0084h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001179

;{131}:Console::WriteLn("array[", x, "] = ", array[x]);
	lea	EAX,OFFSET $S000880
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0088h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000881
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0088h]
	imul	EAX,EAX,000000008h
	mov	EDX,dword ptr [EBP+EAX-0080h]
	add	EAX,000000004h ;low part
	mov	EAX,dword ptr [EBP+EAX-0080h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001178 
$L001179:
;}
$L000851:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Program_TestSortingAlgorithm ENDP

Program_TestSortingEx PROC NEAR 
;void Program::TestSortingEx(Algorithms::Sorting::Proxy::SorterEx ref sorter, string title);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000024h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{12}:Console::WriteLn(title);
	mov	EAX,dword ptr [EBP+000Ch]
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{13}:array(9);
	mov	EAX,000000009h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	call	 Algorithms_Sorting_Proxy_ArrayOfAutomobile

;{15}:tmp= array.getAt(0);
	xor	EAX,EAX
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{16}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{18}:autom.Year= 2009;
	mov	EAX,0000007D9h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{19}:autom.Cost= 260798.0;
	xor	EDX,EDX
	mov	EAX,0410FD5F0h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{20}:autom.Model= "Bentley";
	lea	EAX,OFFSET $S000816
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{22}:tmp= array.getAt(1);
	mov	EAX,000000001h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{23}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{25}:autom.Year= 2006;
	mov	EAX,0000007D6h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{26}:autom.Cost= 105000.0;
	xor	EDX,EDX
	mov	EAX,040F9A280h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{27}:autom.Model= "Range Rover";
	lea	EAX,OFFSET $S000819
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{29}:tmp= array.getAt(2);
	mov	EAX,000000002h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{30}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{32}:autom.Year= 2005;
	mov	EAX,0000007D5h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{33}:autom.Cost= 21400.0;
	xor	EDX,EDX
	mov	EAX,040D4E600h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{34}:autom.Model= "Passat";
	lea	EAX,OFFSET $S000822
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{36}:tmp= array.getAt(3);
	mov	EAX,000000003h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{37}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{39}:autom.Year= 2001;
	mov	EAX,0000007D1h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{40}:autom.Cost= 13900.0;
	xor	EDX,EDX
	mov	EAX,040CB2600h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{41}:autom.Model= "Toyota Camry";
	lea	EAX,OFFSET $S000825
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{43}:tmp= array.getAt(4);
	mov	EAX,000000004h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{44}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{46}:autom.Year= 2008;
	mov	EAX,0000007D8h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{47}:autom.Cost= 150000.0;
	xor	EDX,EDX
	mov	EAX,041024F80h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{48}:autom.Model= "Hummer";
	lea	EAX,OFFSET $S000829
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{50}:tmp= array.getAt(5);
	mov	EAX,000000005h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{51}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{53}:autom.Year= 2009;
	mov	EAX,0000007D9h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{54}:autom.Cost= 190000.0;
	xor	EDX,EDX
	mov	EAX,041073180h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{55}:autom.Model= "Cadillac";
	lea	EAX,OFFSET $S000832
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{57}:tmp= array.getAt(6);
	mov	EAX,000000006h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{58}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{60}:autom.Year= 2007;
	mov	EAX,0000007D7h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{61}:autom.Cost= 1500000.0;
	xor	EDX,EDX
	mov	EAX,04136E360h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{62}:autom.Model= "Maseratti";
	lea	EAX,OFFSET $S000836
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{64}:tmp= array.getAt(7);
	mov	EAX,000000007h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{65}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{67}:autom.Year= 2004;
	mov	EAX,0000007D4h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{68}:autom.Cost= 17500.0;
	xor	EDX,EDX
	mov	EAX,040D11700h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{69}:autom.Model= "Honda Civic";
	lea	EAX,OFFSET $S000840
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{71}:tmp= array.getAt(8);
	mov	EAX,000000008h
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{72}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{74}:autom.Year= 2006;
	mov	EAX,0000007D6h
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Year

;{75}:autom.Cost= 15500.0;
	xor	EDX,EDX
	mov	EAX,040CE4600h
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Cost

;{76}:autom.Model= "Jetta";
	lea	EAX,OFFSET $S000843
	push	EAX
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_put_Model

;{78}:n= array.length;
	lea	ECX,dword ptr [EBP-0010h]
	call	 Algorithms_Sorting_Proxy_Array_get_length
	mov	dword ptr [EBP-001Ch],EAX

;{80}:Console::WriteLn("\nBefore Sorting...\n");
	lea	EAX,OFFSET $S000845
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{81}:for(i= 0; i < n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0020h],EAX
	jmp	OFFSET $L001180
$L001181:
	mov	EAX,dword ptr [EBP-32]
	inc	dword ptr [EBP-32]
$L001180:
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001182
;{

;{83}:tmp= array.getAt(i);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{84}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{85}:Console::WriteLn("Auto :\t", autom.Model, "  ,\tYear :\t\t", autom.Year, ", Cost:\t", autom.Cost);
	lea	EAX,OFFSET $S000847
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Model
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	lea	EAX,OFFSET $S000848
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Year
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000849
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Cost
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001181 
$L001182:

;{88}:sorter.Sort(array);
	lea	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX+0004h]
	call	dword ptr [EDX]

;{89}:Console::WriteLn("\nAfter Sorting...\n");
	lea	EAX,OFFSET $S000850
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{90}:for(i= 0; i < n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0020h],EAX
	jmp	OFFSET $L001183
$L001184:
	mov	EAX,dword ptr [EBP-32]
	inc	dword ptr [EBP-32]
$L001183:
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001185
;{

;{92}:tmp= array.getAt(i);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	lea	ECX,dword ptr [EBP-0010h]
	mov	EDX,dword ptr [ECX+000Ch]
	call	dword ptr [EDX+0004h]
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{93}:autom= dynamic_cast(tmp);
	mov	EAX,dword ptr [EBP-20]
	lea	EBX,dword ptr [EBP-0018h]
	mov	dword ptr [EBX],EAX

;{94}:Console::WriteLn("Auto :\t", autom.Model, "  ,\tYear :\t\t", autom.Year, ", Cost:\t", autom.Cost);
	lea	EAX,OFFSET $S000847
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Model
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	lea	EAX,OFFSET $S000848
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Year
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000849
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	ECX,dword ptr [EBP-24]
	call	 Algorithms_Sorting_Proxy_Automobile_get_Cost
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001184 
$L001185:
;}
$L000807:
	lea	ECX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [ECX+000Ch]
	call	dword ptr [EAX+0010h]
$L001186:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Program_TestSortingEx ENDP

__member_Init@Algorithms_Sorting_Proxy_Array PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:array= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX

;{0}:_length= 0;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],EAX

;{0}:_item_size= 0;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0008h],EAX

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__member_Init@Algorithms_Sorting_Proxy_Array ENDP
__member_Init@Algorithms_Sorting_Proxy_Automobile PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:_cost= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]

;{0}:_model= "";
	lea	EAX,OFFSET $S000669
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+000Ch],EAX

;{0}:_year= 0;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	word ptr [ECX+0010h],AX

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__member_Init@Algorithms_Sorting_Proxy_Automobile ENDP
__member_Init@Algorithms_Sorting_Proxy_QuickSortEx PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:Algorithms::Sorting::Proxy::QuickSortEx::cutOff= 1;
	mov	EAX,000000001h
	mov	 Algorithms_Sorting_Proxy_QuickSortEx_cutOff,EAX

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__member_Init@Algorithms_Sorting_Proxy_QuickSortEx ENDP
__member_Init@Algorithms_Sorting_Proxy_SorterEx PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:_array= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__member_Init@Algorithms_Sorting_Proxy_SorterEx ENDP
__member_Init@Algorithms_Sorting_Proxy_TwoWayMergeSort PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:tmpArray= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0008h],EAX

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__member_Init@Algorithms_Sorting_Proxy_TwoWayMergeSort ENDP
Program_main PROC NEAR 
;void Program::main(void);
	push	EBP
	mov	EBP,ESP
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{228}:Console::WriteLn("\nTest 1:\n");
	lea	EAX,OFFSET $S000922
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{229}:Program::TestSelectionSort();
	call	 Program_TestSelectionSort

;{230}:Console::WriteLn("\nTest 2:\n");
	lea	EAX,OFFSET $S000923
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{231}:Program::TestBubbleSort();
	call	 Program_TestBubbleSort

;{232}:Console::WriteLn("\nTest 3:\n");
	lea	EAX,OFFSET $S000924
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{233}:Program::TestInsertionSort();
	call	 Program_TestInsertionSort

;{234}:Console::WriteLn("\nTest 4:\n");
	lea	EAX,OFFSET $S000925
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{235}:Program::TestShellSort();
	call	 Program_TestShellSort

;{236}:Console::WriteLn("\nTest 5:\n");
	lea	EAX,OFFSET $S000926
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{237}:Program::TestQuickSort();
	call	 Program_TestQuickSort

;{238}:Console::WriteLn("\nTest 6:\n");
	lea	EAX,OFFSET $S000927
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{239}:Program::TestMergeSort();
	call	 Program_TestMergeSort

;{240}:Console::WriteLn("\nTest 7:\n");
	lea	EAX,OFFSET $S000928
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{241}:Program::TestHeapSort();
	call	 Program_TestHeapSort

;{242}:Console::WriteLn("\nTest 8:\n");
	lea	EAX,OFFSET $S000929
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{243}:Program::TestBinaryInsertionSort();
	call	 Program_TestBinaryInsertionSort

;{245}:System::ShowMessage("Now, we are going to test the Objects Sorters", "Sample Sorting Library", System::IconInformation);
	mov	EAX,000000040h
	push	EAX 
	lea	EAX,OFFSET $S000931
	push	EAX 
	lea	EAX,OFFSET $S000930
	push	EAX
	call	 System_ShowMessage

;{247}:Program::TestOOInsertionSort();
	call	 Program_TestOOInsertionSort

;{248}:Program::TestOOBubbleSort();
	call	 Program_TestOOBubbleSort

;{249}:Program::TestOOSelectionSort();
	call	 Program_TestOOSelectionSort

;{250}:Program::TestOOQuickSort();
	call	 Program_TestOOQuickSort

;{251}:Program::TestOOHeapSort();
	call	 Program_TestOOHeapSort

;{252}:Program::TestOOBinaryInsertionSort();
	call	 Program_TestOOBinaryInsertionSort

;{253}:Program::TestOOMergeSort();
	call	 Program_TestOOMergeSort
;}
$L000921:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	call	 Program_main ;user entry point (stdcall calling convention)
	push	EAX
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
@@class_vptr_vtbl@@__Algorithms_Sorting_BinaryInsertionSort	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET Algorithms_Sorting_BinaryInsertionSort_Sort

@@class_vptr_vtbl@@__Algorithms_Sorting_Sorter	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET __purecall

@@class_vptr_vtbl@@__Algorithms_Sorting_BubbleSort	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET Algorithms_Sorting_BubbleSort_Sort

@@class_vptr_vtbl@@__Algorithms_Sorting_HeapSort	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET Algorithms_Sorting_HeapSort_Sort

@@class_vptr_vtbl@@__Algorithms_Sorting_InsertionSort	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET Algorithms_Sorting_InsertionSort_Sort

@@class_vptr_vtbl@@__Algorithms_Sorting_MergeSort	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET Algorithms_Sorting_MergeSort_Sort

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_Array	DWORD	OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall,
						OFFSET Algorithms_Sorting_Proxy_Array_Destructor

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_ArrayOfAutomobile	DWORD	OFFSET Algorithms_Sorting_Proxy_ArrayOfAutomobile_Swap,
						OFFSET Algorithms_Sorting_Proxy_ArrayOfAutomobile_getAt,
						OFFSET Algorithms_Sorting_Proxy_ArrayOfAutomobile_CopyTo,
						OFFSET Algorithms_Sorting_Proxy_ArrayOfAutomobile_CopyFrom,
						OFFSET Algorithms_Sorting_Proxy_Array_Destructor

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_Automobile	DWORD	OFFSET Algorithms_Sorting_Proxy_Automobile_Compare,
						OFFSET Algorithms_Sorting_Proxy_Automobile_Destructor

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_ProxyObject	DWORD	OFFSET __purecall

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_BinaryInsertionSortEx	DWORD	OFFSET Algorithms_Sorting_Proxy_BinaryInsertionSortEx_Sort,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_SorterEx	DWORD	OFFSET __purecall,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_BubbleSortEx	DWORD	OFFSET Algorithms_Sorting_Proxy_BubbleSortEx_Sort,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_HeapSortEx	DWORD	OFFSET Algorithms_Sorting_Proxy_HeapSortEx_Sort,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_InsertionSortEx	DWORD	OFFSET Algorithms_Sorting_Proxy_InsertionSortEx_Sort,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_MedianOfThreeQuickSort	DWORD	OFFSET Algorithms_Sorting_Proxy_QuickSortEx_Sort,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap,
						OFFSET Algorithms_Sorting_Proxy_MedianOfThreeQuickSort_selectPivot,
						OFFSET Algorithms_Sorting_Proxy_QuickSortEx_doSort

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_QuickSortEx	DWORD	OFFSET Algorithms_Sorting_Proxy_QuickSortEx_Sort,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap,
						OFFSET __purecall,
						OFFSET Algorithms_Sorting_Proxy_QuickSortEx_doSort

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_SelectionSortEx	DWORD	OFFSET Algorithms_Sorting_Proxy_SelectionSortEx_Sort,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap

@@class_vptr_vtbl@@__Algorithms_Sorting_Proxy_TwoWayMergeSort	DWORD	OFFSET Algorithms_Sorting_Proxy_TwoWayMergeSort_Sort,
						OFFSET Algorithms_Sorting_Proxy_SorterEx_Swap

@@class_vptr_vtbl@@__Algorithms_Sorting_QuickSort	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET Algorithms_Sorting_QuickSort_Sort

@@class_vptr_vtbl@@__Algorithms_Sorting_SelectionSort	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET Algorithms_Sorting_SelectionSort_Sort

@@class_vptr_vtbl@@__Algorithms_Sorting_ShellSort	DWORD	OFFSET Algorithms_Sorting_Sorter_Swap,
						OFFSET Algorithms_Sorting_Sorter_SwapValues,
						OFFSET Algorithms_Sorting_ShellSort_Sort

File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

$S000848 		BYTE 	"  ,",09h,"Year :",09h,09h,0
$S000669 		BYTE 	0,0 ;null-string
$S000849 		BYTE 	", Cost:",09h,0
$S000847 		BYTE 	"Auto :",09h,0
$S000816 		BYTE 	"Bentley",0
$S000832 		BYTE 	"Cadillac",0
$S000688 		BYTE 	"Destroying an auto...",0
$S000840 		BYTE 	"Honda Civic",0
$S000829 		BYTE 	"Hummer",0
$S000843 		BYTE 	"Jetta",0
$S000836 		BYTE 	"Maseratti",0
$S000930 		BYTE 	"Now, we are going to test the Objects Sorters",0
$S000822 		BYTE 	"Passat",0
$S000819 		BYTE 	"Range Rover",0
$S000931 		BYTE 	"Sample Sorting Library",0
$S000825 		BYTE 	"Toyota Camry",0
$S000850 		BYTE 	0Ah,"After Sorting...",0Ah,0
$S000882 		BYTE 	0Ah,"After sorting...",0
$S000845 		BYTE 	0Ah,"Before Sorting...",0Ah,0
$S000878 		BYTE 	0Ah,"Before sorting...",0
$S000922 		BYTE 	0Ah,"Test 1:",0Ah,0
$S000923 		BYTE 	0Ah,"Test 2:",0Ah,0
$S000924 		BYTE 	0Ah,"Test 3:",0Ah,0
$S000925 		BYTE 	0Ah,"Test 4:",0Ah,0
$S000926 		BYTE 	0Ah,"Test 5:",0Ah,0
$S000927 		BYTE 	0Ah,"Test 6:",0Ah,0
$S000928 		BYTE 	0Ah,"Test 7:",0Ah,0
$S000929 		BYTE 	0Ah,"Test 8:",0Ah,0
$S000906 		BYTE 	0Ah,"Testing BINARY INSERTION SORT Algorithm: worst: O(n^2), best: O(n lg n)",0
$S000888 		BYTE 	0Ah,"Testing BUBBLE SORT Algorithm: O(n^2)",0
$S000903 		BYTE 	0Ah,"Testing HEAP SORT Algorithm: O(n lg n)",0
$S000891 		BYTE 	0Ah,"Testing INSERTION SORT Algorithm: O(n^2) - faster",0
$S000900 		BYTE 	0Ah,"Testing MERGE SORT Algorithm: O(n lg n)",0
$S000897 		BYTE 	0Ah,"Testing QUICK SORT Algorithm: worst: O(n^2), best: O(n lg n)",0
$S000885 		BYTE 	0Ah,"Testing SELECTION SORT Algorithm: O(n^2)",0
$S000894 		BYTE 	0Ah,"Testing SHELL SORT Algorithm: O(n^2) - fastest",0
$S000881 		BYTE 	"] = ",0
$S000880 		BYTE 	"array[",0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000020h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count
Algorithms_Sorting_Proxy_QuickSortEx_cutOff	 DWORD	0

END __System_Hpp_Runtime_Init

