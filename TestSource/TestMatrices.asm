TITLE	 TestMatrices.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE stdhpp\hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{389}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000469
;}
$L000469:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000486
;}
$L000486:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000492
;}
$L000492:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000490
;}
$L000490:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000483
;}
$L000483:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000500
;}
$L000500:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000506
;}
$L000506:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000497
;}
$L000497:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000502
;}
$L000502:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{384}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_RadiansToDegrees ENDP

Program_CalcTrace PROC NEAR 
;double Program::CalcTrace(double double [][] M, int rM, int cM);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{20}:Tr= 0.0;
	fldz
	fstp	qword ptr [EBP-0008h]

;{21}:n= min(rM, cM);
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EBX
	sub	EBX,EAX
	sbb	ECX,ECX
	and	ECX,EBX
	add	EAX,ECX
	mov	dword ptr [EBP-000Ch],EAX

;{22}:for(i= 0; i < n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0010h],EAX
	jmp	OFFSET $L000633
$L000634:
	mov	EAX,dword ptr [EBP-16]
	inc	dword ptr [EBP-16]
$L000633:
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000635
;{

;{23}:Console::WriteLn("M[", i, ",", i, "]= ", M[i][i]);
	lea	EAX,OFFSET $S000541
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000002Ch
	push	EAX 
	call	 Console_WriteChar 
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000543
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0010h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{24}:Tr+= M[i][i];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0010h]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0010h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	clc	
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	lea	EBX,dword ptr [EBP-0008h]
	fadd	qword ptr [EBX]
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L000634 
$L000635:

;{26}:return Tr
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L000533
;}
$L000533:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Program_CalcTrace ENDP

Program_MultiplyMatrices PROC NEAR 
;void Program::MultiplyMatrices(double double [][] A, double double [][] B, int rA, int cA, int rB, int cB);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000330h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{73}:Res;
	lea	EAX,dword ptr [EBP-0320h]

;{74}:if(cA == rB)
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX
	mov	EAX,dword ptr [EBP+0018h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000636
;{

;{77}:for(i= 0; i < rA; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0324h],EAX
	jmp	OFFSET $L000638
$L000639:
	mov	EAX,dword ptr [EBP-804]
	inc	dword ptr [EBP-804]
$L000638:
	mov	EAX,dword ptr [EBP-0324h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000640

;{78}:for(j= 0; j < cB; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0328h],EAX
	jmp	OFFSET $L000641
$L000642:
	mov	EAX,dword ptr [EBP-808]
	inc	dword ptr [EBP-808]
$L000641:
	mov	EAX,dword ptr [EBP-0328h]
	push	EAX
	mov	EAX,dword ptr [EBP+001Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000643

;{79}:Res[i][j]= 0.0;
	mov	EAX,dword ptr [EBP-0324h]
	imul	EAX,EAX,000000050h
	lea	EDX,dword ptr [EBP+EAX-0320h]
	push	EDX
	mov	EAX,dword ptr [EBP-0328h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	fldz
	pop	EBX
	fstp	qword ptr [EBX]
	jmp	OFFSET $L000642 
$L000643:
	jmp	OFFSET $L000639 
$L000640:

;{81}:for(i= 0; i < rA; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0324h],EAX
	jmp	OFFSET $L000644
$L000645:
	mov	EAX,dword ptr [EBP-804]
	inc	dword ptr [EBP-804]
$L000644:
	mov	EAX,dword ptr [EBP-0324h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000646

;{82}:for(j= 0; j < cA; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0328h],EAX
	jmp	OFFSET $L000647
$L000648:
	mov	EAX,dword ptr [EBP-808]
	inc	dword ptr [EBP-808]
$L000647:
	mov	EAX,dword ptr [EBP-0328h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000649

;{83}:for(k= 0; k < cA; k++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-032Ch],EAX
	jmp	OFFSET $L000650
$L000651:
	mov	EAX,dword ptr [EBP-812]
	inc	dword ptr [EBP-812]
$L000650:
	mov	EAX,dword ptr [EBP-032Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000652

;{84}:Res[i][j]+= A[i][k] * B[k][j];
	mov	EAX,dword ptr [EBP-0324h]
	imul	EAX,EAX,000000050h
	lea	EDX,dword ptr [EBP+EAX-0320h]
	push	EDX
	mov	EAX,dword ptr [EBP-0328h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0324h]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-032Ch]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-032Ch]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0328h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	clc	
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fadd	qword ptr [EBX]
	fstp	qword ptr [EBX]
	jmp	OFFSET $L000651 
$L000652:
	jmp	OFFSET $L000648 
$L000649:
	jmp	OFFSET $L000645 
$L000646:

;{86}:Program::ShowMatrixForm(Res, rA, cB);
	mov	EAX,dword ptr [EBP+001Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_ShowMatrixForm
;}
	jmp	OFFSET $L000637

; else {
$L000636:

;{88}:Console::WriteLn("El numero de filas de B debe ser igual al numero de filas de A.");
	lea	EAX,OFFSET $S000575
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000637:

; }
;}
$L000564:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000018h
Program_MultiplyMatrices ENDP

Program_ShowMatrixForm PROC NEAR 
;void Program::ShowMatrixForm(double double [][] M, int rM, int cM);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{11}:for(i= 0; i < rM; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L000653
$L000654:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L000653:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000655
;{

;{12}:Console::Write("\n| ");
	lea	EAX,OFFSET $S000529
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{13}:for(j= 0; j < cM; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L000656
$L000657:
	mov	EAX,dword ptr [EBP-8]
	inc	dword ptr [EBP-8]
$L000656:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000658

;{14}:Console::Write(M[i][j], "  ");
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0008h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 Console_WriteDouble
	lea	EAX,OFFSET $S000531
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	jmp	OFFSET $L000657 
$L000658:

;{15}:Console::Write("| ");
	lea	EAX,OFFSET $S000532
	push	000000000h
	push	EAX 
	call	 Console_WriteString
;}
	jmp	OFFSET $L000654 
$L000655:
;}
$L000523:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Program_ShowMatrixForm ENDP

Program_SumMatrices PROC NEAR 
;void Program::SumMatrices(double double [][] A, double double [][] B, int rows, int cols, Program::OpType what);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000334h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{51}:Res;
	lea	EAX,dword ptr [EBP-0320h]

;{52}:Result= 0.0;
	fldz
	fstp	qword ptr [EBP-0328h]

;{53}:for(i= 0; i < rows; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-032Ch],EAX
	jmp	OFFSET $L000659
$L000660:
	mov	EAX,dword ptr [EBP-812]
	inc	dword ptr [EBP-812]
$L000659:
	mov	EAX,dword ptr [EBP-032Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000661

;{54}:for(j= 0; j < cols; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0330h],EAX
	jmp	OFFSET $L000662
$L000663:
	mov	EAX,dword ptr [EBP-816]
	inc	dword ptr [EBP-816]
$L000662:
	mov	EAX,dword ptr [EBP-0330h]
	push	EAX
	mov	EAX,dword ptr [EBP+0014h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000664
;{

;{55}:if(Program::Sum == what)
	mov	EAX,000000001h
	push	EAX
	mov	EAX,dword ptr [EBP+0018h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000665

;{56}:Result= A[i][j] + B[i][j];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-032Ch]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0330h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-032Ch]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0330h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0328h]
	jmp	OFFSET $L000666

; else {
$L000665:

;{58}:Result= A[i][j] - B[i][j];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-032Ch]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0330h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-032Ch]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0330h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0328h]
$L000666:

; }

;{60}:Res[i][j]= Result;
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP-032Ch]
	imul	EAX,EAX,000000050h
	lea	EDX,dword ptr [EBP+EAX-0320h]
	push	EDX
	mov	EAX,dword ptr [EBP-0330h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,dword ptr [EBP-0328h]
	mov	EAX,dword ptr [EBP-0324h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L000663 
$L000664:
	jmp	OFFSET $L000660 
$L000661:

;{63}:Program::ShowMatrixForm(Res, rows, cols);
	mov	EAX,dword ptr [EBP+0014h]
	push	EAX 
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_ShowMatrixForm
;}
$L000554:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000014h
Program_SumMatrices ENDP

Program_Traspose PROC NEAR 
;void Program::Traspose(double double [][] M, int rM, int cM);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000032Ch
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{31}:Res;
	lea	EAX,dword ptr [EBP-0320h]

;{33}:for(i= 0; i < rM; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0324h],EAX
	jmp	OFFSET $L000667
$L000668:
	mov	EAX,dword ptr [EBP-804]
	inc	dword ptr [EBP-804]
$L000667:
	mov	EAX,dword ptr [EBP-0324h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000669

;{34}:for(j= 0; j < cM; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0328h],EAX
	jmp	OFFSET $L000670
$L000671:
	mov	EAX,dword ptr [EBP-808]
	inc	dword ptr [EBP-808]
$L000670:
	mov	EAX,dword ptr [EBP-0328h]
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000672

;{35}:Res[j][i]= M[i][j];
	mov	EAX,dword ptr [EBP-0328h]
	imul	EAX,EAX,000000050h
	lea	EDX,dword ptr [EBP+EAX-0320h]
	push	EDX
	mov	EAX,dword ptr [EBP-0324h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0324h]
	imul	EAX,EAX,00000000Ah
	mov	ESI,EAX
	mov	EAX,dword ptr [EBP-0328h]
	add	EAX,ESI
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
	jmp	OFFSET $L000671 
$L000672:
	jmp	OFFSET $L000668 
$L000669:

;{37}:Program::ShowMatrixForm(Res, rM, cM);
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX 
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_ShowMatrixForm
;}
$L000544:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	00000000Ch
Program_Traspose ENDP

Program_main PROC NEAR 
;void Program::main(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000674h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{93}:A;
	lea	EAX,dword ptr [EBP-0320h]

;{94}:B;
	lea	EAX,dword ptr [EBP-0640h]

;{96}:Tr= 0.0;
	fldz
	fstp	qword ptr [EBP-0648h]

;{97}:bExitProgram= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-064Ch],AL

;{98}:bReEnterMatrices= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-0650h],AL

;{99}:while(true)
$L000673:
	mov	EAX,000000001h
	test	AL,AL
	jz	OFFSET $L000674
;{

;{101}:Console::ClearScreen();
	call	 Console_ClearScreen

;{102}:Console::WriteLn("Programa de Matrices\n\n");
	lea	EAX,OFFSET $S000582
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{103}:Console::WriteLn("Entre las dimensiones de dos matrices:\n");
	lea	EAX,OFFSET $S000583
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{104}:Console::Write("Entre las filas de A: ");
	lea	EAX,OFFSET $S000584
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{105}:rA= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0654h],EAX

;{106}:Console::Write("\nEntre las columnas de A: ");
	lea	EAX,OFFSET $S000586
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{107}:cA= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0658h],EAX

;{109}:Console::Write("\nEntre las filas de B: ");
	lea	EAX,OFFSET $S000588
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{110}:rB= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-065Ch],EAX

;{111}:Console::Write("\nEntre las columnas de B: ");
	lea	EAX,OFFSET $S000590
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{112}:cB= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0660h],EAX

;{114}:Console::ClearScreen();
	call	 Console_ClearScreen

;{116}:x= 'N';
	mov	EAX,00000004Eh
	mov	byte ptr [EBP-0664h],AL

;{117}:if(rA <= 0 || rB <= 0)
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jnz	OFFSET $L000677
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
$L000677:
	test	AL,AL
	jz	OFFSET $L000675
;{

;{119}:Console::WriteLn("El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
	lea	EAX,OFFSET $S000594
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{120}:x= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0664h],AL

;{121}:if(x == 'y' || x == 'Y')
	movsx	EAX,byte ptr [EBP-0664h]
	push	EAX
	mov	EAX,000000079h
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000680
	movsx	EAX,byte ptr [EBP-0664h]
	push	EAX
	mov	EAX,000000059h
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000680:
	test	AL,AL
	jz	OFFSET $L000678

;continue;
	jmp	OFFSET $L000673
$L000678:

;break;
	jmp	OFFSET $L000674
;}
$L000675:

;{126}:if(rA > 10 || rB > 10)
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jnz	OFFSET $L000683
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setg	AL
$L000683:
	test	AL,AL
	jz	OFFSET $L000681
;{

;{128}:Console::WriteLn("El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
	lea	EAX,OFFSET $S000594
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{129}:x= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0664h],AL

;{130}:if(x == 'y' || x == 'Y')
	movsx	EAX,byte ptr [EBP-0664h]
	push	EAX
	mov	EAX,000000079h
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000686
	movsx	EAX,byte ptr [EBP-0664h]
	push	EAX
	mov	EAX,000000059h
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000686:
	test	AL,AL
	jz	OFFSET $L000684

;continue;
	jmp	OFFSET $L000673
$L000684:

;break;
	jmp	OFFSET $L000674
;}
$L000681:

;{135}:if(cA <= 0 || cB <= 0)
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jnz	OFFSET $L000689
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setle	AL
$L000689:
	test	AL,AL
	jz	OFFSET $L000687
;{

;{137}:Console::WriteLn("El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
	lea	EAX,OFFSET $S000598
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{138}:x= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0664h],AL

;{139}:if(x == 'y' || x == 'Y')
	movsx	EAX,byte ptr [EBP-0664h]
	push	EAX
	mov	EAX,000000079h
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000692
	movsx	EAX,byte ptr [EBP-0664h]
	push	EAX
	mov	EAX,000000059h
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000692:
	test	AL,AL
	jz	OFFSET $L000690

;continue;
	jmp	OFFSET $L000673
$L000690:

;break;
	jmp	OFFSET $L000674
;}
$L000687:

;{144}:if(cA > 10 || cB > 10)
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jnz	OFFSET $L000695
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setg	AL
$L000695:
	test	AL,AL
	jz	OFFSET $L000693
;{

;{146}:Console::WriteLn("El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
	lea	EAX,OFFSET $S000598
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{147}:x= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0664h],AL

;{148}:if(x == 'y' || x == 'Y')
	movsx	EAX,byte ptr [EBP-0664h]
	push	EAX
	mov	EAX,000000079h
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jnz	OFFSET $L000698
	movsx	EAX,byte ptr [EBP-0664h]
	push	EAX
	mov	EAX,000000059h
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000698:
	test	AL,AL
	jz	OFFSET $L000696

;continue;
	jmp	OFFSET $L000673
$L000696:

;break;
	jmp	OFFSET $L000674
;}
$L000693:

;{153}:Console::WriteLn("Entre los valores para la matriz A[", rA, "][", cA, "]");
	lea	EAX,OFFSET $S000599
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000600
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000005Dh
	push	EAX 
	call	 Console_WriteChar 
	call	 Console_WriteCrLf 

;{154}:for(i= 0; i < rA; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0668h],EAX
	jmp	OFFSET $L000699
$L000700:
	mov	EAX,dword ptr [EBP-1640]
	inc	dword ptr [EBP-1640]
$L000699:
	mov	EAX,dword ptr [EBP-0668h]
	push	EAX
	mov	EAX,dword ptr [EBP-0654h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000701

;{155}:for(j= 0; j < cA; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-066Ch],EAX
	jmp	OFFSET $L000702
$L000703:
	mov	EAX,dword ptr [EBP-1644]
	inc	dword ptr [EBP-1644]
$L000702:
	mov	EAX,dword ptr [EBP-066Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0658h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000704
;{

;{157}:Console::Write("Elemento en A[", i, ",", j, "] = ");
	lea	EAX,OFFSET $S000604
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0668h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000002Ch
	push	EAX 
	call	 Console_WriteChar 
	mov	EAX,dword ptr [EBP-066Ch]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000605
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 

;{158}:A[i][j]= Console::ReadDouble();
	mov	EAX,dword ptr [EBP-0668h]
	imul	EAX,EAX,000000050h
	lea	EDX,dword ptr [EBP+EAX-0320h]
	push	EDX
	mov	EAX,dword ptr [EBP-066Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	call	 Console_ReadDouble
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L000703 
$L000704:
	jmp	OFFSET $L000700 
$L000701:

;{161}:Console::WriteLn("\nEntre los valores para la matriz B[", rB, "][", cB, "]");
	lea	EAX,OFFSET $S000606
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000600
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000005Dh
	push	EAX 
	call	 Console_WriteChar 
	call	 Console_WriteCrLf 

;{162}:for(i= 0; i < rB; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0668h],EAX
	jmp	OFFSET $L000705
$L000706:
	mov	EAX,dword ptr [EBP-1640]
	inc	dword ptr [EBP-1640]
$L000705:
	mov	EAX,dword ptr [EBP-0668h]
	push	EAX
	mov	EAX,dword ptr [EBP-065Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000707

;{163}:for(j= 0; j < cB; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-066Ch],EAX
	jmp	OFFSET $L000708
$L000709:
	mov	EAX,dword ptr [EBP-1644]
	inc	dword ptr [EBP-1644]
$L000708:
	mov	EAX,dword ptr [EBP-066Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0660h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000710
;{

;{165}:Console::Write("Elemento en B[", i, ",", j, "] = ");
	lea	EAX,OFFSET $S000607
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0668h]
	push	EAX 
	call	 Console_WriteInteger 
	mov	EAX,00000002Ch
	push	EAX 
	call	 Console_WriteChar 
	mov	EAX,dword ptr [EBP-066Ch]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000605
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 

;{166}:B[i][j]= Console::ReadDouble();
	mov	EAX,dword ptr [EBP-0668h]
	imul	EAX,EAX,000000050h
	lea	EDX,dword ptr [EBP+EAX-0640h]
	push	EDX
	mov	EAX,dword ptr [EBP-066Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	call	 Console_ReadDouble
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
	jmp	OFFSET $L000709 
$L000710:
	jmp	OFFSET $L000706 
$L000707:

;{170}:Console::WriteLn("Matriz A:\n");
	lea	EAX,OFFSET $S000608
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{171}:Program::ShowMatrixForm(A, rA, cA);
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_ShowMatrixForm

;{172}:Console::WriteLn("\n\nMatriz B:\n");
	lea	EAX,OFFSET $S000609
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{173}:Program::ShowMatrixForm(B, rB, cB);
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX 
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX 
	lea	EAX,dword ptr [EBP-0640h]
	push	EAX
	call	 Program_ShowMatrixForm

;do
$L000711:
;{

;{176}:Console::WriteLn("\n\nQue deseas hacer?\n");
	lea	EAX,OFFSET $S000610
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{177}:Console::WriteLn("0. Mostrar las Matrices\n1. Sumar las matrices.\n2. Restar las matrices.\n3. Multiplicar las matrices (A*B).\n4. Multiplicar las matrices (B*A).\n5. Calcular la traza de A\n6. Calcular la traza de B.\n7. Trasponer matriz A.\n8. Trasponer matriz B.\n9. Re-Entrar Matrices\n10. Salir\n\n");
	lea	EAX,OFFSET $S000611
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{178}:Console::Write(">:");
	lea	EAX,OFFSET $S000612
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{179}:nOption= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0670h],EAX

;{180}:switch(nOption)
	mov	EAX,dword ptr [EBP-0670h]
	mov	ESI,EAX
	xor	EAX,EAX
	cmp	EAX,ESI
	jz	OFFSET $L000715
	mov	EAX,000000001h
	cmp	EAX,ESI
	jz	OFFSET $L000716
	mov	EAX,000000002h
	cmp	EAX,ESI 
	jz	OFFSET $L000717 
	mov	EAX,000000003h
	cmp	EAX,ESI
	jz	OFFSET $L000723
	mov	EAX,000000004h
	cmp	EAX,ESI
	jz	OFFSET $L000726
	mov	EAX,000000005h
	cmp	EAX,ESI
	jz	OFFSET $L000729
	mov	EAX,000000006h
	cmp	EAX,ESI
	jz	OFFSET $L000730
	mov	EAX,000000007h
	cmp	EAX,ESI
	jz	OFFSET $L000731
	mov	EAX,000000008h
	cmp	EAX,ESI
	jz	OFFSET $L000734
	mov	EAX,000000009h
	cmp	EAX,ESI
	jz	OFFSET $L000737
	mov	EAX,00000000Ah
	cmp	EAX,ESI
	jz	OFFSET $L000738
	jmp	OFFSET $L000739
$L000715:
;{

;{183}:Console::WriteLn("Matriz A:\n");
	lea	EAX,OFFSET $S000608
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{184}:Program::ShowMatrixForm(A, rA, cA);
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_ShowMatrixForm

;{185}:Console::WriteLn("\n\nMatriz B:\n");
	lea	EAX,OFFSET $S000609
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{186}:Program::ShowMatrixForm(B, rB, cB);
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX 
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX 
	lea	EAX,dword ptr [EBP-0640h]
	push	EAX
	call	 Program_ShowMatrixForm
;}
	jmp	OFFSET $L000714
$L000716:
$L000717:
;{

;{192}:if(rA != rB || cA != cB)
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX
	mov	EAX,dword ptr [EBP-065Ch]
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jnz	OFFSET $L000720
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX
	mov	EAX,dword ptr [EBP-0660h]
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
$L000720:
	test	AL,AL
	jz	OFFSET $L000718
;{

;{194}:Console::WriteLn("Las matrices deben tener las mismas dimensiones para ser sumadas.");
	lea	EAX,OFFSET $S000614
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000719

; else {
$L000718:
;{

;{196}:Console::WriteLn("La matriz resultado:");
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{197}:Program::SumMatrices(A, B, rA, rB, nOption == 1 ? Program::Sum : Program::Substract);
	mov	EAX,dword ptr [EBP-0670h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	 $L000721
	mov	EAX,000000001h
	jmp	 $L000722
$L000721:
	mov	EAX,000000002h
$L000722:
	push	EAX 
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0640h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_SumMatrices
;}
$L000719:

; }
;}
	jmp	OFFSET $L000714
$L000723:
;{

;{203}:if(cA == rB)
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX
	mov	EAX,dword ptr [EBP-065Ch]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000724
;{

;{205}:Console::WriteLn("La matriz resultado C = A*B es:\n");
	lea	EAX,OFFSET $S000617
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{206}:Program::MultiplyMatrices(A, B, rA, cA, rB, cB);
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX 
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX 
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0640h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_MultiplyMatrices
;}
	jmp	OFFSET $L000725

; else {
$L000724:

;{208}:Console::WriteLn("El numero de filas de B debe ser igual al numero de columnas de A.");
	lea	EAX,OFFSET $S000618
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000725:

; }
;}
	jmp	OFFSET $L000714
$L000726:
;{

;{213}:if(cB == rA)
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX
	mov	EAX,dword ptr [EBP-0654h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000727
;{

;{215}:Console::WriteLn("La matriz resultado C = B*A es:\n");
	lea	EAX,OFFSET $S000620
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{216}:Program::MultiplyMatrices(B, A, rB, cB, rA, cA);
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX 
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0640h]
	push	EAX
	call	 Program_MultiplyMatrices
;}
	jmp	OFFSET $L000728

; else {
$L000727:

;{218}:Console::WriteLn("El numero de filas de A debe ser igual al numero de columnas de B.");
	lea	EAX,OFFSET $S000621
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000728:

; }
;}
	jmp	OFFSET $L000714
$L000729:
;{

;{222}:Tr= Program::CalcTrace(A, rA, cA);
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_CalcTrace
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0648h]

;{223}:Console::WriteLn("\nLa Traza de la matriz es = ", Tr);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000623
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0648h]
	mov	EAX,dword ptr [EBP-0644h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000714
$L000730:
;{

;{227}:Tr= Program::CalcTrace(B, rB, cB);
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX 
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX 
	lea	EAX,dword ptr [EBP-0640h]
	push	EAX
	call	 Program_CalcTrace
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0648h]

;{228}:Console::WriteLn("\nLa Traza de la matriz es = ", Tr);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S000623
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0648h]
	mov	EAX,dword ptr [EBP-0644h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000714
$L000731:
;{

;{232}:if(rA == cA)
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX
	mov	EAX,dword ptr [EBP-0658h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000732
;{

;{234}:Console::WriteLn("La Traspuesta de la matriz es:");
	lea	EAX,OFFSET $S000626
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{235}:Program::Traspose(A, rA, cA);
	mov	EAX,dword ptr [EBP-0658h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0654h]
	push	EAX 
	lea	EAX,dword ptr [EBP-0320h]
	push	EAX
	call	 Program_Traspose
;}
	jmp	OFFSET $L000733

; else {
$L000732:

;{237}:Console::WriteLn("Esta matriz no se puede trasponer ya que no es cuadrada.");
	lea	EAX,OFFSET $S000627
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000733:

; }
;}
	jmp	OFFSET $L000714
$L000734:
;{

;{241}:if(rB == cB)
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0660h]
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L000735
;{

;{243}:Console::WriteLn("La Traspuesta de la matriz es:");
	lea	EAX,OFFSET $S000626
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{244}:Program::Traspose(B, rB, cB);
	mov	EAX,dword ptr [EBP-0660h]
	push	EAX 
	mov	EAX,dword ptr [EBP-065Ch]
	push	EAX 
	lea	EAX,dword ptr [EBP-0640h]
	push	EAX
	call	 Program_Traspose
;}
	jmp	OFFSET $L000736

; else {
$L000735:

;{246}:Console::WriteLn("Esta matriz no se puede trasponer ya que no es cuadrada.");
	lea	EAX,OFFSET $S000627
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L000736:

; }
;}
	jmp	OFFSET $L000714
$L000737:
;{

;{251}:bReEnterMatrices= true;
	mov	EAX,000000001h
	mov	byte ptr [EBP-0650h],AL
;}
	jmp	OFFSET $L000714
$L000738:
;{

;{256}:bExitProgram= true;
	mov	EAX,000000001h
	mov	byte ptr [EBP-064Ch],AL
;}
	jmp	OFFSET $L000714
$L000739:
;{

;{261}:Console::WriteLn("Entrada desconocida. Favor seleccionar una opcion.");
	lea	EAX,OFFSET $S000630
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000714:

;{265}:if(false == bExitProgram)
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-064Ch]
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L000740
;{

;{267}:Console::WriteLn("\n\nPresione una tecla para regresar...");
	lea	EAX,OFFSET $S000631
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{268}:ch= Console::ReadChar();
	call	 Console_ReadChar
	mov	byte ptr [EBP-0674h],AL
;}
$L000740:
;}
$L000712:

;{268}:while(false == bExitProgram && false == bReEnterMatrices)
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-064Ch]
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L000742
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-0650h]
	pop	EDX
	cmp	DL,AL
	setz	AL
$L000742:
	test	AL,AL
	jne	OFFSET $L000711
$L000713:

;{273}:if(bExitProgram)
	movzx	EAX,byte ptr [EBP-064Ch]
	test	AL,AL
	jz	OFFSET $L000743

;break;
	jmp	OFFSET $L000674
$L000743:

;{275}:if(bReEnterMatrices)
	movzx	EAX,byte ptr [EBP-0650h]
	test	AL,AL
	jz	OFFSET $L000745
;{

;{276}:bReEnterMatrices= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-0650h],AL

;continue;
	jmp	OFFSET $L000673
;}
$L000745:
;}
	jmp	OFFSET $L000673
$L000674:
;}
$L000576:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Program_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	call	 Program_main ;user entry point (stdcall calling convention)
	push	EAX
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

$S000531 		BYTE 	"  ",0
$S000611 		BYTE 	"0. Mostrar las Matrices",0Ah,"1. Sumar las matrices.",0Ah,"2. Restar las matrices.",0Ah,"3. Multiplicar las matrices (A*B).",0Ah,"4. Multiplicar las matrices (B*A).",0Ah,"5. Calcular la traza de A",0Ah,"6. Calcular la traza de B.",0Ah,"7. Trasponer matriz A.",0Ah,"8. Trasponer matriz B.",0Ah,"9. Re-Entrar Matrices",0Ah,"10. Salir",0Ah,0Ah,0
$S000612 		BYTE 	">:",0
$S000598 		BYTE 	"El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?",0
$S000621 		BYTE 	"El numero de filas de A debe ser igual al numero de columnas de B.",0
$S000618 		BYTE 	"El numero de filas de B debe ser igual al numero de columnas de A.",0
$S000575 		BYTE 	"El numero de filas de B debe ser igual al numero de filas de A.",0
$S000594 		BYTE 	"El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?",0
$S000604 		BYTE 	"Elemento en A[",0
$S000607 		BYTE 	"Elemento en B[",0
$S000630 		BYTE 	"Entrada desconocida. Favor seleccionar una opcion.",0
$S000583 		BYTE 	"Entre las dimensiones de dos matrices:",0Ah,0
$S000584 		BYTE 	"Entre las filas de A: ",0
$S000599 		BYTE 	"Entre los valores para la matriz A[",0
$S000627 		BYTE 	"Esta matriz no se puede trasponer ya que no es cuadrada.",0
$S000626 		BYTE 	"La Traspuesta de la matriz es:",0
$S000617 		BYTE 	"La matriz resultado C = A*B es:",0Ah,0
$S000620 		BYTE 	"La matriz resultado C = B*A es:",0Ah,0
$S000615 		BYTE 	"La matriz resultado:",0
$S000614 		BYTE 	"Las matrices deben tener las mismas dimensiones para ser sumadas.",0
$S000541 		BYTE 	"M[",0
$S000608 		BYTE 	"Matriz A:",0Ah,0
$S000582 		BYTE 	"Programa de Matrices",0Ah,0Ah,0
$S000586 		BYTE 	0Ah,"Entre las columnas de A: ",0
$S000590 		BYTE 	0Ah,"Entre las columnas de B: ",0
$S000588 		BYTE 	0Ah,"Entre las filas de B: ",0
$S000606 		BYTE 	0Ah,"Entre los valores para la matriz B[",0
$S000623 		BYTE 	0Ah,"La Traza de la matriz es = ",0
$S000609 		BYTE 	0Ah,0Ah,"Matriz B:",0Ah,0
$S000631 		BYTE 	0Ah,0Ah,"Presione una tecla para regresar...",0
$S000610 		BYTE 	0Ah,0Ah,"Que deseas hacer?",0Ah,0
$S000529 		BYTE 	0Ah,"| ",0
$S000605 		BYTE 	"] = ",0
$S000543 		BYTE 	"]= ",0
$S000600 		BYTE 	"][",0
$S000532 		BYTE 	"| ",0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000020h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count

END __System_Hpp_Runtime_Init

