Microsoft (R) Macro Assembler Version 6.15.8803		    03/19/13 15:13:31
TestMatrices.hpp					     Page 1 - 1


				TITLE	 TestMatrices.hpp
				SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


					.486P
					.MODEL flat,stdcall
					.STACK 000100000h
					INCLUDE stdhpp\hcclib32.INC	; the H++ library.
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C ; when the "C" calling convension is used, then we must use :PROC;
			      C ; when the stdcall calling convension is used, we must use :PROTO;
			      C 
			      C EXTERN __purecall: PROTO;
			      C 
			      C ; H++  C O N S O L E   A P I s 
			      C 
			      C EXTERN Console_ClearScreen:PROTO;
			      C EXTERN Console_ReadString:PROTO;
			      C EXTERN Console_ReadChar:PROTO;
			      C EXTERN Console_WriteString:PROTO;
			      C EXTERN Console_WriteCrlf:PROTO;
			      C EXTERN Console_WriteChar:PROTO;
			      C EXTERN Console_SetCursorPos:PROTO;
			      C EXTERN Console_SetTextColor:PROTO;
			      C EXTERN Console_SetConsoleSize:PROTO;
			      C EXTERN Console_SetTitle:PROTO;
			      C EXTERN Console_GetTitle:PROTO;
			      C EXTERN Console_MoveWindow:PROTO;
			      C 
			      C EXTERN Console_ReadDouble:PROTO;
			      C EXTERN Console_ReadInteger:PROTO;
			      C EXTERN Console_WriteDouble:PROTO;
			      C EXTERN Console_WriteInteger:PROTO;
			      C EXTERN Console_WriteInteger64:PROTO;
			      C EXTERN Console_WriteBoolean:PROTO;
			      C 
			      C ; H++  F I L E   A P I s 
			      C 
			      C EXTERN File_Open:PROTO;
			      C EXTERN File_Close:PROTO;
			      C EXTERN File_Read:PROTO;
			      C EXTERN File_Write:PROTO;
			      C EXTERN File_Seek:PROTO;
			      C EXTERN File_FileSize:PROTO;
			      C 
			      C ; H++  S Y S T E M   A P I s 
			      C 
			      C EXTERN System_Exit:PROTO;
			      C EXTERN System_LastError:PROTO;
			      C EXTERN System_CommandLineArgs:PROTO;
			      C EXTERN System_Execute:PROTO;
			      C EXTERN System_GetTickCount:PROTO;
			      C EXTERN System_Sleep:PROTO;
			      C EXTERN System_Debug_OutputString:PROTO;
			      C EXTERN System_BreakPoint:PROTO;
			      C EXTERN System_IsDebuggerPresent:PROTO;
			      C 
			      C ; H++  M A T H   A P I s
			      C 
			      C EXTERN Math_Init:PROTO;
			      C EXTERN Math_Abs:PROTO;
			      C EXTERN Math_ChangeSign:PROTO;
			      C EXTERN Math_Sqrt:PROTO;
			      C EXTERN Math_Sqr:PROTO;
			      C 
			      C EXTERN Math_Sin:PROTO;
			      C EXTERN Math_Cos:PROTO;
			      C EXTERN Math_Tan:PROTO;
			      C EXTERN Math_ArcTan:PROTO;
			      C EXTERN Math_Round:PROTO;
			      C 
			      C EXTERN Math_Modulus:PROTO;
			      C EXTERN Math_IEEEModulus:PROTO;
			      C EXTERN Math_ModulusTruncateDivisor:PROTO;
			      C 
			      C EXTERN Math_Ln:PROTO;
			      C EXTERN Math_log2:PROTO;
			      C EXTERN Math_log10:PROTO;
			      C EXTERN Math_Exp:PROTO;
			      C 
			      C EXTERN Math_MantissaOf:PROTO;
			      C EXTERN Math_GetNumberFrom:PROTO;
			      C EXTERN Math_LogN_base:PROTO;
			      C 
			      C EXTERN Math_Max:PROTO;
			      C EXTERN Math_Min:PROTO;
			      C EXTERN Math_Sign:PROTO;
			      C EXTERN Math_Pow2:PROTO;
			      C EXTERN Math_Pow:PROTO;
			      C EXTERN Math_Gcd:PROTO;
			      C EXTERN Math_Odd:PROTO;
			      C EXTERN Math_Even:PROTO;
			      C EXTERN Math_Trunc:PROTO;
			      C 
			      C ; N O N - I N T R I N S I C   M A T H   F U N C T I O N S 
			      C 
			      C EXTERN Math_Cotan:PROTO;
			      C EXTERN Math_Sec:PROTO;
			      C EXTERN Math_Cosec:PROTO;
			      C EXTERN Math_Inverse_Arcsin:PROTO;
			      C EXTERN Math_Inverse_Arccos:PROTO;
			      C EXTERN Math_Inverse_Arcsec:PROTO;
			      C EXTERN Math_Inverse_Arccosec:PROTO;
			      C EXTERN Math_Inverse_Arccotan:PROTO;
			      C 
			      C ; M A T H   C O N S T A N T S  
			      C EXTERN Math_pi:PROTO;
			      C EXTERN Math_log_10_base2:PROTO;
			      C EXTERN Math_log_e_base2:PROTO;
			      C EXTERN Math_log_2_base10:PROTO;
			      C EXTERN Math_log_2_base_e:PROTO;
			      C 
			      C 
			      C ; I N T E G E R   S P E C I F I C S   ( U T I L I T I E S )
			      C EXTERN Integer_toStringEx:PROTO;
			      C EXTERN Integer_toString:PROTO;
			      C EXTERN Integer_fromString:PROTO;
			      C 
			      C 
			      C ; F L O A T I N G   P O I N T   S P E C I F I C  (U T I L I T I E S )
			      C 
			      C EXTERN FloatingPoint_Compare:PROTO;
			      C EXTERN FloatingPoint_CompareToInteger:PROTO;
			      C EXTERN FloatingPoint_ToInt:PROTO;
			      C EXTERN FloatingPoint_ToInt64:PROTO;
			      C EXTERN FloatingPoint_FromInt:PROTO;
			      C EXTERN FloatingPoint_FromInt64:PROTO;
			      C 
			      C EXTERN FloatingPoint_toString:PROTO;
			      C EXTERN FloatingPoint_toStringEx:PROTO;
			      C EXTERN FloatingPoint_fromString:PROTO;
			      C 
			      C ; H++  S T R I N G  H A N D L I N G   A P I s 
			      C 
			      C EXTERN StringHandling_StringLength2:PROTO;
			      C EXTERN StringHandling_StringLength:PROTO;
			      C EXTERN StringHandling_StringCopy:PROTO;
			      C EXTERN StringHandling_StringCompare:PROTO;
			      C EXTERN StringHandling_StringUCase:PROTO;
			      C EXTERN StringHandling_StringLCase:PROTO;
			      C EXTERN StringHandling_StringSet:PROTO;
			      C 
			      C ; H++  M E M O R Y   H A N D L I N G   A P I s
			      C 
			      C EXTERN System_Memory_Memset:PROTO;
			      C EXTERN System_Memory_GetProcessHeap:PROTO
			      C EXTERN System_Memory_Alloc:PROTO
			      C EXTERN System_Memory_Free:PROTO
			      C EXTERN System_Memory_Size:PROTO
			      C EXTERN System_Memory_New:PROTO
			      C EXTERN System_Memory_Destroy:PROTO
			      C EXTERN System_Memory_SizeFor:PROTO
			      C 
			      C 
			      C EXTERN System_GetCommandLineArgv:PROTO;
			      C 
			      C EXTERN System_ShowMessage:PROTO;
			      C 
			      C EXTERN ConsoleHandle:DWORD;
			      C ;
			      C .LIST
			      C 

				;Windows API prototypes
				GetVersion PROTO

				;This assembly file was generated by the 32-bit H++ Compiler

 00000000			.CODE ;code segment
 00000000			Math_DegreesToRadians PROC NEAR 
				;double Math::DegreesToRadians(double deg);
 00000000  55				push	EBP
 00000001  8B EC			mov	EBP,ESP
 00000003  51				push	ECX 
 00000004  53				push	EBX 
 00000005  56				push	ESI 
 00000006  57				push	EDI 
				;{

				;{389}:return (deg * Math::pi()) / 180
 00000007  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000000A  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000000D  50				push	EAX
 0000000E  52				push	EDX 
 0000000F  E8 00000000 E		call	 Math_pi
 00000014  9B DB E2			fclex
 00000017  50				push	EAX
 00000018  52				push	EDX 
 00000019  DD 04 24			fld	qword ptr [ESP]
 0000001C  59				pop	ECX
 0000001D  59				pop	ECX 
 0000001E  DC 0C 24			fmul	qword ptr [ESP]
 00000021  DD 1C 24			fstp	qword ptr [ESP]
 00000024  B8 000000B4			mov	EAX,0000000B4h
 00000029  9B DB E2			fclex
 0000002C  50				push	EAX
 0000002D  E8 00000000 E		call	 FloatingPoint_FromInt
 00000032  50				push	EAX
 00000033  52				push	EDX 
 00000034  DD 04 24			fld	qword ptr [ESP]
 00000037  59				pop	ECX
 00000038  59				pop	ECX 
 00000039  DC 3C 24			fdivr	qword ptr [ESP]
 0000003C  DD 1C 24			fstp	qword ptr [ESP]
 0000003F  5A				pop	EDX
 00000040  58				pop	EAX 
 00000041  EB 00			jmp	OFFSET $L000469
				;}
 00000043			$L000469:

 00000043  5F				pop	EDI
 00000044  5E				pop	ESI 
 00000045  5B				pop	EBX 
 00000046  8B E5			mov	ESP,EBP
 00000048  5D				pop	EBP 
 00000049  C2 0008			retn	000000008h
 0000004C			Math_DegreesToRadians ENDP

 0000004C			Math_Hyperbolic_HCos PROC NEAR 
				;double Math::Hyperbolic::HCos(double X);
 0000004C  55				push	EBP
 0000004D  8B EC			mov	EBP,ESP
 0000004F  51				push	ECX 
 00000050  53				push	EBX 
 00000051  56				push	ESI 
 00000052  57				push	EDI 
				;{

				;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
 00000053  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000056  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000059  50				push	EAX
 0000005A  52				push	EDX 
 0000005B  E8 00000000 E		call	 Math_Exp
 00000060  50				push	EAX
 00000061  52				push	EDX 
 00000062  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000065  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000068  50				push	EAX
 00000069  52				push	EDX 
 0000006A  DD 04 24			fld	qword ptr [ESP]
 0000006D  D9 E0			fchs
 0000006F  DD 1C 24			fstp	qword ptr [ESP]
 00000072  E8 00000000 E		call	 Math_Exp
 00000077  50				push	EAX
 00000078  52				push	EDX 
 00000079  DD 04 24			fld	qword ptr [ESP]
 0000007C  59				pop	ECX
 0000007D  59				pop	ECX 
 0000007E  DC 04 24			fadd	qword ptr [ESP]
 00000081  DD 1C 24			fstp	qword ptr [ESP]
 00000084  B8 00000002			mov	EAX,000000002h
 00000089  9B DB E2			fclex
 0000008C  50				push	EAX
 0000008D  E8 00000000 E		call	 FloatingPoint_FromInt
 00000092  50				push	EAX
 00000093  52				push	EDX 
 00000094  DD 04 24			fld	qword ptr [ESP]
 00000097  59				pop	ECX
 00000098  59				pop	ECX 
 00000099  DC 3C 24			fdivr	qword ptr [ESP]
 0000009C  DD 1C 24			fstp	qword ptr [ESP]
 0000009F  5A				pop	EDX
 000000A0  58				pop	EAX 
 000000A1  EB 00			jmp	OFFSET $L000486
				;}
 000000A3			$L000486:

 000000A3  5F				pop	EDI
 000000A4  5E				pop	ESI 
 000000A5  5B				pop	EBX 
 000000A6  8B E5			mov	ESP,EBP
 000000A8  5D				pop	EBP 
 000000A9  C2 0008			retn	000000008h
 000000AC			Math_Hyperbolic_HCos ENDP

 000000AC			Math_Hyperbolic_HCosec PROC NEAR 
				;double Math::Hyperbolic::HCosec(double X);
 000000AC  55				push	EBP
 000000AD  8B EC			mov	EBP,ESP
 000000AF  51				push	ECX 
 000000B0  53				push	EBX 
 000000B1  56				push	ESI 
 000000B2  57				push	EDI 
				;{

				;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
 000000B3  B8 00000002			mov	EAX,000000002h
 000000B8  50				push	EAX
 000000B9  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000000BC  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000000BF  50				push	EAX
 000000C0  52				push	EDX 
 000000C1  E8 00000000 E		call	 Math_Exp
 000000C6  50				push	EAX
 000000C7  52				push	EDX 
 000000C8  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000000CB  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000000CE  50				push	EAX
 000000CF  52				push	EDX 
 000000D0  DD 04 24			fld	qword ptr [ESP]
 000000D3  D9 E0			fchs
 000000D5  DD 1C 24			fstp	qword ptr [ESP]
 000000D8  E8 00000000 E		call	 Math_Exp
 000000DD  50				push	EAX
 000000DE  52				push	EDX 
 000000DF  DD 04 24			fld	qword ptr [ESP]
 000000E2  59				pop	ECX
 000000E3  59				pop	ECX 
 000000E4  DD 04 24			fld	qword ptr [ESP]
 000000E7  D8 E1			fsub	st,st(1)
 000000E9  DD 1C 24			fstp	qword ptr [ESP]
 000000EC  9B DB E2			fclex
 000000EF  DD 04 24			fld	qword ptr [ESP]
 000000F2  59				pop	ECX
 000000F3  59				pop	ECX 
 000000F4  E8 00000000 E		call	 FloatingPoint_FromInt
 000000F9  50				push	EAX
 000000FA  52				push	EDX 
 000000FB  DC 3C 24			fdivr	qword ptr [ESP]
 000000FE  DD 1C 24			fstp	qword ptr [ESP]
 00000101  5A				pop	EDX
 00000102  58				pop	EAX 
 00000103  EB 00			jmp	OFFSET $L000492
				;}
 00000105			$L000492:

 00000105  5F				pop	EDI
 00000106  5E				pop	ESI 
 00000107  5B				pop	EBX 
 00000108  8B E5			mov	ESP,EBP
 0000010A  5D				pop	EBP 
 0000010B  C2 0008			retn	000000008h
 0000010E			Math_Hyperbolic_HCosec ENDP

 0000010E			Math_Hyperbolic_HCotan PROC NEAR 
				;double Math::Hyperbolic::HCotan(double X);
 0000010E  55				push	EBP
 0000010F  8B EC			mov	EBP,ESP
 00000111  51				push	ECX 
 00000112  53				push	EBX 
 00000113  56				push	ESI 
 00000114  57				push	EDI 
				;{

				;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
 00000115  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000118  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000011B  50				push	EAX
 0000011C  52				push	EDX 
 0000011D  E8 00000000 E		call	 Math_Exp
 00000122  50				push	EAX
 00000123  52				push	EDX 
 00000124  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000127  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000012A  50				push	EAX
 0000012B  52				push	EDX 
 0000012C  DD 04 24			fld	qword ptr [ESP]
 0000012F  D9 E0			fchs
 00000131  DD 1C 24			fstp	qword ptr [ESP]
 00000134  E8 00000000 E		call	 Math_Exp
 00000139  50				push	EAX
 0000013A  52				push	EDX 
 0000013B  DD 04 24			fld	qword ptr [ESP]
 0000013E  59				pop	ECX
 0000013F  59				pop	ECX 
 00000140  DC 04 24			fadd	qword ptr [ESP]
 00000143  DD 1C 24			fstp	qword ptr [ESP]
 00000146  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000149  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000014C  50				push	EAX
 0000014D  52				push	EDX 
 0000014E  E8 00000000 E		call	 Math_Exp
 00000153  50				push	EAX
 00000154  52				push	EDX 
 00000155  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000158  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000015B  50				push	EAX
 0000015C  52				push	EDX 
 0000015D  DD 04 24			fld	qword ptr [ESP]
 00000160  D9 E0			fchs
 00000162  DD 1C 24			fstp	qword ptr [ESP]
 00000165  E8 00000000 E		call	 Math_Exp
 0000016A  50				push	EAX
 0000016B  52				push	EDX 
 0000016C  DD 04 24			fld	qword ptr [ESP]
 0000016F  59				pop	ECX
 00000170  59				pop	ECX 
 00000171  DD 04 24			fld	qword ptr [ESP]
 00000174  D8 E1			fsub	st,st(1)
 00000176  DD 1C 24			fstp	qword ptr [ESP]
 00000179  9B DB E2			fclex
 0000017C  DD 04 24			fld	qword ptr [ESP]
 0000017F  59				pop	ECX
 00000180  59				pop	ECX 
 00000181  DC 3C 24			fdivr	qword ptr [ESP]
 00000184  DD 1C 24			fstp	qword ptr [ESP]
 00000187  5A				pop	EDX
 00000188  58				pop	EAX 
 00000189  EB 00			jmp	OFFSET $L000494
				;}
 0000018B			$L000494:

 0000018B  5F				pop	EDI
 0000018C  5E				pop	ESI 
 0000018D  5B				pop	EBX 
 0000018E  8B E5			mov	ESP,EBP
 00000190  5D				pop	EBP 
 00000191  C2 0008			retn	000000008h
 00000194			Math_Hyperbolic_HCotan ENDP

 00000194			Math_Hyperbolic_HSec PROC NEAR 
				;double Math::Hyperbolic::HSec(double X);
 00000194  55				push	EBP
 00000195  8B EC			mov	EBP,ESP
 00000197  51				push	ECX 
 00000198  53				push	EBX 
 00000199  56				push	ESI 
 0000019A  57				push	EDI 
				;{

				;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
 0000019B  B8 00000002			mov	EAX,000000002h
 000001A0  50				push	EAX
 000001A1  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000001A4  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000001A7  50				push	EAX
 000001A8  52				push	EDX 
 000001A9  E8 00000000 E		call	 Math_Exp
 000001AE  50				push	EAX
 000001AF  52				push	EDX 
 000001B0  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000001B3  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000001B6  50				push	EAX
 000001B7  52				push	EDX 
 000001B8  DD 04 24			fld	qword ptr [ESP]
 000001BB  D9 E0			fchs
 000001BD  DD 1C 24			fstp	qword ptr [ESP]
 000001C0  E8 00000000 E		call	 Math_Exp
 000001C5  50				push	EAX
 000001C6  52				push	EDX 
 000001C7  DD 04 24			fld	qword ptr [ESP]
 000001CA  59				pop	ECX
 000001CB  59				pop	ECX 
 000001CC  DC 04 24			fadd	qword ptr [ESP]
 000001CF  DD 1C 24			fstp	qword ptr [ESP]
 000001D2  9B DB E2			fclex
 000001D5  DD 04 24			fld	qword ptr [ESP]
 000001D8  59				pop	ECX
 000001D9  59				pop	ECX 
 000001DA  E8 00000000 E		call	 FloatingPoint_FromInt
 000001DF  50				push	EAX
 000001E0  52				push	EDX 
 000001E1  DC 3C 24			fdivr	qword ptr [ESP]
 000001E4  DD 1C 24			fstp	qword ptr [ESP]
 000001E7  5A				pop	EDX
 000001E8  58				pop	EAX 
 000001E9  EB 00			jmp	OFFSET $L000490
				;}
 000001EB			$L000490:

 000001EB  5F				pop	EDI
 000001EC  5E				pop	ESI 
 000001ED  5B				pop	EBX 
 000001EE  8B E5			mov	ESP,EBP
 000001F0  5D				pop	EBP 
 000001F1  C2 0008			retn	000000008h
 000001F4			Math_Hyperbolic_HSec ENDP

 000001F4			Math_Hyperbolic_HSin PROC NEAR 
				;double Math::Hyperbolic::HSin(double X);
 000001F4  55				push	EBP
 000001F5  8B EC			mov	EBP,ESP
 000001F7  51				push	ECX 
 000001F8  53				push	EBX 
 000001F9  56				push	ESI 
 000001FA  57				push	EDI 
				;{

				;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
 000001FB  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000001FE  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000201  50				push	EAX
 00000202  52				push	EDX 
 00000203  E8 00000000 E		call	 Math_Exp
 00000208  50				push	EAX
 00000209  52				push	EDX 
 0000020A  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000020D  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000210  50				push	EAX
 00000211  52				push	EDX 
 00000212  DD 04 24			fld	qword ptr [ESP]
 00000215  D9 E0			fchs
 00000217  DD 1C 24			fstp	qword ptr [ESP]
 0000021A  E8 00000000 E		call	 Math_Exp
 0000021F  50				push	EAX
 00000220  52				push	EDX 
 00000221  DD 04 24			fld	qword ptr [ESP]
 00000224  59				pop	ECX
 00000225  59				pop	ECX 
 00000226  DD 04 24			fld	qword ptr [ESP]
 00000229  D8 E1			fsub	st,st(1)
 0000022B  DD 1C 24			fstp	qword ptr [ESP]
 0000022E  B8 00000002			mov	EAX,000000002h
 00000233  9B DB E2			fclex
 00000236  50				push	EAX
 00000237  E8 00000000 E		call	 FloatingPoint_FromInt
 0000023C  50				push	EAX
 0000023D  52				push	EDX 
 0000023E  DD 04 24			fld	qword ptr [ESP]
 00000241  59				pop	ECX
 00000242  59				pop	ECX 
 00000243  DC 3C 24			fdivr	qword ptr [ESP]
 00000246  DD 1C 24			fstp	qword ptr [ESP]
 00000249  5A				pop	EDX
 0000024A  58				pop	EAX 
 0000024B  EB 00			jmp	OFFSET $L000483
				;}
 0000024D			$L000483:

 0000024D  5F				pop	EDI
 0000024E  5E				pop	ESI 
 0000024F  5B				pop	EBX 
 00000250  8B E5			mov	ESP,EBP
 00000252  5D				pop	EBP 
 00000253  C2 0008			retn	000000008h
 00000256			Math_Hyperbolic_HSin ENDP

 00000256			Math_Hyperbolic_HTan PROC NEAR 
				;double Math::Hyperbolic::HTan(double X);
 00000256  55				push	EBP
 00000257  8B EC			mov	EBP,ESP
 00000259  51				push	ECX 
 0000025A  53				push	EBX 
 0000025B  56				push	ESI 
 0000025C  57				push	EDI 
				;{

				;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
 0000025D  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000260  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000263  50				push	EAX
 00000264  52				push	EDX 
 00000265  E8 00000000 E		call	 Math_Exp
 0000026A  50				push	EAX
 0000026B  52				push	EDX 
 0000026C  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000026F  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000272  50				push	EAX
 00000273  52				push	EDX 
 00000274  DD 04 24			fld	qword ptr [ESP]
 00000277  D9 E0			fchs
 00000279  DD 1C 24			fstp	qword ptr [ESP]
 0000027C  E8 00000000 E		call	 Math_Exp
 00000281  50				push	EAX
 00000282  52				push	EDX 
 00000283  DD 04 24			fld	qword ptr [ESP]
 00000286  59				pop	ECX
 00000287  59				pop	ECX 
 00000288  DD 04 24			fld	qword ptr [ESP]
 0000028B  D8 E1			fsub	st,st(1)
 0000028D  DD 1C 24			fstp	qword ptr [ESP]
 00000290  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000293  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000296  50				push	EAX
 00000297  52				push	EDX 
 00000298  E8 00000000 E		call	 Math_Exp
 0000029D  50				push	EAX
 0000029E  52				push	EDX 
 0000029F  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000002A2  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000002A5  50				push	EAX
 000002A6  52				push	EDX 
 000002A7  DD 04 24			fld	qword ptr [ESP]
 000002AA  D9 E0			fchs
 000002AC  DD 1C 24			fstp	qword ptr [ESP]
 000002AF  E8 00000000 E		call	 Math_Exp
 000002B4  50				push	EAX
 000002B5  52				push	EDX 
 000002B6  DD 04 24			fld	qword ptr [ESP]
 000002B9  59				pop	ECX
 000002BA  59				pop	ECX 
 000002BB  DC 04 24			fadd	qword ptr [ESP]
 000002BE  DD 1C 24			fstp	qword ptr [ESP]
 000002C1  9B DB E2			fclex
 000002C4  DD 04 24			fld	qword ptr [ESP]
 000002C7  59				pop	ECX
 000002C8  59				pop	ECX 
 000002C9  DC 3C 24			fdivr	qword ptr [ESP]
 000002CC  DD 1C 24			fstp	qword ptr [ESP]
 000002CF  5A				pop	EDX
 000002D0  58				pop	EAX 
 000002D1  EB 00			jmp	OFFSET $L000488
				;}
 000002D3			$L000488:

 000002D3  5F				pop	EDI
 000002D4  5E				pop	ESI 
 000002D5  5B				pop	EBX 
 000002D6  8B E5			mov	ESP,EBP
 000002D8  5D				pop	EBP 
 000002D9  C2 0008			retn	000000008h
 000002DC			Math_Hyperbolic_HTan ENDP

 000002DC			Math_Hyperbolic_Inverse_HArccos PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArccos(double X);
 000002DC  55				push	EBP
 000002DD  8B EC			mov	EBP,ESP
 000002DF  51				push	ECX 
 000002E0  53				push	EBX 
 000002E1  56				push	ESI 
 000002E2  57				push	EDI 
				;{

				;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
 000002E3  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000002E6  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000002E9  50				push	EAX
 000002EA  52				push	EDX 
 000002EB  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000002EE  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000002F1  50				push	EAX
 000002F2  52				push	EDX 
 000002F3  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000002F6  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000002F9  9B DB E2			fclex
 000002FC  50				push	EAX
 000002FD  52				push	EDX 
 000002FE  DD 04 24			fld	qword ptr [ESP]
 00000301  59				pop	ECX
 00000302  59				pop	ECX 
 00000303  DC 0C 24			fmul	qword ptr [ESP]
 00000306  DD 1C 24			fstp	qword ptr [ESP]
 00000309  B8 00000001			mov	EAX,000000001h
 0000030E  50				push	EAX
 0000030F  E8 00000000 E		call	 FloatingPoint_FromInt
 00000314  50				push	EAX
 00000315  52				push	EDX 
 00000316  DD 04 24			fld	qword ptr [ESP]
 00000319  59				pop	ECX
 0000031A  59				pop	ECX 
 0000031B  DD 04 24			fld	qword ptr [ESP]
 0000031E  D8 E1			fsub	st,st(1)
 00000320  DD 1C 24			fstp	qword ptr [ESP]
 00000323  E8 00000000 E		call	 Math_Sqrt
 00000328  50				push	EAX
 00000329  52				push	EDX 
 0000032A  DD 04 24			fld	qword ptr [ESP]
 0000032D  59				pop	ECX
 0000032E  59				pop	ECX 
 0000032F  DC 04 24			fadd	qword ptr [ESP]
 00000332  DD 1C 24			fstp	qword ptr [ESP]
 00000335  E8 00000000 E		call	 Math_Ln
 0000033A  EB 00			jmp	OFFSET $L000500
				;}
 0000033C			$L000500:

 0000033C  5F				pop	EDI
 0000033D  5E				pop	ESI 
 0000033E  5B				pop	EBX 
 0000033F  8B E5			mov	ESP,EBP
 00000341  5D				pop	EBP 
 00000342  C2 0008			retn	000000008h
 00000345			Math_Hyperbolic_Inverse_HArccos ENDP

 00000345			Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArccosec(double X);
 00000345  55				push	EBP
 00000346  8B EC			mov	EBP,ESP
 00000348  51				push	ECX 
 00000349  53				push	EBX 
 0000034A  56				push	ESI 
 0000034B  57				push	EDI 
				;{

				;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
 0000034C  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000034F  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000352  50				push	EAX
 00000353  52				push	EDX 
 00000354  E8 00000000 E		call	 Math_Sign
 00000359  50				push	EAX
 0000035A  52				push	EDX 
 0000035B  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000035E  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000361  50				push	EAX
 00000362  52				push	EDX 
 00000363  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000366  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000369  9B DB E2			fclex
 0000036C  50				push	EAX
 0000036D  52				push	EDX 
 0000036E  DD 04 24			fld	qword ptr [ESP]
 00000371  59				pop	ECX
 00000372  59				pop	ECX 
 00000373  DC 0C 24			fmul	qword ptr [ESP]
 00000376  DD 1C 24			fstp	qword ptr [ESP]
 00000379  B8 00000001			mov	EAX,000000001h
 0000037E  50				push	EAX
 0000037F  E8 00000000 E		call	 FloatingPoint_FromInt
 00000384  50				push	EAX
 00000385  52				push	EDX 
 00000386  DD 04 24			fld	qword ptr [ESP]
 00000389  59				pop	ECX
 0000038A  59				pop	ECX 
 0000038B  DC 04 24			fadd	qword ptr [ESP]
 0000038E  DD 1C 24			fstp	qword ptr [ESP]
 00000391  E8 00000000 E		call	 Math_Sqrt
 00000396  9B DB E2			fclex
 00000399  50				push	EAX
 0000039A  52				push	EDX 
 0000039B  DD 04 24			fld	qword ptr [ESP]
 0000039E  59				pop	ECX
 0000039F  59				pop	ECX 
 000003A0  DC 0C 24			fmul	qword ptr [ESP]
 000003A3  DD 1C 24			fstp	qword ptr [ESP]
 000003A6  B8 00000001			mov	EAX,000000001h
 000003AB  50				push	EAX
 000003AC  E8 00000000 E		call	 FloatingPoint_FromInt
 000003B1  50				push	EAX
 000003B2  52				push	EDX 
 000003B3  DD 04 24			fld	qword ptr [ESP]
 000003B6  59				pop	ECX
 000003B7  59				pop	ECX 
 000003B8  DC 04 24			fadd	qword ptr [ESP]
 000003BB  DD 1C 24			fstp	qword ptr [ESP]
 000003BE  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000003C1  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000003C4  9B DB E2			fclex
 000003C7  50				push	EAX
 000003C8  52				push	EDX 
 000003C9  DD 04 24			fld	qword ptr [ESP]
 000003CC  59				pop	ECX
 000003CD  59				pop	ECX 
 000003CE  DC 3C 24			fdivr	qword ptr [ESP]
 000003D1  DD 1C 24			fstp	qword ptr [ESP]
 000003D4  E8 00000000 E		call	 Math_Ln
 000003D9  EB 00			jmp	OFFSET $L000506
				;}
 000003DB			$L000506:

 000003DB  5F				pop	EDI
 000003DC  5E				pop	ESI 
 000003DD  5B				pop	EBX 
 000003DE  8B E5			mov	ESP,EBP
 000003E0  5D				pop	EBP 
 000003E1  C2 0008			retn	000000008h
 000003E4			Math_Hyperbolic_Inverse_HArccosec ENDP

 000003E4			Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArccotan(double X);
 000003E4  55				push	EBP
 000003E5  8B EC			mov	EBP,ESP
 000003E7  51				push	ECX 
 000003E8  53				push	EBX 
 000003E9  56				push	ESI 
 000003EA  57				push	EDI 
				;{

				;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
 000003EB  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000003EE  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000003F1  50				push	EAX
 000003F2  52				push	EDX 
 000003F3  B8 00000001			mov	EAX,000000001h
 000003F8  50				push	EAX
 000003F9  E8 00000000 E		call	 FloatingPoint_FromInt
 000003FE  50				push	EAX
 000003FF  52				push	EDX 
 00000400  DD 04 24			fld	qword ptr [ESP]
 00000403  59				pop	ECX
 00000404  59				pop	ECX 
 00000405  DC 04 24			fadd	qword ptr [ESP]
 00000408  DD 1C 24			fstp	qword ptr [ESP]
 0000040B  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000040E  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000411  50				push	EAX
 00000412  52				push	EDX 
 00000413  B8 00000001			mov	EAX,000000001h
 00000418  50				push	EAX
 00000419  E8 00000000 E		call	 FloatingPoint_FromInt
 0000041E  50				push	EAX
 0000041F  52				push	EDX 
 00000420  DD 04 24			fld	qword ptr [ESP]
 00000423  59				pop	ECX
 00000424  59				pop	ECX 
 00000425  DD 04 24			fld	qword ptr [ESP]
 00000428  D8 E1			fsub	st,st(1)
 0000042A  DD 1C 24			fstp	qword ptr [ESP]
 0000042D  9B DB E2			fclex
 00000430  DD 04 24			fld	qword ptr [ESP]
 00000433  59				pop	ECX
 00000434  59				pop	ECX 
 00000435  DC 3C 24			fdivr	qword ptr [ESP]
 00000438  DD 1C 24			fstp	qword ptr [ESP]
 0000043B  E8 00000000 E		call	 Math_Ln
 00000440  50				push	EAX
 00000441  52				push	EDX 
 00000442  B8 00000002			mov	EAX,000000002h
 00000447  9B DB E2			fclex
 0000044A  50				push	EAX
 0000044B  E8 00000000 E		call	 FloatingPoint_FromInt
 00000450  50				push	EAX
 00000451  52				push	EDX 
 00000452  DD 04 24			fld	qword ptr [ESP]
 00000455  59				pop	ECX
 00000456  59				pop	ECX 
 00000457  DC 3C 24			fdivr	qword ptr [ESP]
 0000045A  DD 1C 24			fstp	qword ptr [ESP]
 0000045D  5A				pop	EDX
 0000045E  58				pop	EAX 
 0000045F  EB 00			jmp	OFFSET $L000508
				;}
 00000461			$L000508:

 00000461  5F				pop	EDI
 00000462  5E				pop	ESI 
 00000463  5B				pop	EBX 
 00000464  8B E5			mov	ESP,EBP
 00000466  5D				pop	EBP 
 00000467  C2 0008			retn	000000008h
 0000046A			Math_Hyperbolic_Inverse_HArccotan ENDP

 0000046A			Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArcsec(double X);
 0000046A  55				push	EBP
 0000046B  8B EC			mov	EBP,ESP
 0000046D  51				push	ECX 
 0000046E  53				push	EBX 
 0000046F  56				push	ESI 
 00000470  57				push	EDI 
				;{

				;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
 00000471  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000474  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000477  50				push	EAX
 00000478  52				push	EDX 
 00000479  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000047C  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000047F  9B DB E2			fclex
 00000482  50				push	EAX
 00000483  52				push	EDX 
 00000484  DD 04 24			fld	qword ptr [ESP]
 00000487  59				pop	ECX
 00000488  59				pop	ECX 
 00000489  DC 0C 24			fmul	qword ptr [ESP]
 0000048C  DD 1C 24			fstp	qword ptr [ESP]
 0000048F  DD 04 24			fld	qword ptr [ESP]
 00000492  D9 E0			fchs
 00000494  DD 1C 24			fstp	qword ptr [ESP]
 00000497  B8 00000001			mov	EAX,000000001h
 0000049C  50				push	EAX
 0000049D  E8 00000000 E		call	 FloatingPoint_FromInt
 000004A2  50				push	EAX
 000004A3  52				push	EDX 
 000004A4  DD 04 24			fld	qword ptr [ESP]
 000004A7  59				pop	ECX
 000004A8  59				pop	ECX 
 000004A9  DC 04 24			fadd	qword ptr [ESP]
 000004AC  DD 1C 24			fstp	qword ptr [ESP]
 000004AF  E8 00000000 E		call	 Math_Sqrt
 000004B4  50				push	EAX
 000004B5  52				push	EDX 
 000004B6  B8 00000001			mov	EAX,000000001h
 000004BB  50				push	EAX
 000004BC  E8 00000000 E		call	 FloatingPoint_FromInt
 000004C1  50				push	EAX
 000004C2  52				push	EDX 
 000004C3  DD 04 24			fld	qword ptr [ESP]
 000004C6  59				pop	ECX
 000004C7  59				pop	ECX 
 000004C8  DC 04 24			fadd	qword ptr [ESP]
 000004CB  DD 1C 24			fstp	qword ptr [ESP]
 000004CE  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000004D1  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 000004D4  9B DB E2			fclex
 000004D7  50				push	EAX
 000004D8  52				push	EDX 
 000004D9  DD 04 24			fld	qword ptr [ESP]
 000004DC  59				pop	ECX
 000004DD  59				pop	ECX 
 000004DE  DC 3C 24			fdivr	qword ptr [ESP]
 000004E1  DD 1C 24			fstp	qword ptr [ESP]
 000004E4  E8 00000000 E		call	 Math_Ln
 000004E9  EB 00			jmp	OFFSET $L000504
				;}
 000004EB			$L000504:

 000004EB  5F				pop	EDI
 000004EC  5E				pop	ESI 
 000004ED  5B				pop	EBX 
 000004EE  8B E5			mov	ESP,EBP
 000004F0  5D				pop	EBP 
 000004F1  C2 0008			retn	000000008h
 000004F4			Math_Hyperbolic_Inverse_HArcsec ENDP

 000004F4			Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArcsin(double X);
 000004F4  55				push	EBP
 000004F5  8B EC			mov	EBP,ESP
 000004F7  51				push	ECX 
 000004F8  53				push	EBX 
 000004F9  56				push	ESI 
 000004FA  57				push	EDI 
				;{

				;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
 000004FB  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 000004FE  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000501  50				push	EAX
 00000502  52				push	EDX 
 00000503  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 00000506  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000509  50				push	EAX
 0000050A  52				push	EDX 
 0000050B  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000050E  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000511  9B DB E2			fclex
 00000514  50				push	EAX
 00000515  52				push	EDX 
 00000516  DD 04 24			fld	qword ptr [ESP]
 00000519  59				pop	ECX
 0000051A  59				pop	ECX 
 0000051B  DC 0C 24			fmul	qword ptr [ESP]
 0000051E  DD 1C 24			fstp	qword ptr [ESP]
 00000521  B8 00000001			mov	EAX,000000001h
 00000526  50				push	EAX
 00000527  E8 00000000 E		call	 FloatingPoint_FromInt
 0000052C  50				push	EAX
 0000052D  52				push	EDX 
 0000052E  DD 04 24			fld	qword ptr [ESP]
 00000531  59				pop	ECX
 00000532  59				pop	ECX 
 00000533  DC 04 24			fadd	qword ptr [ESP]
 00000536  DD 1C 24			fstp	qword ptr [ESP]
 00000539  E8 00000000 E		call	 Math_Sqrt
 0000053E  50				push	EAX
 0000053F  52				push	EDX 
 00000540  DD 04 24			fld	qword ptr [ESP]
 00000543  59				pop	ECX
 00000544  59				pop	ECX 
 00000545  DC 04 24			fadd	qword ptr [ESP]
 00000548  DD 1C 24			fstp	qword ptr [ESP]
 0000054B  E8 00000000 E		call	 Math_Ln
 00000550  EB 00			jmp	OFFSET $L000497
				;}
 00000552			$L000497:

 00000552  5F				pop	EDI
 00000553  5E				pop	ESI 
 00000554  5B				pop	EBX 
 00000555  8B E5			mov	ESP,EBP
 00000557  5D				pop	EBP 
 00000558  C2 0008			retn	000000008h
 0000055B			Math_Hyperbolic_Inverse_HArcsin ENDP

 0000055B			Math_Hyperbolic_Inverse_HArctan PROC NEAR 
				;double Math::Hyperbolic::Inverse::HArctan(double X);
 0000055B  55				push	EBP
 0000055C  8B EC			mov	EBP,ESP
 0000055E  51				push	ECX 
 0000055F  53				push	EBX 
 00000560  56				push	ESI 
 00000561  57				push	EDI 
				;{

				;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
 00000562  B8 00000001			mov	EAX,000000001h
 00000567  50				push	EAX
 00000568  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000056B  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000056E  50				push	EAX
 0000056F  52				push	EDX 
 00000570  DD 04 24			fld	qword ptr [ESP]
 00000573  59				pop	ECX
 00000574  59				pop	ECX 
 00000575  E8 00000000 E		call	 FloatingPoint_FromInt
 0000057A  50				push	EAX
 0000057B  52				push	EDX 
 0000057C  DC 04 24			fadd	qword ptr [ESP]
 0000057F  DD 1C 24			fstp	qword ptr [ESP]
 00000582  B8 00000001			mov	EAX,000000001h
 00000587  50				push	EAX
 00000588  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000058B  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 0000058E  50				push	EAX
 0000058F  52				push	EDX 
 00000590  DD 04 24			fld	qword ptr [ESP]
 00000593  59				pop	ECX
 00000594  59				pop	ECX 
 00000595  E8 00000000 E		call	 FloatingPoint_FromInt
 0000059A  50				push	EAX
 0000059B  52				push	EDX 
 0000059C  DD 04 24			fld	qword ptr [ESP]
 0000059F  D8 E1			fsub	st,st(1)
 000005A1  DD 1C 24			fstp	qword ptr [ESP]
 000005A4  9B DB E2			fclex
 000005A7  DD 04 24			fld	qword ptr [ESP]
 000005AA  59				pop	ECX
 000005AB  59				pop	ECX 
 000005AC  DC 3C 24			fdivr	qword ptr [ESP]
 000005AF  DD 1C 24			fstp	qword ptr [ESP]
 000005B2  E8 00000000 E		call	 Math_Ln
 000005B7  50				push	EAX
 000005B8  52				push	EDX 
 000005B9  B8 00000002			mov	EAX,000000002h
 000005BE  9B DB E2			fclex
 000005C1  50				push	EAX
 000005C2  E8 00000000 E		call	 FloatingPoint_FromInt
 000005C7  50				push	EAX
 000005C8  52				push	EDX 
 000005C9  DD 04 24			fld	qword ptr [ESP]
 000005CC  59				pop	ECX
 000005CD  59				pop	ECX 
 000005CE  DC 3C 24			fdivr	qword ptr [ESP]
 000005D1  DD 1C 24			fstp	qword ptr [ESP]
 000005D4  5A				pop	EDX
 000005D5  58				pop	EAX 
 000005D6  EB 00			jmp	OFFSET $L000502
				;}
 000005D8			$L000502:

 000005D8  5F				pop	EDI
 000005D9  5E				pop	ESI 
 000005DA  5B				pop	EBX 
 000005DB  8B E5			mov	ESP,EBP
 000005DD  5D				pop	EBP 
 000005DE  C2 0008			retn	000000008h
 000005E1			Math_Hyperbolic_Inverse_HArctan ENDP

 000005E1			Math_RadiansToDegrees PROC NEAR 
				;double Math::RadiansToDegrees(double rad);
 000005E1  55				push	EBP
 000005E2  8B EC			mov	EBP,ESP
 000005E4  51				push	ECX 
 000005E5  53				push	EBX 
 000005E6  56				push	ESI 
 000005E7  57				push	EDI 
				;{

				;{384}:return (180 / Math::pi()) * rad
 000005E8  B8 000000B4			mov	EAX,0000000B4h
 000005ED  50				push	EAX
 000005EE  E8 00000000 E		call	 Math_pi
 000005F3  9B DB E2			fclex
 000005F6  50				push	EAX
 000005F7  52				push	EDX 
 000005F8  DD 04 24			fld	qword ptr [ESP]
 000005FB  59				pop	ECX
 000005FC  59				pop	ECX 
 000005FD  E8 00000000 E		call	 FloatingPoint_FromInt
 00000602  50				push	EAX
 00000603  52				push	EDX 
 00000604  DC 3C 24			fdivr	qword ptr [ESP]
 00000607  DD 1C 24			fstp	qword ptr [ESP]
 0000060A  8B 55 08			mov	EDX,dword ptr [EBP+0008h]
 0000060D  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch] 
 00000610  9B DB E2			fclex
 00000613  50				push	EAX
 00000614  52				push	EDX 
 00000615  DD 04 24			fld	qword ptr [ESP]
 00000618  59				pop	ECX
 00000619  59				pop	ECX 
 0000061A  DC 0C 24			fmul	qword ptr [ESP]
 0000061D  DD 1C 24			fstp	qword ptr [ESP]
 00000620  5A				pop	EDX
 00000621  58				pop	EAX 
 00000622  EB 00			jmp	OFFSET $L000466
				;}
 00000624			$L000466:

 00000624  5F				pop	EDI
 00000625  5E				pop	ESI 
 00000626  5B				pop	EBX 
 00000627  8B E5			mov	ESP,EBP
 00000629  5D				pop	EBP 
 0000062A  C2 0008			retn	000000008h
 0000062D			Math_RadiansToDegrees ENDP

 0000062D			Program_CalcTrace PROC NEAR 
				;double Program::CalcTrace(double double [][] M, int rM, int cM);
 0000062D  55				push	EBP
 0000062E  8B EC			mov	EBP,ESP
 00000630  83 EC 14			sub	ESP,000000014h
 00000633  53				push	EBX 
 00000634  56				push	ESI 
 00000635  57				push	EDI 
				;{

				;{20}:Tr= 0.0;
 00000636  D9 EE			fldz
 00000638  DD 5D F8			fstp	qword ptr [EBP-0008h]

				;{21}:n= min(rM, cM);
 0000063B  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 0000063E  50				push	EAX
 0000063F  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000642  5B				pop	EBX
 00000643  2B D8			sub	EBX,EAX
 00000645  1B C9			sbb	ECX,ECX
 00000647  23 CB			and	ECX,EBX
 00000649  03 C1			add	EAX,ECX
 0000064B  89 45 F4			mov	dword ptr [EBP-000Ch],EAX

				;{22}:for(i= 0; i < n; i++ )
 0000064E  33 C0			xor	EAX,EAX
 00000650  89 45 F0			mov	dword ptr [EBP-0010h],EAX
 00000653  EB 06			jmp	OFFSET $L000633
 00000655			$L000634:
 00000655  8B 45 F0			mov	EAX,dword ptr [EBP-16]
 00000658  FF 45 F0			inc	dword ptr [EBP-16]
 0000065B			$L000633:
 0000065B  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 0000065E  50				push	EAX
 0000065F  8B 45 F4			mov	EAX,dword ptr [EBP-000Ch]
 00000662  5A				pop	EDX
 00000663  3B D0			cmp	EDX,EAX
 00000665  0F 9C C0			setl	AL
 00000668  84 C0			test	AL,AL
 0000066A  0F 84 0000009B		jz	OFFSET $L000635
				;{

				;{23}:Console::WriteLn("M[", i, ",", i, "]= ", M[i][i]);
 00000670  8D 05 00000444 R		lea	EAX,OFFSET $S000541
 00000676  6A 00			push	000000000h
 00000678  50				push	EAX 
 00000679  E8 00000000 E		call	 Console_WriteString
 0000067E  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000681  50				push	EAX 
 00000682  E8 00000000 E		call	 Console_WriteInteger 
 00000687  B8 0000002C			mov	EAX,00000002Ch
 0000068C  50				push	EAX 
 0000068D  E8 00000000 E		call	 Console_WriteChar 
 00000692  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 00000695  50				push	EAX 
 00000696  E8 00000000 E		call	 Console_WriteInteger 
 0000069B  8D 05 0000054A R		lea	EAX,OFFSET $S000543
 000006A1  6A 00			push	000000000h 
 000006A3  50				push	EAX 
 000006A4  E8 00000000 E		call	 Console_WriteString 
 000006A9  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 000006AC  8B C3			mov	EAX,EBX 
 000006AE  50				push	EAX
 000006AF  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 000006B2  6B C0 0A			imul	EAX,EAX,00000000Ah
 000006B5  8B F0			mov	ESI,EAX
 000006B7  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 000006BA  03 C6			add	EAX,ESI
 000006BC  5E				pop	ESI
 000006BD  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 000006C0  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 000006C7  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 000006CA  50				push	EAX 
 000006CB  52				push	EDX 
 000006CC  E8 00000000 E		call	 Console_WriteDouble 
 000006D1  E8 00000000 E		call	 Console_WriteCrLf 

				;{24}:Tr+= M[i][i];
 000006D6  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 000006D9  8B C3			mov	EAX,EBX 
 000006DB  50				push	EAX
 000006DC  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 000006DF  6B C0 0A			imul	EAX,EAX,00000000Ah
 000006E2  8B F0			mov	ESI,EAX
 000006E4  8B 45 F0			mov	EAX,dword ptr [EBP-0010h]
 000006E7  03 C6			add	EAX,ESI
 000006E9  5E				pop	ESI
 000006EA  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 000006ED  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 000006F4  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 000006F7  F8				clc	
 000006F8  50				push	EAX
 000006F9  52				push	EDX 
 000006FA  DD 04 24			fld	qword ptr [ESP]
 000006FD  5A				pop	EDX
 000006FE  58				pop	EAX 
 000006FF  8D 5D F8			lea	EBX,dword ptr [EBP-0008h]
 00000702  DC 03			fadd	qword ptr [EBX]
 00000704  DD 1B			fstp	qword ptr [EBX]
				;}
 00000706  E9 FFFFFF4A			jmp	OFFSET $L000634 
 0000070B			$L000635:

				;{26}:return Tr
 0000070B  8B 55 F8			mov	EDX,dword ptr [EBP-0008h]
 0000070E  8B 45 FC			mov	EAX,dword ptr [EBP-0004h] 
 00000711  EB 00			jmp	OFFSET $L000533
				;}
 00000713			$L000533:

 00000713  5F				pop	EDI
 00000714  5E				pop	ESI 
 00000715  5B				pop	EBX 
 00000716  8B E5			mov	ESP,EBP
 00000718  5D				pop	EBP 
 00000719  C2 000C			retn	00000000Ch
 0000071C			Program_CalcTrace ENDP

 0000071C			Program_MultiplyMatrices PROC NEAR 
				;void Program::MultiplyMatrices(double double [][] A, double double [][] B, int rA, int cA, int rB, int cB);
 0000071C  55				push	EBP
 0000071D  8B EC			mov	EBP,ESP
 0000071F  81 EC 00000330		sub	ESP,000000330h
 00000725  53				push	EBX 
 00000726  56				push	ESI 
 00000727  57				push	EDI 
				;{

				;{73}:Res;
 00000728  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]

				;{74}:if(cA == rB)
 0000072E  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000731  50				push	EAX
 00000732  8B 45 18			mov	EAX,dword ptr [EBP+0018h]
 00000735  5A				pop	EDX
 00000736  3B D0			cmp	EDX,EAX
 00000738  0F 94 C0			setz	AL
 0000073B  84 C0			test	AL,AL
 0000073D  0F 84 000001AF		jz	OFFSET $L000636
				;{

				;{77}:for(i= 0; i < rA; i++ )
 00000743  33 C0			xor	EAX,EAX
 00000745  89 85 FFFFFCDC		mov	dword ptr [EBP-0324h],EAX
 0000074B  EB 0C			jmp	OFFSET $L000638
 0000074D			$L000639:
 0000074D  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-804]
 00000753  FF 85 FFFFFCDC		inc	dword ptr [EBP-804]
 00000759			$L000638:
 00000759  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h]
 0000075F  50				push	EAX
 00000760  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000763  5A				pop	EDX
 00000764  3B D0			cmp	EDX,EAX
 00000766  0F 9C C0			setl	AL
 00000769  84 C0			test	AL,AL
 0000076B  74 4F			jz	OFFSET $L000640

				;{78}:for(j= 0; j < cB; j++ )
 0000076D  33 C0			xor	EAX,EAX
 0000076F  89 85 FFFFFCD8		mov	dword ptr [EBP-0328h],EAX
 00000775  EB 0C			jmp	OFFSET $L000641
 00000777			$L000642:
 00000777  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-808]
 0000077D  FF 85 FFFFFCD8		inc	dword ptr [EBP-808]
 00000783			$L000641:
 00000783  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-0328h]
 00000789  50				push	EAX
 0000078A  8B 45 1C			mov	EAX,dword ptr [EBP+001Ch]
 0000078D  5A				pop	EDX
 0000078E  3B D0			cmp	EDX,EAX
 00000790  0F 9C C0			setl	AL
 00000793  84 C0			test	AL,AL
 00000795  74 23			jz	OFFSET $L000643

				;{79}:Res[i][j]= 0.0;
 00000797  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h]
 0000079D  6B C0 50			imul	EAX,EAX,000000050h
 000007A0  8D 94 28			lea	EDX,dword ptr [EBP+EAX-0320h]
	   FFFFFCE0
 000007A7  52				push	EDX
 000007A8  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-0328h]
 000007AE  5E				pop	ESI
 000007AF  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 000007B2  50				push	EAX
 000007B3  D9 EE			fldz
 000007B5  5B				pop	EBX
 000007B6  DD 1B			fstp	qword ptr [EBX]
 000007B8  EB BD			jmp	OFFSET $L000642 
 000007BA			$L000643:
 000007BA  EB 91			jmp	OFFSET $L000639 
 000007BC			$L000640:

				;{81}:for(i= 0; i < rA; i++ )
 000007BC  33 C0			xor	EAX,EAX
 000007BE  89 85 FFFFFCDC		mov	dword ptr [EBP-0324h],EAX
 000007C4  EB 0C			jmp	OFFSET $L000644
 000007C6			$L000645:
 000007C6  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-804]
 000007CC  FF 85 FFFFFCDC		inc	dword ptr [EBP-804]
 000007D2			$L000644:
 000007D2  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h]
 000007D8  50				push	EAX
 000007D9  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 000007DC  5A				pop	EDX
 000007DD  3B D0			cmp	EDX,EAX
 000007DF  0F 9C C0			setl	AL
 000007E2  84 C0			test	AL,AL
 000007E4  0F 84 000000F2		jz	OFFSET $L000646

				;{82}:for(j= 0; j < cA; j++ )
 000007EA  33 C0			xor	EAX,EAX
 000007EC  89 85 FFFFFCD8		mov	dword ptr [EBP-0328h],EAX
 000007F2  EB 0C			jmp	OFFSET $L000647
 000007F4			$L000648:
 000007F4  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-808]
 000007FA  FF 85 FFFFFCD8		inc	dword ptr [EBP-808]
 00000800			$L000647:
 00000800  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-0328h]
 00000806  50				push	EAX
 00000807  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 0000080A  5A				pop	EDX
 0000080B  3B D0			cmp	EDX,EAX
 0000080D  0F 9C C0			setl	AL
 00000810  84 C0			test	AL,AL
 00000812  0F 84 000000BF		jz	OFFSET $L000649

				;{83}:for(k= 0; k < cA; k++ )
 00000818  33 C0			xor	EAX,EAX
 0000081A  89 85 FFFFFCD4		mov	dword ptr [EBP-032Ch],EAX
 00000820  EB 0C			jmp	OFFSET $L000650
 00000822			$L000651:
 00000822  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-812]
 00000828  FF 85 FFFFFCD4		inc	dword ptr [EBP-812]
 0000082E			$L000650:
 0000082E  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 00000834  50				push	EAX
 00000835  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000838  5A				pop	EDX
 00000839  3B D0			cmp	EDX,EAX
 0000083B  0F 9C C0			setl	AL
 0000083E  84 C0			test	AL,AL
 00000840  0F 84 0000008C		jz	OFFSET $L000652

				;{84}:Res[i][j]+= A[i][k] * B[k][j];
 00000846  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h]
 0000084C  6B C0 50			imul	EAX,EAX,000000050h
 0000084F  8D 94 28			lea	EDX,dword ptr [EBP+EAX-0320h]
	   FFFFFCE0
 00000856  52				push	EDX
 00000857  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-0328h]
 0000085D  5E				pop	ESI
 0000085E  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 00000861  50				push	EAX
 00000862  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000865  8B C3			mov	EAX,EBX 
 00000867  50				push	EAX
 00000868  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h]
 0000086E  6B C0 0A			imul	EAX,EAX,00000000Ah
 00000871  8B F0			mov	ESI,EAX
 00000873  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 00000879  03 C6			add	EAX,ESI
 0000087B  5E				pop	ESI
 0000087C  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 0000087F  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000886  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000889  50				push	EAX
 0000088A  52				push	EDX 
 0000088B  8B 5D 0C			mov	EBX,dword ptr [EBP+000Ch]
 0000088E  8B C3			mov	EAX,EBX 
 00000890  50				push	EAX
 00000891  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 00000897  6B C0 0A			imul	EAX,EAX,00000000Ah
 0000089A  8B F0			mov	ESI,EAX
 0000089C  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-0328h]
 000008A2  03 C6			add	EAX,ESI
 000008A4  5E				pop	ESI
 000008A5  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 000008A8  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 000008AF  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 000008B2  9B DB E2			fclex
 000008B5  50				push	EAX
 000008B6  52				push	EDX 
 000008B7  DD 04 24			fld	qword ptr [ESP]
 000008BA  59				pop	ECX
 000008BB  59				pop	ECX 
 000008BC  DC 0C 24			fmul	qword ptr [ESP]
 000008BF  DD 1C 24			fstp	qword ptr [ESP]
 000008C2  F8				clc	
 000008C3  DD 04 24			fld	qword ptr [ESP]
 000008C6  5A				pop	EDX
 000008C7  58				pop	EAX 
 000008C8  5B				pop	EBX
 000008C9  DC 03			fadd	qword ptr [EBX]
 000008CB  DD 1B			fstp	qword ptr [EBX]
 000008CD  E9 FFFFFF50			jmp	OFFSET $L000651 
 000008D2			$L000652:
 000008D2  E9 FFFFFF1D			jmp	OFFSET $L000648 
 000008D7			$L000649:
 000008D7  E9 FFFFFEEA			jmp	OFFSET $L000645 
 000008DC			$L000646:

				;{86}:Program::ShowMatrixForm(Res, rA, cB);
 000008DC  8B 45 1C			mov	EAX,dword ptr [EBP+001Ch]
 000008DF  50				push	EAX 
 000008E0  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 000008E3  50				push	EAX 
 000008E4  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 000008EA  50				push	EAX
 000008EB  E8 0000001E			call	 Program_ShowMatrixForm
				;}
 000008F0  EB 13			jmp	OFFSET $L000637

				; else {
 000008F2			$L000636:

				;{88}:Console::WriteLn("El numero de filas de B debe ser igual al numero de filas de A.");
 000008F2  8D 05 00000200 R		lea	EAX,OFFSET $S000575
 000008F8  6A 00			push	000000000h
 000008FA  50				push	EAX 
 000008FB  E8 00000000 E		call	 Console_WriteString
 00000900  E8 00000000 E		call	 Console_WriteCrLf 
 00000905			$L000637:

				; }
				;}
 00000905			$L000564:

 00000905  5F				pop	EDI
 00000906  5E				pop	ESI 
 00000907  5B				pop	EBX 
 00000908  8B E5			mov	ESP,EBP
 0000090A  5D				pop	EBP 
 0000090B  C2 0018			retn	000000018h
 0000090E			Program_MultiplyMatrices ENDP

 0000090E			Program_ShowMatrixForm PROC NEAR 
				;void Program::ShowMatrixForm(double double [][] M, int rM, int cM);
 0000090E  55				push	EBP
 0000090F  8B EC			mov	EBP,ESP
 00000911  83 EC 0C			sub	ESP,00000000Ch
 00000914  53				push	EBX 
 00000915  56				push	ESI 
 00000916  57				push	EDI 
				;{

				;{11}:for(i= 0; i < rM; i++ )
 00000917  33 C0			xor	EAX,EAX
 00000919  89 45 FC			mov	dword ptr [EBP-0004h],EAX
 0000091C  EB 06			jmp	OFFSET $L000653
 0000091E			$L000654:
 0000091E  8B 45 FC			mov	EAX,dword ptr [EBP-4]
 00000921  FF 45 FC			inc	dword ptr [EBP-4]
 00000924			$L000653:
 00000924  8B 45 FC			mov	EAX,dword ptr [EBP-0004h]
 00000927  50				push	EAX
 00000928  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 0000092B  5A				pop	EDX
 0000092C  3B D0			cmp	EDX,EAX
 0000092E  0F 9C C0			setl	AL
 00000931  84 C0			test	AL,AL
 00000933  74 77			jz	OFFSET $L000655
				;{

				;{12}:Console::Write("\n| ");
 00000935  8D 05 00000541 R		lea	EAX,OFFSET $S000529
 0000093B  6A 00			push	000000000h
 0000093D  50				push	EAX 
 0000093E  E8 00000000 E		call	 Console_WriteString

				;{13}:for(j= 0; j < cM; j++ )
 00000943  33 C0			xor	EAX,EAX
 00000945  89 45 F8			mov	dword ptr [EBP-0008h],EAX
 00000948  EB 06			jmp	OFFSET $L000656
 0000094A			$L000657:
 0000094A  8B 45 F8			mov	EAX,dword ptr [EBP-8]
 0000094D  FF 45 F8			inc	dword ptr [EBP-8]
 00000950			$L000656:
 00000950  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000953  50				push	EAX
 00000954  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000957  5A				pop	EDX
 00000958  3B D0			cmp	EDX,EAX
 0000095A  0F 9C C0			setl	AL
 0000095D  84 C0			test	AL,AL
 0000095F  74 38			jz	OFFSET $L000658

				;{14}:Console::Write(M[i][j], "  ");
 00000961  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000964  8B C3			mov	EAX,EBX 
 00000966  50				push	EAX
 00000967  8B 45 FC			mov	EAX,dword ptr [EBP-0004h]
 0000096A  6B C0 0A			imul	EAX,EAX,00000000Ah
 0000096D  8B F0			mov	ESI,EAX
 0000096F  8B 45 F8			mov	EAX,dword ptr [EBP-0008h]
 00000972  03 C6			add	EAX,ESI
 00000974  5E				pop	ESI
 00000975  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000978  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 0000097F  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000982  50				push	EAX
 00000983  52				push	EDX 
 00000984  E8 00000000 E		call	 Console_WriteDouble
 00000989  8D 05 00000000 R		lea	EAX,OFFSET $S000531
 0000098F  6A 00			push	000000000h 
 00000991  50				push	EAX 
 00000992  E8 00000000 E		call	 Console_WriteString 
 00000997  EB B1			jmp	OFFSET $L000657 
 00000999			$L000658:

				;{15}:Console::Write("| ");
 00000999  8D 05 00000551 R		lea	EAX,OFFSET $S000532
 0000099F  6A 00			push	000000000h
 000009A1  50				push	EAX 
 000009A2  E8 00000000 E		call	 Console_WriteString
				;}
 000009A7  E9 FFFFFF72			jmp	OFFSET $L000654 
 000009AC			$L000655:
				;}
 000009AC			$L000523:

 000009AC  5F				pop	EDI
 000009AD  5E				pop	ESI 
 000009AE  5B				pop	EBX 
 000009AF  8B E5			mov	ESP,EBP
 000009B1  5D				pop	EBP 
 000009B2  C2 000C			retn	00000000Ch
 000009B5			Program_ShowMatrixForm ENDP

 000009B5			Program_SumMatrices PROC NEAR 
				;void Program::SumMatrices(double double [][] A, double double [][] B, int rows, int cols, Program::OpType what);
 000009B5  55				push	EBP
 000009B6  8B EC			mov	EBP,ESP
 000009B8  81 EC 00000334		sub	ESP,000000334h
 000009BE  53				push	EBX 
 000009BF  56				push	ESI 
 000009C0  57				push	EDI 
				;{

				;{51}:Res;
 000009C1  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]

				;{52}:Result= 0.0;
 000009C7  D9 EE			fldz
 000009C9  DD 9D FFFFFCD8		fstp	qword ptr [EBP-0328h]

				;{53}:for(i= 0; i < rows; i++ )
 000009CF  33 C0			xor	EAX,EAX
 000009D1  89 85 FFFFFCD4		mov	dword ptr [EBP-032Ch],EAX
 000009D7  EB 0C			jmp	OFFSET $L000659
 000009D9			$L000660:
 000009D9  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-812]
 000009DF  FF 85 FFFFFCD4		inc	dword ptr [EBP-812]
 000009E5			$L000659:
 000009E5  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 000009EB  50				push	EAX
 000009EC  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 000009EF  5A				pop	EDX
 000009F0  3B D0			cmp	EDX,EAX
 000009F2  0F 9C C0			setl	AL
 000009F5  84 C0			test	AL,AL
 000009F7  0F 84 00000155		jz	OFFSET $L000661

				;{54}:for(j= 0; j < cols; j++ )
 000009FD  33 C0			xor	EAX,EAX
 000009FF  89 85 FFFFFCD0		mov	dword ptr [EBP-0330h],EAX
 00000A05  EB 0C			jmp	OFFSET $L000662
 00000A07			$L000663:
 00000A07  8B 85 FFFFFCD0		mov	EAX,dword ptr [EBP-816]
 00000A0D  FF 85 FFFFFCD0		inc	dword ptr [EBP-816]
 00000A13			$L000662:
 00000A13  8B 85 FFFFFCD0		mov	EAX,dword ptr [EBP-0330h]
 00000A19  50				push	EAX
 00000A1A  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000A1D  5A				pop	EDX
 00000A1E  3B D0			cmp	EDX,EAX
 00000A20  0F 9C C0			setl	AL
 00000A23  84 C0			test	AL,AL
 00000A25  0F 84 00000122		jz	OFFSET $L000664
				;{

				;{55}:if(Program::Sum == what)
 00000A2B  B8 00000001			mov	EAX,000000001h
 00000A30  50				push	EAX
 00000A31  8B 45 18			mov	EAX,dword ptr [EBP+0018h]
 00000A34  5A				pop	EDX
 00000A35  3B D0			cmp	EDX,EAX
 00000A37  0F 94 C0			setz	AL
 00000A3A  84 C0			test	AL,AL
 00000A3C  74 6A			jz	OFFSET $L000665

				;{56}:Result= A[i][j] + B[i][j];
 00000A3E  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000A41  8B C3			mov	EAX,EBX 
 00000A43  50				push	EAX
 00000A44  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 00000A4A  6B C0 0A			imul	EAX,EAX,00000000Ah
 00000A4D  8B F0			mov	ESI,EAX
 00000A4F  8B 85 FFFFFCD0		mov	EAX,dword ptr [EBP-0330h]
 00000A55  03 C6			add	EAX,ESI
 00000A57  5E				pop	ESI
 00000A58  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000A5B  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000A62  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000A65  50				push	EAX
 00000A66  52				push	EDX 
 00000A67  8B 5D 0C			mov	EBX,dword ptr [EBP+000Ch]
 00000A6A  8B C3			mov	EAX,EBX 
 00000A6C  50				push	EAX
 00000A6D  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 00000A73  6B C0 0A			imul	EAX,EAX,00000000Ah
 00000A76  8B F0			mov	ESI,EAX
 00000A78  8B 85 FFFFFCD0		mov	EAX,dword ptr [EBP-0330h]
 00000A7E  03 C6			add	EAX,ESI
 00000A80  5E				pop	ESI
 00000A81  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000A84  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000A8B  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000A8E  50				push	EAX
 00000A8F  52				push	EDX 
 00000A90  DD 04 24			fld	qword ptr [ESP]
 00000A93  59				pop	ECX
 00000A94  59				pop	ECX 
 00000A95  DC 04 24			fadd	qword ptr [ESP]
 00000A98  DD 1C 24			fstp	qword ptr [ESP]
 00000A9B  DD C0			ffree	st
 00000A9D  DD 04 24			fld	qword ptr [ESP]
 00000AA0  DD 9D FFFFFCD8		fstp	qword ptr [EBP-0328h]
 00000AA6  EB 6A			jmp	OFFSET $L000666

				; else {
 00000AA8			$L000665:

				;{58}:Result= A[i][j] - B[i][j];
 00000AA8  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000AAB  8B C3			mov	EAX,EBX 
 00000AAD  50				push	EAX
 00000AAE  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 00000AB4  6B C0 0A			imul	EAX,EAX,00000000Ah
 00000AB7  8B F0			mov	ESI,EAX
 00000AB9  8B 85 FFFFFCD0		mov	EAX,dword ptr [EBP-0330h]
 00000ABF  03 C6			add	EAX,ESI
 00000AC1  5E				pop	ESI
 00000AC2  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000AC5  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000ACC  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000ACF  50				push	EAX
 00000AD0  52				push	EDX 
 00000AD1  8B 5D 0C			mov	EBX,dword ptr [EBP+000Ch]
 00000AD4  8B C3			mov	EAX,EBX 
 00000AD6  50				push	EAX
 00000AD7  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 00000ADD  6B C0 0A			imul	EAX,EAX,00000000Ah
 00000AE0  8B F0			mov	ESI,EAX
 00000AE2  8B 85 FFFFFCD0		mov	EAX,dword ptr [EBP-0330h]
 00000AE8  03 C6			add	EAX,ESI
 00000AEA  5E				pop	ESI
 00000AEB  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000AEE  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000AF5  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000AF8  50				push	EAX
 00000AF9  52				push	EDX 
 00000AFA  DD 04 24			fld	qword ptr [ESP]
 00000AFD  59				pop	ECX
 00000AFE  59				pop	ECX 
 00000AFF  DD 04 24			fld	qword ptr [ESP]
 00000B02  D8 E1			fsub	st,st(1)
 00000B04  DD 1C 24			fstp	qword ptr [ESP]
 00000B07  DD C0			ffree	st
 00000B09  DD 04 24			fld	qword ptr [ESP]
 00000B0C  DD 9D FFFFFCD8		fstp	qword ptr [EBP-0328h]
 00000B12			$L000666:

				; }

				;{60}:Res[i][j]= Result;
 00000B12  5A				pop	EDX
 00000B13  58				pop	EAX 
 00000B14  8B 85 FFFFFCD4		mov	EAX,dword ptr [EBP-032Ch]
 00000B1A  6B C0 50			imul	EAX,EAX,000000050h
 00000B1D  8D 94 28			lea	EDX,dword ptr [EBP+EAX-0320h]
	   FFFFFCE0
 00000B24  52				push	EDX
 00000B25  8B 85 FFFFFCD0		mov	EAX,dword ptr [EBP-0330h]
 00000B2B  5E				pop	ESI
 00000B2C  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 00000B2F  50				push	EAX
 00000B30  8B 95 FFFFFCD8		mov	EDX,dword ptr [EBP-0328h]
 00000B36  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h] 
 00000B3C  50				push	EAX
 00000B3D  52				push	EDX 
 00000B3E  DD C0			ffree	st
 00000B40  DD 04 24			fld	qword ptr [ESP]
 00000B43  5A				pop	EDX
 00000B44  58				pop	EAX 
 00000B45  5B				pop	EBX
 00000B46  DD 1B			fstp	qword ptr [EBX]
				;}
 00000B48  E9 FFFFFEBA			jmp	OFFSET $L000663 
 00000B4D			$L000664:
 00000B4D  E9 FFFFFE87			jmp	OFFSET $L000660 
 00000B52			$L000661:

				;{63}:Program::ShowMatrixForm(Res, rows, cols);
 00000B52  8B 45 14			mov	EAX,dword ptr [EBP+0014h]
 00000B55  50				push	EAX 
 00000B56  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000B59  50				push	EAX 
 00000B5A  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 00000B60  50				push	EAX
 00000B61  E8 FFFFFDA8			call	 Program_ShowMatrixForm
				;}
 00000B66			$L000554:

 00000B66  5F				pop	EDI
 00000B67  5E				pop	ESI 
 00000B68  5B				pop	EBX 
 00000B69  8B E5			mov	ESP,EBP
 00000B6B  5D				pop	EBP 
 00000B6C  C2 0014			retn	000000014h
 00000B6F			Program_SumMatrices ENDP

 00000B6F			Program_Traspose PROC NEAR 
				;void Program::Traspose(double double [][] M, int rM, int cM);
 00000B6F  55				push	EBP
 00000B70  8B EC			mov	EBP,ESP
 00000B72  81 EC 0000032C		sub	ESP,00000032Ch
 00000B78  53				push	EBX 
 00000B79  56				push	ESI 
 00000B7A  57				push	EDI 
				;{

				;{31}:Res;
 00000B7B  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]

				;{33}:for(i= 0; i < rM; i++ )
 00000B81  33 C0			xor	EAX,EAX
 00000B83  89 85 FFFFFCDC		mov	dword ptr [EBP-0324h],EAX
 00000B89  EB 0C			jmp	OFFSET $L000667
 00000B8B			$L000668:
 00000B8B  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-804]
 00000B91  FF 85 FFFFFCDC		inc	dword ptr [EBP-804]
 00000B97			$L000667:
 00000B97  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h]
 00000B9D  50				push	EAX
 00000B9E  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 00000BA1  5A				pop	EDX
 00000BA2  3B D0			cmp	EDX,EAX
 00000BA4  0F 9C C0			setl	AL
 00000BA7  84 C0			test	AL,AL
 00000BA9  0F 84 00000080		jz	OFFSET $L000669

				;{34}:for(j= 0; j < cM; j++ )
 00000BAF  33 C0			xor	EAX,EAX
 00000BB1  89 85 FFFFFCD8		mov	dword ptr [EBP-0328h],EAX
 00000BB7  EB 0C			jmp	OFFSET $L000670
 00000BB9			$L000671:
 00000BB9  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-808]
 00000BBF  FF 85 FFFFFCD8		inc	dword ptr [EBP-808]
 00000BC5			$L000670:
 00000BC5  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-0328h]
 00000BCB  50				push	EAX
 00000BCC  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000BCF  5A				pop	EDX
 00000BD0  3B D0			cmp	EDX,EAX
 00000BD2  0F 9C C0			setl	AL
 00000BD5  84 C0			test	AL,AL
 00000BD7  74 51			jz	OFFSET $L000672

				;{35}:Res[j][i]= M[i][j];
 00000BD9  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-0328h]
 00000BDF  6B C0 50			imul	EAX,EAX,000000050h
 00000BE2  8D 94 28	lea	EDX,dword ptr [EBP+EAX-0320h]
	   FFFFFCE0
 00000BE9  52				push	EDX
 00000BEA  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h]
 00000BF0  5E				pop	ESI
 00000BF1  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 00000BF4  50				push	EAX
 00000BF5  8B 5D 08			mov	EBX,dword ptr [EBP+0008h]
 00000BF8  8B C3			mov	EAX,EBX 
 00000BFA  50				push	EAX
 00000BFB  8B 85 FFFFFCDC		mov	EAX,dword ptr [EBP-0324h]
 00000C01  6B C0 0A			imul	EAX,EAX,00000000Ah
 00000C04  8B F0			mov	ESI,EAX
 00000C06  8B 85 FFFFFCD8		mov	EAX,dword ptr [EBP-0328h]
 00000C0C  03 C6			add	EAX,ESI
 00000C0E  5E				pop	ESI
 00000C0F  8B 14 C6			mov	EDX,dword ptr [ESI+EAX*0008h]
 00000C12  8D 04 C5			lea	EAX,dword ptr [EAX*0008h+4] ;low part
	   00000004
 00000C19  8B 04 30			mov	EAX,dword ptr [ESI+EAX] 
 00000C1C  50				push	EAX
 00000C1D  52				push	EDX 
 00000C1E  DD C0			ffree	st
 00000C20  DD 04 24			fld	qword ptr [ESP]
 00000C23  5A				pop	EDX
 00000C24  58				pop	EAX 
 00000C25  5B				pop	EBX
 00000C26  DD 1B			fstp	qword ptr [EBX]
 00000C28  EB 8F			jmp	OFFSET $L000671 
 00000C2A			$L000672:
 00000C2A  E9 FFFFFF5C			jmp	OFFSET $L000668 
 00000C2F			$L000669:

				;{37}:Program::ShowMatrixForm(Res, rM, cM);
 00000C2F  8B 45 10			mov	EAX,dword ptr [EBP+0010h]
 00000C32  50				push	EAX 
 00000C33  8B 45 0C			mov	EAX,dword ptr [EBP+000Ch]
 00000C36  50				push	EAX 
 00000C37  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 00000C3D  50				push	EAX
 00000C3E  E8 FFFFFCCB			call	 Program_ShowMatrixForm
				;}
 00000C43			$L000544:

 00000C43  5F				pop	EDI
 00000C44  5E				pop	ESI 
 00000C45  5B				pop	EBX 
 00000C46  8B E5			mov	ESP,EBP
 00000C48  5D				pop	EBP 
 00000C49  C2 000C			retn	00000000Ch
 00000C4C			Program_Traspose ENDP

 00000C4C			Program_main PROC NEAR 
				;void Program::main(void);
 00000C4C  55				push	EBP
 00000C4D  8B EC			mov	EBP,ESP
 00000C4F  81 EC 00000674		sub	ESP,000000674h
 00000C55  53				push	EBX 
 00000C56  56				push	ESI 
 00000C57  57				push	EDI 
				;{

				;{93}:A;
 00000C58  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]

				;{94}:B;
 00000C5E  8D 85 FFFFF9C0		lea	EAX,dword ptr [EBP-0640h]

				;{96}:Tr= 0.0;
 00000C64  D9 EE			fldz
 00000C66  DD 9D FFFFF9B8		fstp	qword ptr [EBP-0648h]

				;{97}:bExitProgram= false;
 00000C6C  33 C0			xor	EAX,EAX
 00000C6E  88 85 FFFFF9B4		mov	byte ptr [EBP-064Ch],AL

				;{98}:bReEnterMatrices= false;
 00000C74  33 C0			xor	EAX,EAX
 00000C76  88 85 FFFFF9B0		mov	byte ptr [EBP-0650h],AL

				;{99}:while(true)
 00000C7C			$L000673:
 00000C7C  B8 00000001			mov	EAX,000000001h
 00000C81  84 C0			test	AL,AL
 00000C83  0F 84 000009F7		jz	OFFSET $L000674
				;{

				;{101}:Console::ClearScreen();
 00000C89  E8 00000000 E		call	 Console_ClearScreen

				;{102}:Console::WriteLn("Programa de Matrices\n\n");
 00000C8E  8D 05 00000452 R		lea	EAX,OFFSET $S000582
 00000C94  6A 00			push	000000000h
 00000C96  50				push	EAX 
 00000C97  E8 00000000 E		call	 Console_WriteString
 00000C9C  E8 00000000 E		call	 Console_WriteCrLf 

				;{103}:Console::WriteLn("Entre las dimensiones de dos matrices:\n");
 00000CA1  8D 05 000002F0 R		lea	EAX,OFFSET $S000583
 00000CA7  6A 00			push	000000000h
 00000CA9  50				push	EAX 
 00000CAA  E8 00000000 E		call	 Console_WriteString
 00000CAF  E8 00000000 E		call	 Console_WriteCrLf 

				;{104}:Console::Write("Entre las filas de A: ");
 00000CB4  8D 05 00000318 R		lea	EAX,OFFSET $S000584
 00000CBA  6A 00			push	000000000h
 00000CBC  50				push	EAX 
 00000CBD  E8 00000000 E		call	 Console_WriteString

				;{105}:rA= Console::ReadInteger();
 00000CC2  E8 00000000 E		call	 Console_ReadInteger
 00000CC7  89 85 FFFFF9AC		mov	dword ptr [EBP-0654h],EAX

				;{106}:Console::Write("\nEntre las columnas de A: ");
 00000CCD  8D 05 00000469 R		lea	EAX,OFFSET $S000586
 00000CD3  6A 00			push	000000000h
 00000CD5  50				push	EAX 
 00000CD6  E8 00000000 E		call	 Console_WriteString

				;{107}:cA= Console::ReadInteger();
 00000CDB  E8 00000000 E		call	 Console_ReadInteger
 00000CE0  89 85 FFFFF9A8		mov	dword ptr [EBP-0658h],EAX

				;{109}:Console::Write("\nEntre las filas de B: ");
 00000CE6  8D 05 0000049F R		lea	EAX,OFFSET $S000588
 00000CEC  6A 00			push	000000000h
 00000CEE  50				push	EAX 
 00000CEF  E8 00000000 E		call	 Console_WriteString

				;{110}:rB= Console::ReadInteger();
 00000CF4  E8 00000000 E		call	 Console_ReadInteger
 00000CF9  89 85 FFFFF9A4		mov	dword ptr [EBP-065Ch],EAX

				;{111}:Console::Write("\nEntre las columnas de B: ");
 00000CFF  8D 05 00000484 R		lea	EAX,OFFSET $S000590
 00000D05  6A 00			push	000000000h
 00000D07  50				push	EAX 
 00000D08  E8 00000000 E		call	 Console_WriteString

				;{112}:cB= Console::ReadInteger();
 00000D0D  E8 00000000 E		call	 Console_ReadInteger
 00000D12  89 85 FFFFF9A0		mov	dword ptr [EBP-0660h],EAX

				;{114}:Console::ClearScreen();
 00000D18  E8 00000000 E		call	 Console_ClearScreen

				;{116}:x= 'N';
 00000D1D  B8 0000004E			mov	EAX,00000004Eh
 00000D22  88 85 FFFFF99C		mov	byte ptr [EBP-0664h],AL

				;{117}:if(rA <= 0 || rB <= 0)
 00000D28  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00000D2E  50				push	EAX
 00000D2F  33 C0			xor	EAX,EAX
 00000D31  5A				pop	EDX
 00000D32  3B D0			cmp	EDX,EAX
 00000D34  0F 9E C0			setle	AL
 00000D37  84 C0			test	AL,AL
 00000D39  75 0F			jnz	OFFSET $L000677
 00000D3B  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 00000D41  50				push	EAX
 00000D42  33 C0			xor	EAX,EAX
 00000D44  5A				pop	EDX
 00000D45  3B D0			cmp	EDX,EAX
 00000D47  0F 9E C0			setle	AL
 00000D4A			$L000677:
 00000D4A  84 C0			test	AL,AL
 00000D4C  74 56			jz	OFFSET $L000675
				;{

				;{119}:Console::WriteLn("El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
 00000D4E  8D 05 00000240 R		lea	EAX,OFFSET $S000594
 00000D54  6A 00			push	000000000h
 00000D56  50				push	EAX 
 00000D57  E8 00000000 E		call	 Console_WriteString
 00000D5C  E8 00000000 E		call	 Console_WriteCrLf 

				;{120}:x= Console::ReadChar();
 00000D61  E8 00000000 E		call	 Console_ReadChar
 00000D66  88 85 FFFFF99C		mov	byte ptr [EBP-0664h],AL

				;{121}:if(x == 'y' || x == 'Y')
 00000D6C  0F BE 85			movsx	EAX,byte ptr [EBP-0664h]
	   FFFFF99C
 00000D73  50				push	EAX
 00000D74  B8 00000079			mov	EAX,000000079h
 00000D79  5A				pop	EDX
 00000D7A  38 C2			cmp	DL,AL
 00000D7C  0F 94 C0			setz	AL
 00000D7F  84 C0			test	AL,AL
 00000D81  75 13			jnz	OFFSET $L000680
 00000D83  0F BE 85			movsx	EAX,byte ptr [EBP-0664h]
	   FFFFF99C
 00000D8A  50				push	EAX
 00000D8B  B8 00000059			mov	EAX,000000059h
 00000D90  5A				pop	EDX
 00000D91  38 C2			cmp	DL,AL
 00000D93  0F 94 C0			setz	AL
 00000D96			$L000680:
 00000D96  84 C0			test	AL,AL
 00000D98  74 05			jz	OFFSET $L000678

				;continue;
 00000D9A  E9 FFFFFEDD			jmp	OFFSET $L000673
 00000D9F			$L000678:

				;break;
 00000D9F  E9 000008DC			jmp	OFFSET $L000674
				;}
 00000DA4			$L000675:

				;{126}:if(rA > 10 || rB > 10)
 00000DA4  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00000DAA  50				push	EAX
 00000DAB  B8 0000000A			mov	EAX,00000000Ah
 00000DB0  5A				pop	EDX
 00000DB1  3B D0			cmp	EDX,EAX
 00000DB3  0F 9F C0			setg	AL
 00000DB6  84 C0			test	AL,AL
 00000DB8  75 12			jnz	OFFSET $L000683
 00000DBA  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 00000DC0  50				push	EAX
 00000DC1  B8 0000000A			mov	EAX,00000000Ah
 00000DC6  5A				pop	EDX
 00000DC7  3B D0			cmp	EDX,EAX
 00000DC9  0F 9F C0			setg	AL
 00000DCC			$L000683:
 00000DCC  84 C0			test	AL,AL
 00000DCE  74 56			jz	OFFSET $L000681
				;{

				;{128}:Console::WriteLn("El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
 00000DD0  8D 05 00000240 R		lea	EAX,OFFSET $S000594
 00000DD6  6A 00			push	000000000h
 00000DD8  50				push	EAX 
 00000DD9  E8 00000000 E		call	 Console_WriteString
 00000DDE  E8 00000000 E		call	 Console_WriteCrLf 

				;{129}:x= Console::ReadChar();
 00000DE3  E8 00000000 E		call	 Console_ReadChar
 00000DE8  88 85 FFFFF99C		mov	byte ptr [EBP-0664h],AL

				;{130}:if(x == 'y' || x == 'Y')
 00000DEE  0F BE 85			movsx	EAX,byte ptr [EBP-0664h]
	   FFFFF99C
 00000DF5  50				push	EAX
 00000DF6  B8 00000079			mov	EAX,000000079h
 00000DFB  5A				pop	EDX
 00000DFC  38 C2			cmp	DL,AL
 00000DFE  0F 94 C0			setz	AL
 00000E01  84 C0			test	AL,AL
 00000E03  75 13			jnz	OFFSET $L000686
 00000E05  0F BE 85			movsx	EAX,byte ptr [EBP-0664h]
	   FFFFF99C
 00000E0C  50				push	EAX
 00000E0D  B8 00000059			mov	EAX,000000059h
 00000E12  5A				pop	EDX
 00000E13  38 C2			cmp	DL,AL
 00000E15  0F 94 C0			setz	AL
 00000E18			$L000686:
 00000E18  84 C0			test	AL,AL
 00000E1A  74 05			jz	OFFSET $L000684

				;continue;
 00000E1C  E9 FFFFFE5B			jmp	OFFSET $L000673
 00000E21			$L000684:

				;break;
 00000E21  E9 0000085A			jmp	OFFSET $L000674
				;}
 00000E26			$L000681:

				;{135}:if(cA <= 0 || cB <= 0)
 00000E26  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 00000E2C  50				push	EAX
 00000E2D  33 C0			xor	EAX,EAX
 00000E2F  5A				pop	EDX
 00000E30  3B D0			cmp	EDX,EAX
 00000E32  0F 9E C0			setle	AL
 00000E35  84 C0			test	AL,AL
 00000E37  75 0F			jnz	OFFSET $L000689
 00000E39  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 00000E3F  50				push	EAX
 00000E40  33 C0			xor	EAX,EAX
 00000E42  5A				pop	EDX
 00000E43  3B D0			cmp	EDX,EAX
 00000E45  0F 9E C0			setle	AL
 00000E48			$L000689:
 00000E48  84 C0			test	AL,AL
 00000E4A  74 56			jz	OFFSET $L000687
				;{

				;{137}:Console::WriteLn("El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
 00000E4C  8D 05 00000118 R		lea	EAX,OFFSET $S000598
 00000E52  6A 00			push	000000000h
 00000E54  50				push	EAX 
 00000E55  E8 00000000 E		call	 Console_WriteString
 00000E5A  E8 00000000 E		call	 Console_WriteCrLf 

				;{138}:x= Console::ReadChar();
 00000E5F  E8 00000000 E		call	 Console_ReadChar
 00000E64  88 85 FFFFF99C		mov	byte ptr [EBP-0664h],AL

				;{139}:if(x == 'y' || x == 'Y')
 00000E6A  0F BE 85			movsx	EAX,byte ptr [EBP-0664h]
	   FFFFF99C
 00000E71  50				push	EAX
 00000E72  B8 00000079			mov	EAX,000000079h
 00000E77  5A				pop	EDX
 00000E78  38 C2			cmp	DL,AL
 00000E7A  0F 94 C0			setz	AL
 00000E7D  84 C0			test	AL,AL
 00000E7F  75 13			jnz	OFFSET $L000692
 00000E81  0F BE 85			movsx	EAX,byte ptr [EBP-0664h]
	   FFFFF99C
 00000E88  50				push	EAX
 00000E89  B8 00000059			mov	EAX,000000059h
 00000E8E  5A				pop	EDX
 00000E8F  38 C2			cmp	DL,AL
 00000E91  0F 94 C0			setz	AL
 00000E94			$L000692:
 00000E94  84 C0			test	AL,AL
 00000E96  74 05			jz	OFFSET $L000690

				;continue;
 00000E98  E9 FFFFFDDF			jmp	OFFSET $L000673
 00000E9D			$L000690:

				;break;
 00000E9D  E9 000007DE			jmp	OFFSET $L000674
				;}
 00000EA2			$L000687:

				;{144}:if(cA > 10 || cB > 10)
 00000EA2  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 00000EA8  50				push	EAX
 00000EA9  B8 0000000A			mov	EAX,00000000Ah
 00000EAE  5A				pop	EDX
 00000EAF  3B D0			cmp	EDX,EAX
 00000EB1  0F 9F C0			setg	AL
 00000EB4  84 C0			test	AL,AL
 00000EB6  75 12			jnz	OFFSET $L000695
 00000EB8  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 00000EBE  50				push	EAX
 00000EBF  B8 0000000A			mov	EAX,00000000Ah
 00000EC4  5A				pop	EDX
 00000EC5  3B D0			cmp	EDX,EAX
 00000EC7  0F 9F C0			setg	AL
 00000ECA			$L000695:
 00000ECA  84 C0			test	AL,AL
 00000ECC  74 56			jz	OFFSET $L000693
				;{

				;{146}:Console::WriteLn("El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?");
 00000ECE  8D 05 00000118 R		lea	EAX,OFFSET $S000598
 00000ED4  6A 00			push	000000000h
 00000ED6  50				push	EAX 
 00000ED7  E8 00000000 E		call	 Console_WriteString
 00000EDC  E8 00000000 E		call	 Console_WriteCrLf 

				;{147}:x= Console::ReadChar();
 00000EE1  E8 00000000 E		call	 Console_ReadChar
 00000EE6  88 85 FFFFF99C		mov	byte ptr [EBP-0664h],AL

				;{148}:if(x == 'y' || x == 'Y')
 00000EEC  0F BE 85			movsx	EAX,byte ptr [EBP-0664h]
	   FFFFF99C
 00000EF3  50				push	EAX
 00000EF4  B8 00000079			mov	EAX,000000079h
 00000EF9  5A				pop	EDX
 00000EFA  38 C2			cmp	DL,AL
 00000EFC  0F 94 C0			setz	AL
 00000EFF  84 C0			test	AL,AL
 00000F01  75 13			jnz	OFFSET $L000698
 00000F03  0F BE 85			movsx	EAX,byte ptr [EBP-0664h]
	   FFFFF99C
 00000F0A  50				push	EAX
 00000F0B  B8 00000059			mov	EAX,000000059h
 00000F10  5A				pop	EDX
 00000F11  38 C2			cmp	DL,AL
 00000F13  0F 94 C0			setz	AL
 00000F16			$L000698:
 00000F16  84 C0			test	AL,AL
 00000F18  74 05			jz	OFFSET $L000696

				;continue;
 00000F1A  E9 FFFFFD5D			jmp	OFFSET $L000673
 00000F1F			$L000696:

				;break;
 00000F1F  E9 0000075C			jmp	OFFSET $L000674
				;}
 00000F24			$L000693:

				;{153}:Console::WriteLn("Entre los valores para la matriz A[", rA, "][", cA, "]");
 00000F24  8D 05 0000032F R		lea	EAX,OFFSET $S000599
 00000F2A  6A 00			push	000000000h
 00000F2C  50				push	EAX 
 00000F2D  E8 00000000 E		call	 Console_WriteString
 00000F32  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00000F38  50				push	EAX 
 00000F39  E8 00000000 E		call	 Console_WriteInteger 
 00000F3E  8D 05 0000054E R		lea	EAX,OFFSET $S000600
 00000F44  6A 00			push	000000000h 
 00000F46  50				push	EAX 
 00000F47  E8 00000000 E		call	 Console_WriteString 
 00000F4C  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 00000F52  50				push	EAX 
 00000F53  E8 00000000 E		call	 Console_WriteInteger 
 00000F58  B8 0000005D			mov	EAX,00000005Dh
 00000F5D  50				push	EAX 
 00000F5E  E8 00000000 E		call	 Console_WriteChar 
 00000F63  E8 00000000 E		call	 Console_WriteCrLf 

				;{154}:for(i= 0; i < rA; i++ )
 00000F68  33 C0			xor	EAX,EAX
 00000F6A  89 85 FFFFF998		mov	dword ptr [EBP-0668h],EAX
 00000F70  EB 0C			jmp	OFFSET $L000699
 00000F72			$L000700:
 00000F72  8B 85 FFFFF998		mov	EAX,dword ptr [EBP-1640]
 00000F78  FF 85 FFFFF998		inc	dword ptr [EBP-1640]
 00000F7E			$L000699:
 00000F7E  8B 85 FFFFF998		mov	EAX,dword ptr [EBP-0668h]
 00000F84  50				push	EAX
 00000F85  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00000F8B  5A				pop	EDX
 00000F8C  3B D0			cmp	EDX,EAX
 00000F8E  0F 9C C0			setl	AL
 00000F91  84 C0			test	AL,AL
 00000F93  0F 84 000000A3		jz	OFFSET $L000701

				;{155}:for(j= 0; j < cA; j++ )
 00000F99  33 C0			xor	EAX,EAX
 00000F9B  89 85 FFFFF994		mov	dword ptr [EBP-066Ch],EAX
 00000FA1  EB 0C			jmp	OFFSET $L000702
 00000FA3			$L000703:
 00000FA3  8B 85 FFFFF994		mov	EAX,dword ptr [EBP-1644]
 00000FA9  FF 85 FFFFF994		inc	dword ptr [EBP-1644]
 00000FAF			$L000702:
 00000FAF  8B 85 FFFFF994		mov	EAX,dword ptr [EBP-066Ch]
 00000FB5  50				push	EAX
 00000FB6  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 00000FBC  5A				pop	EDX
 00000FBD  3B D0			cmp	EDX,EAX
 00000FBF  0F 9C C0			setl	AL
 00000FC2  84 C0			test	AL,AL
 00000FC4  74 71			jz	OFFSET $L000704
				;{

				;{157}:Console::Write("Elemento en A[", i, ",", j, "] = ");
 00000FC6  8D 05 0000029F R		lea	EAX,OFFSET $S000604
 00000FCC  6A 00			push	000000000h
 00000FCE  50				push	EAX 
 00000FCF  E8 00000000 E		call	 Console_WriteString
 00000FD4  8B 85 FFFFF998		mov	EAX,dword ptr [EBP-0668h]
 00000FDA  50				push	EAX 
 00000FDB  E8 00000000 E		call	 Console_WriteInteger 
 00000FE0  B8 0000002C			mov	EAX,00000002Ch
 00000FE5  50				push	EAX 
 00000FE6  E8 00000000 E		call	 Console_WriteChar 
 00000FEB  8B 85 FFFFF994		mov	EAX,dword ptr [EBP-066Ch]
 00000FF1  50				push	EAX 
 00000FF2  E8 00000000 E		call	 Console_WriteInteger 
 00000FF7  8D 05 00000545 R		lea	EAX,OFFSET $S000605
 00000FFD  6A 00			push	000000000h 
 00000FFF  50				push	EAX 
 00001000  E8 00000000 E		call	 Console_WriteString 

				;{158}:A[i][j]= Console::ReadDouble();
 00001005  8B 85 FFFFF998		mov	EAX,dword ptr [EBP-0668h]
 0000100B  6B C0 50			imul	EAX,EAX,000000050h
 0000100E  8D 94 28			lea	EDX,dword ptr [EBP+EAX-0320h]
	   FFFFFCE0
 00001015  52				push	EDX
 00001016  8B 85 FFFFF994		mov	EAX,dword ptr [EBP-066Ch]
 0000101C  5E				pop	ESI
 0000101D  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 00001020  50				push	EAX
 00001021  E8 00000000 E		call	 Console_ReadDouble
 00001026  50				push	EAX
 00001027  52				push	EDX 
 00001028  DD C0			ffree	st
 0000102A  DD 04 24			fld	qword ptr [ESP]
 0000102D  5A				pop	EDX
 0000102E  58				pop	EAX 
 0000102F  5B				pop	EBX
 00001030  DD 1B			fstp	qword ptr [EBX]
				;}
 00001032  E9 FFFFFF6C			jmp	OFFSET $L000703 
 00001037			$L000704:
 00001037  E9 FFFFFF36			jmp	OFFSET $L000700 
 0000103C			$L000701:

				;{161}:Console::WriteLn("\nEntre los valores para la matriz B[", rB, "][", cB, "]");
 0000103C  8D 05 000004B7 R		lea	EAX,OFFSET $S000606
 00001042  6A 00			push	000000000h
 00001044  50				push	EAX 
 00001045  E8 00000000 E		call	 Console_WriteString
 0000104A  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 00001050  50				push	EAX 
 00001051  E8 00000000 E		call	 Console_WriteInteger 
 00001056  8D 05 0000054E R		lea	EAX,OFFSET $S000600
 0000105C  6A 00			push	000000000h 
 0000105E  50				push	EAX 
 0000105F  E8 00000000 E		call	 Console_WriteString 
 00001064  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 0000106A  50				push	EAX 
 0000106B  E8 00000000 E		call	 Console_WriteInteger 
 00001070  B8 0000005D			mov	EAX,00000005Dh
 00001075  50				push	EAX 
 00001076  E8 00000000 E		call	 Console_WriteChar 
 0000107B  E8 00000000 E		call	 Console_WriteCrLf 

				;{162}:for(i= 0; i < rB; i++ )
 00001080  33 C0			xor	EAX,EAX
 00001082  89 85 FFFFF998		mov	dword ptr [EBP-0668h],EAX
 00001088  EB 0C			jmp	OFFSET $L000705
 0000108A			$L000706:
 0000108A  8B 85 FFFFF998		mov	EAX,dword ptr [EBP-1640]
 00001090  FF 85 FFFFF998		inc	dword ptr [EBP-1640]
 00001096			$L000705:
 00001096  8B 85 FFFFF998		mov	EAX,dword ptr [EBP-0668h]
 0000109C  50				push	EAX
 0000109D  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 000010A3  5A				pop	EDX
 000010A4  3B D0			cmp	EDX,EAX
 000010A6  0F 9C C0			setl	AL
 000010A9  84 C0			test	AL,AL
 000010AB  0F 84 000000A3		jz	OFFSET $L000707

				;{163}:for(j= 0; j < cB; j++ )
 000010B1  33 C0			xor	EAX,EAX
 000010B3  89 85 FFFFF994		mov	dword ptr [EBP-066Ch],EAX
 000010B9  EB 0C			jmp	OFFSET $L000708
 000010BB			$L000709:
 000010BB  8B 85 FFFFF994		mov	EAX,dword ptr [EBP-1644]
 000010C1  FF 85 FFFFF994		inc	dword ptr [EBP-1644]
 000010C7			$L000708:
 000010C7  8B 85 FFFFF994		mov	EAX,dword ptr [EBP-066Ch]
 000010CD  50				push	EAX
 000010CE  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 000010D4  5A				pop	EDX
 000010D5  3B D0			cmp	EDX,EAX
 000010D7  0F 9C C0			setl	AL
 000010DA  84 C0			test	AL,AL
 000010DC  74 71			jz	OFFSET $L000710
				;{

				;{165}:Console::Write("Elemento en B[", i, ",", j, "] = ");
 000010DE  8D 05 000002AE R		lea	EAX,OFFSET $S000607
 000010E4  6A 00			push	000000000h
 000010E6  50				push	EAX 
 000010E7  E8 00000000 E		call	 Console_WriteString
 000010EC  8B 85 FFFFF998		mov	EAX,dword ptr [EBP-0668h]
 000010F2  50				push	EAX 
 000010F3  E8 00000000 E		call	 Console_WriteInteger 
 000010F8  B8 0000002C			mov	EAX,00000002Ch
 000010FD  50				push	EAX 
 000010FE  E8 00000000 E		call	 Console_WriteChar 
 00001103  8B 85 FFFFF994		mov	EAX,dword ptr [EBP-066Ch]
 00001109  50				push	EAX 
 0000110A  E8 00000000 E		call	 Console_WriteInteger 
 0000110F  8D 05 00000545 R		lea	EAX,OFFSET $S000605
 00001115  6A 00			push	000000000h 
 00001117  50				push	EAX 
 00001118  E8 00000000 E		call	 Console_WriteString 

				;{166}:B[i][j]= Console::ReadDouble();
 0000111D  8B 85 FFFFF998		mov	EAX,dword ptr [EBP-0668h]
 00001123  6B C0 50			imul	EAX,EAX,000000050h
 00001126  8D 94 28			lea	EDX,dword ptr [EBP+EAX-0640h]
	   FFFFF9C0
 0000112D  52				push	EDX
 0000112E  8B 85 FFFFF994		mov	EAX,dword ptr [EBP-066Ch]
 00001134  5E				pop	ESI
 00001135  8D 04 C6			lea	EAX,dword ptr [ESI+EAX*0008h]
 00001138  50				push	EAX
 00001139  E8 00000000 E		call	 Console_ReadDouble
 0000113E  50				push	EAX
 0000113F  52				push	EDX 
 00001140  DD C0			ffree	st
 00001142  DD 04 24			fld	qword ptr [ESP]
 00001145  5A				pop	EDX
 00001146  58				pop	EAX 
 00001147  5B				pop	EBX
 00001148  DD 1B			fstp	qword ptr [EBX]
				;}
 0000114A  E9 FFFFFF6C			jmp	OFFSET $L000709 
 0000114F			$L000710:
 0000114F  E9 FFFFFF36			jmp	OFFSET $L000706 
 00001154			$L000707:

				;{170}:Console::WriteLn("Matriz A:\n");
 00001154  8D 05 00000447 R		lea	EAX,OFFSET $S000608
 0000115A  6A 00			push	000000000h
 0000115C  50				push	EAX 
 0000115D  E8 00000000 E		call	 Console_WriteString
 00001162  E8 00000000 E		call	 Console_WriteCrLf 

				;{171}:Program::ShowMatrixForm(A, rA, cA);
 00001167  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 0000116D  50				push	EAX 
 0000116E  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00001174  50				push	EAX 
 00001175  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 0000117B  50				push	EAX
 0000117C  E8 FFFFF78D			call	 Program_ShowMatrixForm

				;{172}:Console::WriteLn("\n\nMatriz B:\n");
 00001181  8D 05 000004F9 R		lea	EAX,OFFSET $S000609
 00001187  6A 00			push	000000000h
 00001189  50				push	EAX 
 0000118A  E8 00000000 E		call	 Console_WriteString
 0000118F  E8 00000000 E		call	 Console_WriteCrLf 

				;{173}:Program::ShowMatrixForm(B, rB, cB);
 00001194  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 0000119A  50				push	EAX 
 0000119B  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 000011A1  50				push	EAX 
 000011A2  8D 85 FFFFF9C0		lea	EAX,dword ptr [EBP-0640h]
 000011A8  50				push	EAX
 000011A9  E8 FFFFF760			call	 Program_ShowMatrixForm

				;do
 000011AE			$L000711:
				;{

				;{176}:Console::WriteLn("\n\nQue deseas hacer?\n");
 000011AE  8D 05 0000052C R		lea	EAX,OFFSET $S000610
 000011B4  6A 00			push	000000000h
 000011B6  50				push	EAX 
 000011B7  E8 00000000 E		call	 Console_WriteString
 000011BC  E8 00000000 E		call	 Console_WriteCrLf 

				;{177}:Console::WriteLn("0. Mostrar las Matrices\n1. Sumar las matrices.\n2. Restar las matrices.\n3. Multiplicar las matrices (A*B).\n4. Multiplicar las matrices (B*A).\n5. Calcular la traza de A\n6. Calcular la traza de B.\n7. Trasponer matriz A.\n8. Trasponer matriz B.\n9. Re-Entrar Matrices\n10. Salir\n\n");
 000011C1  8D 05 00000003 R		lea	EAX,OFFSET $S000611
 000011C7  6A 00			push	000000000h
 000011C9  50				push	EAX 
 000011CA  E8 00000000 E		call	 Console_WriteString
 000011CF  E8 00000000 E		call	 Console_WriteCrLf 

				;{178}:Console::Write(">:");
 000011D4  8D 05 00000115 R		lea	EAX,OFFSET $S000612
 000011DA  6A 00			push	000000000h
 000011DC  50				push	EAX 
 000011DD  E8 00000000 E		call	 Console_WriteString

				;{179}:nOption= Console::ReadInteger();
 000011E2  E8 00000000 E		call	 Console_ReadInteger
 000011E7  89 85 FFFFF990		mov	dword ptr [EBP-0670h],EAX

				;{180}:switch(nOption)
 000011ED  8B 85 FFFFF990		mov	EAX,dword ptr [EBP-0670h]
 000011F3  8B F0			mov	ESI,EAX
 000011F5  33 C0			xor	EAX,EAX
 000011F7  3B C6			cmp	EAX,ESI
 000011F9  0F 84 00000087		jz	OFFSET $L000715
 000011FF  B8 00000001			mov	EAX,000000001h
 00001204  3B C6			cmp	EAX,ESI
 00001206  0F 84 000000D9		jz	OFFSET $L000716
 0000120C  B8 00000002			mov	EAX,000000002h
 00001211  3B C6			cmp	EAX,ESI 
 00001213  0F 84 000000CC		jz	OFFSET $L000717 
 00001219  B8 00000003			mov	EAX,000000003h
 0000121E  3B C6			cmp	EAX,ESI
 00001220  0F 84 0000015E		jz	OFFSET $L000723
 00001226  B8 00000004			mov	EAX,000000004h
 0000122B  3B C6			cmp	EAX,ESI
 0000122D  0F 84 000001C4		jz	OFFSET $L000726
 00001233  B8 00000005			mov	EAX,000000005h
 00001238  3B C6			cmp	EAX,ESI
 0000123A  0F 84 0000022A		jz	OFFSET $L000729
 00001240  B8 00000006			mov	EAX,000000006h
 00001245  3B C6			cmp	EAX,ESI
 00001247  0F 84 00000271		jz	OFFSET $L000730
 0000124D  B8 00000007			mov	EAX,000000007h
 00001252  3B C6			cmp	EAX,ESI
 00001254  0F 84 000002B8		jz	OFFSET $L000731
 0000125A  B8 00000008			mov	EAX,000000008h
 0000125F  3B C6			cmp	EAX,ESI
 00001261  0F 84 00000309		jz	OFFSET $L000734
 00001267  B8 00000009			mov	EAX,000000009h
 0000126C  3B C6			cmp	EAX,ESI
 0000126E  0F 84 00000357		jz	OFFSET $L000737
 00001274  B8 0000000A			mov	EAX,00000000Ah
 00001279  3B C6			cmp	EAX,ESI
 0000127B  0F 84 00000357		jz	OFFSET $L000738
 00001281  E9 0000035F			jmp	OFFSET $L000739
 00001286			$L000715:
				;{

				;{183}:Console::WriteLn("Matriz A:\n");
 00001286  8D 05 00000447 R		lea	EAX,OFFSET $S000608
 0000128C  6A 00			push	000000000h
 0000128E  50				push	EAX 
 0000128F  E8 00000000 E		call	 Console_WriteString
 00001294  E8 00000000 E		call	 Console_WriteCrLf 

				;{184}:Program::ShowMatrixForm(A, rA, cA);
 00001299  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 0000129F  50				push	EAX 
 000012A0  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 000012A6  50				push	EAX 
 000012A7  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 000012AD  50				push	EAX
 000012AE  E8 FFFFF65B			call	 Program_ShowMatrixForm

				;{185}:Console::WriteLn("\n\nMatriz B:\n");
 000012B3  8D 05 000004F9 R		lea	EAX,OFFSET $S000609
 000012B9  6A 00			push	000000000h
 000012BB  50				push	EAX 
 000012BC  E8 00000000 E		call	 Console_WriteString
 000012C1  E8 00000000 E		call	 Console_WriteCrLf 

				;{186}:Program::ShowMatrixForm(B, rB, cB);
 000012C6  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 000012CC  50				push	EAX 
 000012CD  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 000012D3  50				push	EAX 
 000012D4  8D 85 FFFFF9C0		lea	EAX,dword ptr [EBP-0640h]
 000012DA  50				push	EAX
 000012DB  E8 FFFFF62E			call	 Program_ShowMatrixForm
				;}
 000012E0  E9 00000313			jmp	OFFSET $L000714
 000012E5			$L000716:
 000012E5			$L000717:
				;{

				;{192}:if(rA != rB || cA != cB)
 000012E5  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 000012EB  50				push	EAX
 000012EC  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 000012F2  5A				pop	EDX
 000012F3  3B D0			cmp	EDX,EAX
 000012F5  0F 95 C0			setnz	AL
 000012F8  84 C0			test	AL,AL
 000012FA  75 13			jnz	OFFSET $L000720
 000012FC  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 00001302  50				push	EAX
 00001303  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 00001309  5A				pop	EDX
 0000130A  3B D0			cmp	EDX,EAX
 0000130C  0F 95 C0			setnz	AL
 0000130F			$L000720:
 0000130F  84 C0			test	AL,AL
 00001311  74 15			jz	OFFSET $L000718
				;{

				;{194}:Console::WriteLn("Las matrices deben tener las mismas dimensiones para ser sumadas.");
 00001313  8D 05 00000402 R		lea	EAX,OFFSET $S000614
 00001319  6A 00			push	000000000h
 0000131B  50				push	EAX 
 0000131C  E8 00000000 E		call	 Console_WriteString
 00001321  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 00001326  EB 57			jmp	OFFSET $L000719

				; else {
 00001328			$L000718:
				;{

				;{196}:Console::WriteLn("La matriz resultado:");
 00001328  8D 05 000003ED R		lea	EAX,OFFSET $S000615
 0000132E  6A 00			push	000000000h
 00001330  50				push	EAX 
 00001331  E8 00000000 E		call	 Console_WriteString
 00001336  E8 00000000 E		call	 Console_WriteCrLf 

				;{197}:Program::SumMatrices(A, B, rA, rB, nOption == 1 ? Program::Sum : Program::Substract);
 0000133B  8B 85 FFFFF990		mov	EAX,dword ptr [EBP-0670h]
 00001341  50				push	EAX
 00001342  B8 00000001			mov	EAX,000000001h
 00001347  5A				pop	EDX
 00001348  3B D0			cmp	EDX,EAX
 0000134A  0F 94 C0			setz	AL
 0000134D  84 C0			test	AL,AL
 0000134F  74 07			jz	 $L000721
 00001351  B8 00000001			mov	EAX,000000001h
 00001356  EB 05			jmp	 $L000722
 00001358			$L000721:
 00001358  B8 00000002			mov	EAX,000000002h
 0000135D			$L000722:
 0000135D  50				push	EAX 
 0000135E  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 00001364  50				push	EAX 
 00001365  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 0000136B  50				push	EAX 
 0000136C  8D 85 FFFFF9C0		lea	EAX,dword ptr [EBP-0640h]
 00001372  50				push	EAX 
 00001373  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 00001379  50				push	EAX
 0000137A  E8 FFFFF636			call	 Program_SumMatrices
				;}
 0000137F			$L000719:

				; }
				;}
 0000137F  E9 00000274			jmp	OFFSET $L000714
 00001384			$L000723:
				;{

				;{203}:if(cA == rB)
 00001384  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 0000138A  50				push	EAX
 0000138B  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 00001391  5A				pop	EDX
 00001392  3B D0			cmp	EDX,EAX
 00001394  0F 94 C0			setz	AL
 00001397  84 C0			test	AL,AL
 00001399  74 44			jz	OFFSET $L000724
				;{

				;{205}:Console::WriteLn("La matriz resultado C = A*B es:\n");
 0000139B  8D 05 000003AB R		lea	EAX,OFFSET $S000617
 000013A1  6A 00			push	000000000h
 000013A3  50				push	EAX 
 000013A4  E8 00000000 E		call	 Console_WriteString
 000013A9  E8 00000000 E		call	 Console_WriteCrLf 

				;{206}:Program::MultiplyMatrices(A, B, rA, cA, rB, cB);
 000013AE  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 000013B4  50				push	EAX 
 000013B5  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 000013BB  50				push	EAX 
 000013BC  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 000013C2  50				push	EAX 
 000013C3  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 000013C9  50				push	EAX 
 000013CA  8D 85 FFFFF9C0		lea	EAX,dword ptr [EBP-0640h]
 000013D0  50				push	EAX 
 000013D1  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 000013D7  50				push	EAX
 000013D8  E8 FFFFF33F			call	 Program_MultiplyMatrices
				;}
 000013DD  EB 13			jmp	OFFSET $L000725

				; else {
 000013DF			$L000724:

				;{208}:Console::WriteLn("El numero de filas de B debe ser igual al numero de columnas de A.");
 000013DF  8D 05 000001BD R		lea	EAX,OFFSET $S000618
 000013E5  6A 00			push	000000000h
 000013E7  50				push	EAX 
 000013E8  E8 00000000 E		call	 Console_WriteString
 000013ED  E8 00000000 E		call	 Console_WriteCrLf 
 000013F2			$L000725:

				; }
				;}
 000013F2  E9 00000201			jmp	OFFSET $L000714
 000013F7			$L000726:
				;{

				;{213}:if(cB == rA)
 000013F7  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 000013FD  50				push	EAX
 000013FE  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00001404  5A				pop	EDX
 00001405  3B D0			cmp	EDX,EAX
 00001407  0F 94 C0			setz	AL
 0000140A  84 C0			test	AL,AL
 0000140C  74 44			jz	OFFSET $L000727
				;{

				;{215}:Console::WriteLn("La matriz resultado C = B*A es:\n");
 0000140E  8D 05 000003CC R		lea	EAX,OFFSET $S000620
 00001414  6A 00			push	000000000h
 00001416  50				push	EAX 
 00001417  E8 00000000 E		call	 Console_WriteString
 0000141C  E8 00000000 E		call	 Console_WriteCrLf 

				;{216}:Program::MultiplyMatrices(B, A, rB, cB, rA, cA);
 00001421  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 00001427  50				push	EAX 
 00001428  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 0000142E  50				push	EAX 
 0000142F  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 00001435  50				push	EAX 
 00001436  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 0000143C  50				push	EAX 
 0000143D  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 00001443  50				push	EAX 
 00001444  8D 85 FFFFF9C0		lea	EAX,dword ptr [EBP-0640h]
 0000144A  50				push	EAX
 0000144B  E8 FFFFF2CC			call	 Program_MultiplyMatrices
				;}
 00001450  EB 13			jmp	OFFSET $L000728

				; else {
 00001452			$L000727:

				;{218}:Console::WriteLn("El numero de filas de A debe ser igual al numero de columnas de B.");
 00001452  8D 05 0000017A R		lea	EAX,OFFSET $S000621
 00001458  6A 00			push	000000000h
 0000145A  50				push	EAX 
 0000145B  E8 00000000 E		call	 Console_WriteString
 00001460  E8 00000000 E		call	 Console_WriteCrLf 
 00001465			$L000728:

				; }
				;}
 00001465  E9 0000018E			jmp	OFFSET $L000714
 0000146A			$L000729:
				;{

				;{222}:Tr= Program::CalcTrace(A, rA, cA);
 0000146A  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 00001470  50				push	EAX 
 00001471  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00001477  50				push	EAX 
 00001478  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 0000147E  50				push	EAX
 0000147F  E8 FFFFF1A9			call	 Program_CalcTrace
 00001484  50				push	EAX
 00001485  52				push	EDX 
 00001486  DD C0			ffree	st
 00001488  DD 04 24			fld	qword ptr [ESP]
 0000148B  DD 9D FFFFF9B8		fstp	qword ptr [EBP-0648h]

				;{223}:Console::WriteLn("\nLa Traza de la matriz es = ", Tr);
 00001491  5A				pop	EDX
 00001492  58				pop	EAX 
 00001493  8D 05 000004DC R		lea	EAX,OFFSET $S000623
 00001499  6A 00			push	000000000h
 0000149B  50				push	EAX 
 0000149C  E8 00000000 E		call	 Console_WriteString
 000014A1  8B 95 FFFFF9B8		mov	EDX,dword ptr [EBP-0648h]
 000014A7  8B 85 FFFFF9BC		mov	EAX,dword ptr [EBP-0644h] 
 000014AD  50				push	EAX 
 000014AE  52				push	EDX 
 000014AF  E8 00000000 E		call	 Console_WriteDouble 
 000014B4  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 000014B9  E9 0000013A			jmp	OFFSET $L000714
 000014BE			$L000730:
				;{

				;{227}:Tr= Program::CalcTrace(B, rB, cB);
 000014BE  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 000014C4  50				push	EAX 
 000014C5  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 000014CB  50				push	EAX 
 000014CC  8D 85 FFFFF9C0		lea	EAX,dword ptr [EBP-0640h]
 000014D2  50				push	EAX
 000014D3  E8 FFFFF155			call	 Program_CalcTrace
 000014D8  50				push	EAX
 000014D9  52				push	EDX 
 000014DA  DD C0			ffree	st
 000014DC  DD 04 24			fld	qword ptr [ESP]
 000014DF  DD 9D FFFFF9B8		fstp	qword ptr [EBP-0648h]

				;{228}:Console::WriteLn("\nLa Traza de la matriz es = ", Tr);
 000014E5  5A				pop	EDX
 000014E6  58				pop	EAX 
 000014E7  8D 05 000004DC R		lea	EAX,OFFSET $S000623
 000014ED  6A 00			push	000000000h
 000014EF  50				push	EAX 
 000014F0  E8 00000000 E		call	 Console_WriteString
 000014F5  8B 95 FFFFF9B8		mov	EDX,dword ptr [EBP-0648h]
 000014FB  8B 85 FFFFF9BC		mov	EAX,dword ptr [EBP-0644h] 
 00001501  50				push	EAX 
 00001502  52				push	EDX 
 00001503  E8 00000000 E		call	 Console_WriteDouble 
 00001508  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 0000150D  E9 000000E6			jmp	OFFSET $L000714
 00001512			$L000731:
				;{

				;{232}:if(rA == cA)
 00001512  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00001518  50				push	EAX
 00001519  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 0000151F  5A				pop	EDX
 00001520  3B D0			cmp	EDX,EAX
 00001522  0F 94 C0			setz	AL
 00001525  84 C0			test	AL,AL
 00001527  74 2F			jz	OFFSET $L000732
				;{

				;{234}:Console::WriteLn("La Traspuesta de la matriz es:");
 00001529  8D 05 0000038C R		lea	EAX,OFFSET $S000626
 0000152F  6A 00			push	000000000h
 00001531  50				push	EAX 
 00001532  E8 00000000 E		call	 Console_WriteString
 00001537  E8 00000000 E		call	 Console_WriteCrLf 

				;{235}:Program::Traspose(A, rA, cA);
 0000153C  8B 85 FFFFF9A8		mov	EAX,dword ptr [EBP-0658h]
 00001542  50				push	EAX 
 00001543  8B 85 FFFFF9AC		mov	EAX,dword ptr [EBP-0654h]
 00001549  50				push	EAX 
 0000154A  8D 85 FFFFFCE0		lea	EAX,dword ptr [EBP-0320h]
 00001550  50				push	EAX
 00001551  E8 FFFFF619			call	 Program_Traspose
				;}
 00001556  EB 13			jmp	OFFSET $L000733

				; else {
 00001558			$L000732:

				;{237}:Console::WriteLn("Esta matriz no se puede trasponer ya que no es cuadrada.");
 00001558  8D 05 00000353 R		lea	EAX,OFFSET $S000627
 0000155E  6A 00			push	000000000h
 00001560  50				push	EAX 
 00001561  E8 00000000 E		call	 Console_WriteString
 00001566  E8 00000000 E		call	 Console_WriteCrLf 
 0000156B			$L000733:

				; }
				;}
 0000156B  E9 00000088			jmp	OFFSET $L000714
 00001570			$L000734:
				;{

				;{241}:if(rB == cB)
 00001570  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 00001576  50				push	EAX
 00001577  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 0000157D  5A				pop	EDX
 0000157E  3B D0			cmp	EDX,EAX
 00001580  0F 94 C0			setz	AL
 00001583  84 C0			test	AL,AL
 00001585  74 2F			jz	OFFSET $L000735
				;{

				;{243}:Console::WriteLn("La Traspuesta de la matriz es:");
 00001587  8D 05 0000038C R		lea	EAX,OFFSET $S000626
 0000158D  6A 00			push	000000000h
 0000158F  50				push	EAX 
 00001590  E8 00000000 E		call	 Console_WriteString
 00001595  E8 00000000 E		call	 Console_WriteCrLf 

				;{244}:Program::Traspose(B, rB, cB);
 0000159A  8B 85 FFFFF9A0		mov	EAX,dword ptr [EBP-0660h]
 000015A0  50				push	EAX 
 000015A1  8B 85 FFFFF9A4		mov	EAX,dword ptr [EBP-065Ch]
 000015A7  50				push	EAX 
 000015A8  8D 85 FFFFF9C0		lea	EAX,dword ptr [EBP-0640h]
 000015AE  50				push	EAX
 000015AF  E8 FFFFF5BB			call	 Program_Traspose
				;}
 000015B4  EB 13			jmp	OFFSET $L000736

				; else {
 000015B6			$L000735:

				;{246}:Console::WriteLn("Esta matriz no se puede trasponer ya que no es cuadrada.");
 000015B6  8D 05 00000353 R		lea	EAX,OFFSET $S000627
 000015BC  6A 00			push	000000000h
 000015BE  50				push	EAX 
 000015BF  E8 00000000 E		call	 Console_WriteString
 000015C4  E8 00000000 E		call	 Console_WriteCrLf 
 000015C9			$L000736:

				; }
				;}
 000015C9  EB 2D			jmp	OFFSET $L000714
 000015CB			$L000737:
				;{

				;{251}:bReEnterMatrices= true;
 000015CB  B8 00000001			mov	EAX,000000001h
 000015D0  88 85 FFFFF9B0		mov	byte ptr [EBP-0650h],AL
				;}
 000015D6  EB 20			jmp	OFFSET $L000714
 000015D8			$L000738:
				;{

				;{256}:bExitProgram= true;
 000015D8  B8 00000001			mov	EAX,000000001h
 000015DD  88 85 FFFFF9B4		mov	byte ptr [EBP-064Ch],AL
				;}
 000015E3  EB 13			jmp	OFFSET $L000714
 000015E5			$L000739:
				;{

				;{261}:Console::WriteLn("Entrada desconocida. Favor seleccionar una opcion.");
 000015E5  8D 05 000002BD R		lea	EAX,OFFSET $S000630
 000015EB  6A 00			push	000000000h
 000015ED  50				push	EAX 
 000015EE  E8 00000000 E		call	 Console_WriteString
 000015F3  E8 00000000 E		call	 Console_WriteCrLf 
				;}
 000015F8			$L000714:

				;{265}:if(false == bExitProgram)
 000015F8  33 C0			xor	EAX,EAX
 000015FA  50				push	EAX
 000015FB  0F B6 85			movzx	EAX,byte ptr [EBP-064Ch]
	   FFFFF9B4
 00001602  5A				pop	EDX
 00001603  38 C2			cmp	DL,AL
 00001605  0F 94 C0			setz	AL
 00001608  84 C0			test	AL,AL
 0000160A  74 1E			jz	OFFSET $L000740
				;{

				;{267}:Console::WriteLn("\n\nPresione una tecla para regresar...");
 0000160C  8D 05 00000506 R		lea	EAX,OFFSET $S000631
 00001612  6A 00			push	000000000h
 00001614  50				push	EAX 
 00001615  E8 00000000 E		call	 Console_WriteString
 0000161A  E8 00000000 E		call	 Console_WriteCrLf 

				;{268}:ch= Console::ReadChar();
 0000161F  E8 00000000 E		call	 Console_ReadChar
 00001624  88 85 FFFFF98C		mov	byte ptr [EBP-0674h],AL
				;}
 0000162A			$L000740:
				;}
 0000162A			$L000712:

				;{268}:while(false == bExitProgram && false == bReEnterMatrices)
 0000162A  33 C0			xor	EAX,EAX
 0000162C  50				push	EAX
 0000162D  0F B6 85			movzx	EAX,byte ptr [EBP-064Ch]
	   FFFFF9B4
 00001634  5A				pop	EDX
 00001635  38 C2			cmp	DL,AL
 00001637  0F 94 C0			setz	AL
 0000163A  84 C0			test	AL,AL
 0000163C  74 10			jz	OFFSET $L000742
 0000163E  33 C0			xor	EAX,EAX
 00001640  50				push	EAX
 00001641  0F B6 85			movzx	EAX,byte ptr [EBP-0650h]
	   FFFFF9B0
 00001648  5A				pop	EDX
 00001649  38 C2			cmp	DL,AL
 0000164B  0F 94 C0			setz	AL
 0000164E			$L000742:
 0000164E  84 C0			test	AL,AL
 00001650  0F 85 FFFFFB58		jne	OFFSET $L000711
 00001656			$L000713:

				;{273}:if(bExitProgram)
 00001656  0F B6 85			movzx	EAX,byte ptr [EBP-064Ch]
	   FFFFF9B4
 0000165D  84 C0			test	AL,AL
 0000165F  74 02			jz	OFFSET $L000743

				;break;
 00001661  EB 1D			jmp	OFFSET $L000674
 00001663			$L000743:

				;{275}:if(bReEnterMatrices)
 00001663  0F B6 85			movzx	EAX,byte ptr [EBP-0650h]
	   FFFFF9B0
 0000166A  84 C0			test	AL,AL
 0000166C  74 0D			jz	OFFSET $L000745
				;{

				;{276}:bReEnterMatrices= false;
 0000166E  33 C0			xor	EAX,EAX
 00001670  88 85 FFFFF9B0		mov	byte ptr [EBP-0650h],AL

				;continue;
 00001676  E9 FFFFF601			jmp	OFFSET $L000673
				;}
 0000167B			$L000745:
				;}
 0000167B  E9 FFFFF5FC			jmp	OFFSET $L000673
 00001680			$L000674:
				;}
 00001680			$L000576:

 00001680  5F				pop	EDI
 00001681  5E				pop	ESI 
 00001682  5B				pop	EBX 
 00001683  8B E5			mov	ESP,EBP
 00001685  5D				pop	EBP 
 00001686  C3				ret	
 00001687			Program_main ENDP

 00001687			__System_Hpp_Runtime_Init PROC

 00001687  55				push	EBP
 00001688  8B EC			mov	EBP,ESP
 0000168A  51				push	ECX 
 0000168B  53				push	EBX 
 0000168C  56				push	ESI 
 0000168D  57				push	EDI 
 0000168E  E8 00000000 E		call	 GetVersion
 00001693  A3 00000554 R		mov	 __osver,EAX ;os version
 00001698  A1 00000554 R		mov	EAX, __osver 
 0000169D  C1 E8 08			shr	EAX,000000008h
 000016A0  25 000000FF			and	EAX,0000000FFh
 000016A5  A3 00000558 R		mov	 __winminor,EAX ;windows minor
 000016AA  8B 0D 00000554 R		mov	ECX, __osver 
 000016B0  81 E1 000000FF		and	ECX,0000000FFh 
 000016B6  89 0D 0000055C R		mov	 __winmajor,ECX ;windows major
 000016BC  8B 15 0000055C R		mov	EDX,dword ptr __winmajor 
 000016C2  C1 E2 08			shl	EDX,000000008h
 000016C5  03 15 00000558 R		add	EDX,dword ptr __winminor
 000016CB  89 15 00000560 R		mov	dword ptr __winver,EDX ;windows version
 000016D1  A1 00000554 R		mov	EAX, __osver 
 000016D6  C1 E8 10			shr	EAX,000000010h 
 000016D9  25 0000FFFF			and	EAX,00000FFFFh 
 000016DE  A3 00000554 R		mov	 __osver,EAX 
 000016E3  E8 FFFFF564			call	 Program_main ;user entry point (stdcall calling convention)
 000016E8  50				push	EAX
 000016E9  E8 00000000 E		call	 System_Exit 

 000016EE  5F				pop	EDI
 000016EF  5E				pop	ESI 
 000016F0  5B				pop	EBX 
 000016F1  8B E5			mov	ESP,EBP
 000016F3  5D				pop	EBP 
 000016F4  C3				ret	
 000016F5			__System_Hpp_Runtime_Init ENDP

 00000000			.DATA ;data segment
 = FFFFFFFF			File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
 = FFFFFFFF			File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

 00000000 20 20 00		$S000531 		BYTE 	"  ",0
 00000003 30 2E 20 4D 6F	$S000611 		BYTE 	"0. Mostrar las Matrices",0Ah,"1. Sumar las matrices.",0Ah,"2. Restar las matrices.",0Ah,"3. Multiplicar las matrices (A*B).",0Ah,"4. Multiplicar las matrices (B*A).",0Ah,"5. Calcular la traza de A",0Ah,"6. Calcular la traza de B.",0Ah,"7. Trasponer matriz A.",0Ah,"8. Trasponer matriz B.",0Ah,"9. Re-Entrar Matrices",0Ah,"10. Salir",0Ah,0Ah,0
	   73 74 72 61 72
	   20 6C 61 73 20
	   4D 61 74 72 69
	   63 65 73 0A 31
	   2E 20 53 75 6D
	   61 72 20 6C 61
	   73 20 6D 61 74
	   72 69 63 65 73
	   2E 0A 32 2E 20
	   52 65 73 74 61
	   72 20 6C 61 73
	   20 6D 61 74 72
	   69 63 65 73 2E
	   0A 33 2E 20 4D
	   75 6C 74 69 70
	   6C 69 63 61 72
	   20 6C 61 73 20
	   6D 61 74 72 69
	   63 65 73 20 28
	   41 2A 42 29 2E
	   0A 34 2E 20 4D
	   75 6C 74 69 70
	   6C 69 63 61 72
	   20 6C 61 73 20
	   6D 61 74 72 69
	   63 65 73 20 28
	   42 2A 41 29 2E
	   0A 35 2E 20 43
	   61 6C 63 75 6C
	   61 72 20 6C 61
	   20 74 72 61 7A
	   61 20 64 65 20
	   41 0A 36 2E 20
	   43 61 6C 63 75
	   6C 61 72 20 6C
	   61 20 74 72 61
	   7A 61 20 64 65
	   20 42 2E 0A 37
	   2E 20 54 72 61
	   73 70 6F 6E 65
	   72 20 6D 61 74
	   72 69 7A 20 41
	   2E 0A 38 2E 20
	   54 72 61 73 70
	   6F 6E 65 72 20
	   6D 61 74 72 69
	   7A 20 42 2E 0A
	   39 2E 20 52 65
	   2D 45 6E 74 72
	   61 72 20 4D 61
	   74 72 69 63 65
	   73 0A 31 30 2E
	   20 53 61 6C 69
	   72 0A 0A 00
 00000115 3E 3A 00		$S000612 		BYTE 	">:",0
 00000118 45 6C 20 6E 75	$S000598 		BYTE 	"El numero de columnas debe estar en 0 < c < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?",0
	   6D 65 72 6F 20
	   64 65 20 63 6F
	   6C 75 6D 6E 61
	   73 20 64 65 62
	   65 20 65 73 74
	   61 72 20 65 6E
	   20 30 20 3C 20
	   63 20 3C 20 31
	   30 20 70 61 72
	   61 20 61 6D 62
	   61 73 20 6D 61
	   74 72 69 63 65
	   73 2E 20 44 65
	   73 65 61 20 65
	   6D 70 65 7A 61
	   72 20 64 65 20
	   6E 75 65 76 6F
	   20 28 59 2F 4E
	   29 3F 00
 0000017A 45 6C 20 6E 75	$S000621 		BYTE 	"El numero de filas de A debe ser igual al numero de columnas de B.",0
	   6D 65 72 6F 20
	   64 65 20 66 69
	   6C 61 73 20 64
	   65 20 41 20 64
	   65 62 65 20 73
	   65 72 20 69 67
	   75 61 6C 20 61
	   6C 20 6E 75 6D
	   65 72 6F 20 64
	   65 20 63 6F 6C
	   75 6D 6E 61 73
	   20 64 65 20 42
	   2E 00
 000001BD 45 6C 20 6E 75	$S000618 		BYTE 	"El numero de filas de B debe ser igual al numero de columnas de A.",0
	   6D 65 72 6F 20
	   64 65 20 66 69
	   6C 61 73 20 64
	   65 20 42 20 64
	   65 62 65 20 73
	   65 72 20 69 67
	   75 61 6C 20 61
	   6C 20 6E 75 6D
	   65 72 6F 20 64
	   65 20 63 6F 6C
	   75 6D 6E 61 73
	   20 64 65 20 41
	   2E 00
 00000200 45 6C 20 6E 75	$S000575 		BYTE 	"El numero de filas de B debe ser igual al numero de filas de A.",0
	   6D 65 72 6F 20
	   64 65 20 66 69
	   6C 61 73 20 64
	   65 20 42 20 64
	   65 62 65 20 73
	   65 72 20 69 67
	   75 61 6C 20 61
	   6C 20 6E 75 6D
	   65 72 6F 20 64
	   65 20 66 69 6C
	   61 73 20 64 65
	   20 41 2E 00
 00000240 45 6C 20 6E 75	$S000594 		BYTE 	"El numero de filas debe estar en 0 < r < 10 para ambas matrices. Desea empezar de nuevo (Y/N)?",0
	   6D 65 72 6F 20
	   64 65 20 66 69
	   6C 61 73 20 64
	   65 62 65 20 65
	   73 74 61 72 20
	   65 6E 20 30 20
	   3C 20 72 20 3C
	   20 31 30 20 70
	   61 72 61 20 61
	   6D 62 61 73 20
	   6D 61 74 72 69
	   63 65 73 2E 20
	   44 65 73 65 61
	   20 65 6D 70 65
	   7A 61 72 20 64
	   65 20 6E 75 65
	   76 6F 20 28 59
	   2F 4E 29 3F 00
 0000029F 45 6C 65 6D 65	$S000604 		BYTE 	"Elemento en A[",0
	   6E 74 6F 20 65
	   6E 20 41 5B 00
 000002AE 45 6C 65 6D 65	$S000607 		BYTE 	"Elemento en B[",0
	   6E 74 6F 20 65
	   6E 20 42 5B 00
 000002BD 45 6E 74 72 61	$S000630 		BYTE 	"Entrada desconocida. Favor seleccionar una opcion.",0
	   64 61 20 64 65
	   73 63 6F 6E 6F
	   63 69 64 61 2E
	   20 46 61 76 6F
	   72 20 73 65 6C
	   65 63 63 69 6F
	   6E 61 72 20 75
	   6E 61 20 6F 70
	   63 69 6F 6E 2E
	   00
 000002F0 45 6E 74 72 65	$S000583 		BYTE 	"Entre las dimensiones de dos matrices:",0Ah,0
	   20 6C 61 73 20
	   64 69 6D 65 6E
	   73 69 6F 6E 65
	   73 20 64 65 20
	   64 6F 73 20 6D
	   61 74 72 69 63
	   65 73 3A 0A 00
 00000318 45 6E 74 72 65	$S000584 		BYTE 	"Entre las filas de A: ",0
	   20 6C 61 73 20
	   66 69 6C 61 73
	   20 64 65 20 41
	   3A 20 00
 0000032F 45 6E 74 72 65	$S000599 		BYTE 	"Entre los valores para la matriz A[",0
	   20 6C 6F 73 20
	   76 61 6C 6F 72
	   65 73 20 70 61
	   72 61 20 6C 61
	   20 6D 61 74 72
	   69 7A 20 41 5B
	   00
 00000353 45 73 74 61 20	$S000627 		BYTE 	"Esta matriz no se puede trasponer ya que no es cuadrada.",0
	   6D 61 74 72 69
	   7A 20 6E 6F 20
	   73 65 20 70 75
	   65 64 65 20 74
	   72 61 73 70 6F
	   6E 65 72 20 79
	   61 20 71 75 65
	   20 6E 6F 20 65
	   73 20 63 75 61
	   64 72 61 64 61
	   2E 00
 0000038C 4C 61 20 54 72	$S000626 		BYTE 	"La Traspuesta de la matriz es:",0
	   61 73 70 75 65
	   73 74 61 20 64
	   65 20 6C 61 20
	   6D 61 74 72 69
	   7A 20 65 73 3A
	   00
 000003AB 4C 61 20 6D 61$S000617 		BYTE 	"La matriz resultado C = A*B es:",0Ah,0
	   74 72 69 7A 20
	   72 65 73 75 6C
	   74 61 64 6F 20
	   43 20 3D 20 41
	   2A 42 20 65 73
	   3A 0A 00
 000003CC 4C 61 20 6D 61	$S000620 		BYTE 	"La matriz resultado C = B*A es:",0Ah,0
	   74 72 69 7A 20
	   72 65 73 75 6C
	   74 61 64 6F 20
	   43 20 3D 20 42
	   2A 41 20 65 73
	   3A 0A 00
 000003ED 4C 61 20 6D 61	$S000615 		BYTE 	"La matriz resultado:",0
	   74 72 69 7A 20
	   72 65 73 75 6C
	   74 61 64 6F 3A
	   00
 00000402 4C 61 73 20 6D	$S000614 		BYTE 	"Las matrices deben tener las mismas dimensiones para ser sumadas.",0
	   61 74 72 69 63
	   65 73 20 64 65
	   62 65 6E 20 74
	   65 6E 65 72 20
	   6C 61 73 20 6D
	   69 73 6D 61 73
	   20 64 69 6D 65
	   6E 73 69 6F 6E
	   65 73 20 70 61
	   72 61 20 73 65
	   72 20 73 75 6D
	   61 64 61 73 2E
	   00
 00000444 4D 5B 00		$S000541 		BYTE 	"M[",0
 00000447 4D 61 74 72 69	$S000608 		BYTE 	"Matriz A:",0Ah,0
	   7A 20 41 3A 0A
	   00
 00000452 50 72 6F 67 72	$S000582 		BYTE 	"Programa de Matrices",0Ah,0Ah,0
	   61 6D 61 20 64
	   65 20 4D 61 74
	   72 69 63 65 73
	   0A 0A 00
 00000469 0A 45 6E 74 72	$S000586 		BYTE 	0Ah,"Entre las columnas de A: ",0
	   65 20 6C 61 73
	   20 63 6F 6C 75
	   6D 6E 61 73 20
	   64 65 20 41 3A
	   20 00
 00000484 0A 45 6E 74 72	$S000590 		BYTE 	0Ah,"Entre las columnas de B: ",0
	   65 20 6C 61 73
	   20 63 6F 6C 75
	   6D 6E 61 73 20
	   64 65 20 42 3A
	   20 00
 0000049F 0A 45 6E 74 72	$S000588 		BYTE 	0Ah,"Entre las filas de B: ",0
	   65 20 6C 61 73
	   20 66 69 6C 61
	   73 20 64 65 20
	   42 3A 20 00
 000004B7 0A 45 6E 74 72	$S000606 		BYTE 	0Ah,"Entre los valores para la matriz B[",0
	   65 20 6C 6F 73
	   20 76 61 6C 6F
	   72 65 73 20 70
	   61 72 61 20 6C
	   61 20 6D 61 74
	   72 69 7A 20 42
	   5B 00
 000004DC 0A 4C 61 20 54	$S000623 		BYTE 	0Ah,"La Traza de la matriz es = ",0
	   72 61 7A 61 20
	   64 65 20 6C 61
	   20 6D 61 74 72
	   69 7A 20 65 73
	   20 3D 20 00
 000004F9 0A 0A 4D 61 74	$S000609 		BYTE 	0Ah,0Ah,"Matriz B:",0Ah,0
	   72 69 7A 20 42
	   3A 0A 00
 00000506 0A 0A 50 72 65	$S000631 		BYTE 	0Ah,0Ah,"Presione una tecla para regresar...",0
	   73 69 6F 6E 65
	   20 75 6E 61 20
	   74 65 63 6C 61
	   20 70 61 72 61
	   20 72 65 67 72
	   65 73 61 72 2E
	   2E 2E 00
 0000052C 0A 0A 51 75 65	$S000610 		BYTE 	0Ah,0Ah,"Que deseas hacer?",0Ah,0
	   20 64 65 73 65
	   61 73 20 68 61
	   63 65 72 3F 0A
	   00
 00000541 0A 7C 20 00		$S000529 		BYTE 	0Ah,"| ",0
 00000545 5D 20 3D 20 00	$S000605 		BYTE 	"] = ",0
 0000054A 5D 3D 20 00		$S000543 		BYTE 	"]= ",0
 0000054E 5D 5B 00		$S000600 		BYTE 	"][",0
 00000551 7C 20 00		$S000532 		BYTE 	"| ",0

 00000554 00000000		__osver 		DWORD 	0;Windows OS version
 00000558 00000000		__winminor 		DWORD 	0;Windows minor version
 0000055C 00000000		__winmajor 		DWORD 	0;Windows major version
 00000560 00000000		__winver 		DWORD 	0;Windows version
 00000564  00000020 [		__computer 		BYTE 	000000020h DUP(?);Computer name
	    00
	   ]
 00000584 00000000		___argv 		DWORD 	0;Array of argument values
 00000588 00000000		___argc 		DWORD 	0;Argument count

				END __System_Hpp_Runtime_Init

Microsoft (R) Macro Assembler Version 6.15.8803		    03/19/13 15:13:31
TestMatrices.hpp					     Symbols 2 - 1
This file was automatically generated by the 32-bit H++ Comp



Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPos  . . . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  maxWinSize . . . . . . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00100000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 0000058C Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000016F5 Para	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ClearScreen  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_GetTitle . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_MoveWindow . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ReadChar . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ReadDouble . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ReadInteger  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_ReadString . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_SetConsoleSize . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_SetCursorPos . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_SetTextColor . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_SetTitle . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteBoolean . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteChar  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteCrlf  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteDouble  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteInteger64 . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteInteger . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Console_WriteString  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Close . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_FileSize  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Open  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Read  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Seek  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
File_Write . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_CompareToInteger .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_Compare  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_FromInt64  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_FromInt  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_ToInt64  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_ToInt  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_fromString . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_toStringEx . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatingPoint_toString . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVersion . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Integer_fromString . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Integer_toStringEx . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Integer_toString . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Abs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_ArcTan  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_ChangeSign  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Cosec . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Cos . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Cotan . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_DegreesToRadians  . . . . .	P Near	 00000000 _TEXT	Length= 0000004C Public STDCALL
  $L000469 . . . . . . . . . . .	L Near	 00000043 _TEXT	
Math_Even  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Exp . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Gcd . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_GetNumberFrom . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Hyperbolic_HCosec . . . . .	P Near	 000000AC _TEXT	Length= 00000062 Public STDCALL
  $L000492 . . . . . . . . . . .	L Near	 00000105 _TEXT	
Math_Hyperbolic_HCos . . . . . .	P Near	 0000004C _TEXT	Length= 00000060 Public STDCALL
  $L000486 . . . . . . . . . . .	L Near	 000000A3 _TEXT	
Math_Hyperbolic_HCotan . . . . .	P Near	 0000010E _TEXT	Length= 00000086 Public STDCALL
  $L000494 . . . . . . . . . . .	L Near	 0000018B _TEXT	
Math_Hyperbolic_HSec . . . . . .	P Near	 00000194 _TEXT	Length= 00000060 Public STDCALL
  $L000490 . . . . . . . . . . .	L Near	 000001EB _TEXT	
Math_Hyperbolic_HSin . . . . . .	P Near	 000001F4 _TEXT	Length= 00000062 Public STDCALL
  $L000483 . . . . . . . . . . .	L Near	 0000024D _TEXT	
Math_Hyperbolic_HTan . . . . . .	P Near	 00000256 _TEXT	Length= 00000086 Public STDCALL
  $L000488 . . . . . . . . . . .	L Near	 000002D3 _TEXT	
Math_Hyperbolic_Inverse_HArccosec 	P Near	 00000345 _TEXT	Length= 0000009F Public STDCALL
  $L000506 . . . . . . . . . . .	L Near	 000003DB _TEXT	
Math_Hyperbolic_Inverse_HArccos 	P Near	 000002DC _TEXT	Length= 00000069 Public STDCALL
  $L000500 . . . . . . . . . . .	L Near	 0000033C _TEXT	
Math_Hyperbolic_Inverse_HArccotan 	P Near	 000003E4 _TEXT	Length= 00000086 Public STDCALL
  $L000508 . . . . . . . . . . .	L Near	 00000461 _TEXT	
Math_Hyperbolic_Inverse_HArcsec 	P Near	 0000046A _TEXT	Length= 0000008A Public STDCALL
  $L000504 . . . . . . . . . . .	L Near	 000004EB _TEXT	
Math_Hyperbolic_Inverse_HArcsin 	P Near	 000004F4 _TEXT	Length= 00000067 Public STDCALL
  $L000497 . . . . . . . . . . .	L Near	 00000552 _TEXT	
Math_Hyperbolic_Inverse_HArctan 	P Near	 0000055B _TEXT	Length= 00000086 Public STDCALL
  $L000502 . . . . . . . . . . .	L Near	 000005D8 _TEXT	
Math_IEEEModulus . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Init  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arccosec  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arccos  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arccotan  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arcsec  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Inverse_Arcsin  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Ln  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_LogN_base . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_MantissaOf  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Max . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Min . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_ModulusTruncateDivisor  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Modulus . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Odd . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Pow2  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Pow . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_RadiansToDegrees  . . . . .	P Near	 000005E1 _TEXT	Length= 0000004C Public STDCALL
  $L000466 . . . . . . . . . . .	L Near	 00000624 _TEXT	
Math_Round . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sign  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sqrt  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Sqr . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Tan . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_Trunc . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log10 . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log2  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log_10_base2  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log_2_base10  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log_2_base_e  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_log_e_base2 . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Math_pi  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Program_CalcTrace  . . . . . . .	P Near	 0000062D _TEXT	Length= 000000EF Public STDCALL
  $L000634 . . . . . . . . . . .	L Near	 00000655 _TEXT	
  $L000633 . . . . . . . . . . .	L Near	 0000065B _TEXT	
  $L000635 . . . . . . . . . . .	L Near	 0000070B _TEXT	
  $L000533 . . . . . . . . . . .	L Near	 00000713 _TEXT	
Program_MultiplyMatrices . . . .	P Near	 0000071C _TEXT	Length= 000001F2 Public STDCALL
  $L000639 . . . . . . . . . . .	L Near	 0000074D _TEXT	
  $L000638 . . . . . . . . . . .	L Near	 00000759 _TEXT	
  $L000642 . . . . . . . . . . .	L Near	 00000777 _TEXT	
  $L000641 . . . . . . . . . . .	L Near	 00000783 _TEXT	
  $L000643 . . . . . . . . . . .	L Near	 000007BA _TEXT	
  $L000640 . . . . . . . . . . .	L Near	 000007BC _TEXT	
  $L000645 . . . . . . . . . . .	L Near	 000007C6 _TEXT	
  $L000644 . . . . . . . . . . .	L Near	 000007D2 _TEXT	
  $L000648 . . . . . . . . . . .	L Near	 000007F4 _TEXT	
  $L000647 . . . . . . . . . . .	L Near	 00000800 _TEXT	
  $L000651 . . . . . . . . . . .	L Near	 00000822 _TEXT	
  $L000650 . . . . . . . . . . .	L Near	 0000082E _TEXT	
  $L000652 . . . . . . . . . . .	L Near	 000008D2 _TEXT	
  $L000649 . . . . . . . . . . .	L Near	 000008D7 _TEXT	
  $L000646 . . . . . . . . . . .	L Near	 000008DC _TEXT	
  $L000636 . . . . . . . . . . .	L Near	 000008F2 _TEXT	
  $L000637 . . . . . . . . . . .	L Near	 00000905 _TEXT	
  $L000564 . . . . . . . . . . .	L Near	 00000905 _TEXT	
Program_ShowMatrixForm . . . . .	P Near	 0000090E _TEXT	Length= 000000A7 Public STDCALL
  $L000654 . . . . . . . . . . .	L Near	 0000091E _TEXT	
  $L000653 . . . . . . . . . . .	L Near	 00000924 _TEXT	
  $L000657 . . . . . . . . . . .	L Near	 0000094A _TEXT	
  $L000656 . . . . . . . . . . .	L Near	 00000950 _TEXT	
  $L000658 . . . . . . . . . . .	L Near	 00000999 _TEXT	
  $L000655 . . . . . . . . . . .	L Near	 000009AC _TEXT	
  $L000523 . . . . . . . . . . .	L Near	 000009AC _TEXT	
Program_SumMatrices  . . . . . .	P Near	 000009B5 _TEXT	Length= 000001BA Public STDCALL
  $L000660 . . . . . . . . . . .	L Near	 000009D9 _TEXT	
  $L000659 . . . . . . . . . . .	L Near	 000009E5 _TEXT	
  $L000663 . . . . . . . . . . .	L Near	 00000A07 _TEXT	
  $L000662 . . . . . . . . . . .	L Near	 00000A13 _TEXT	
  $L000665 . . . . . . . . . . .	L Near	 00000AA8 _TEXT	
  $L000666 . . . . . . . . . . .	L Near	 00000B12 _TEXT	
  $L000664 . . . . . . . . . . .	L Near	 00000B4D _TEXT	
  $L000661 . . . . . . . . . . .	L Near	 00000B52 _TEXT	
  $L000554 . . . . . . . . . . .	L Near	 00000B66 _TEXT	
Program_Traspose . . . . . . . .	P Near	 00000B6F _TEXT	Length= 000000DD Public STDCALL
  $L000668 . . . . . . . . . . .	L Near	 00000B8B _TEXT	
  $L000667 . . . . . . . . . . .	L Near	 00000B97 _TEXT	
  $L000671 . . . . . . . . . . .	L Near	 00000BB9 _TEXT	
  $L000670 . . . . . . . . . . .	L Near	 00000BC5 _TEXT	
  $L000672 . . . . . . . . . . .	L Near	 00000C2A _TEXT	
  $L000669 . . . . . . . . . . .	L Near	 00000C2F _TEXT	
  $L000544 . . . . . . . . . . .	L Near	 00000C43 _TEXT	
Program_main . . . . . . . . . .	P Near	 00000C4C _TEXT	Length= 00000A3B Public STDCALL
  $L000673 . . . . . . . . . . .	L Near	 00000C7C _TEXT	
  $L000677 . . . . . . . . . . .	L Near	 00000D4A _TEXT	
  $L000680 . . . . . . . . . . .	L Near	 00000D96 _TEXT	
  $L000678 . . . . . . . . . . .	L Near	 00000D9F _TEXT	
  $L000675 . . . . . . . . . . .	L Near	 00000DA4 _TEXT	
  $L000683 . . . . . . . . . . .	L Near	 00000DCC _TEXT	
  $L000686 . . . . . . . . . . .	L Near	 00000E18 _TEXT	
  $L000684 . . . . . . . . . . .	L Near	 00000E21 _TEXT	
  $L000681 . . . . . . . . . . .	L Near	 00000E26 _TEXT	
  $L000689 . . . . . . . . . . .	L Near	 00000E48 _TEXT	
  $L000692 . . . . . . . . . . .	L Near	 00000E94 _TEXT	
  $L000690 . . . . . . . . . . .	L Near	 00000E9D _TEXT	
  $L000687 . . . . . . . . . . .	L Near	 00000EA2 _TEXT	
  $L000695 . . . . . . . . . . .	L Near	 00000ECA _TEXT	
  $L000698 . . . . . . . . . . .	L Near	 00000F16 _TEXT	
  $L000696 . . . . . . . . . . .	L Near	 00000F1F _TEXT	
  $L000693 . . . . . . . . . . .	L Near	 00000F24 _TEXT	
  $L000700 . . . . . . . . . . .	L Near	 00000F72 _TEXT	
  $L000699 . . . . . . . . . . .	L Near	 00000F7E _TEXT	
  $L000703 . . . . . . . . . . .	L Near	 00000FA3 _TEXT	
  $L000702 . . . . . . . . . . .	L Near	 00000FAF _TEXT	
  $L000704 . . . . . . . . . . .	L Near	 00001037 _TEXT	
  $L000701 . . . . . . . . . . .	L Near	 0000103C _TEXT	
  $L000706 . . . . . . . . . . .	L Near	 0000108A _TEXT	
  $L000705 . . . . . . . . . . .	L Near	 00001096 _TEXT	
  $L000709 . . . . . . . . . . .	L Near	 000010BB _TEXT	
  $L000708 . . . . . . . . . . .	L Near	 000010C7 _TEXT	
  $L000710 . . . . . . . . . . .	L Near	 0000114F _TEXT	
  $L000707 . . . . . . . . . . .	L Near	 00001154 _TEXT	
  $L000711 . . . . . . . . . . .	L Near	 000011AE _TEXT	
  $L000715 . . . . . . . . . . .	L Near	 00001286 _TEXT	
  $L000716 . . . . . . . . . . .	L Near	 000012E5 _TEXT	
  $L000717 . . . . . . . . . . .	L Near	 000012E5 _TEXT	
  $L000720 . . . . . . . . . . .	L Near	 0000130F _TEXT	
  $L000718 . . . . . . . . . . .	L Near	 00001328 _TEXT	
  $L000721 . . . . . . . . . . .	L Near	 00001358 _TEXT	
  $L000722 . . . . . . . . . . .	L Near	 0000135D _TEXT	
  $L000719 . . . . . . . . . . .	L Near	 0000137F _TEXT	
  $L000723 . . . . . . . . . . .	L Near	 00001384 _TEXT	
  $L000724 . . . . . . . . . . .	L Near	 000013DF _TEXT	
  $L000725 . . . . . . . . . . .	L Near	 000013F2 _TEXT	
  $L000726 . . . . . . . . . . .	L Near	 000013F7 _TEXT	
  $L000727 . . . . . . . . . . .	L Near	 00001452 _TEXT	
  $L000728 . . . . . . . . . . .	L Near	 00001465 _TEXT	
  $L000729 . . . . . . . . . . .	L Near	 0000146A _TEXT	
  $L000730 . . . . . . . . . . .	L Near	 000014BE _TEXT	
  $L000731 . . . . . . . . . . .	L Near	 00001512 _TEXT	
  $L000732 . . . . . . . . . . .	L Near	 00001558 _TEXT	
  $L000733 . . . . . . . . . . .	L Near	 0000156B _TEXT	
  $L000734 . . . . . . . . . . .	L Near	 00001570 _TEXT	
  $L000735 . . . . . . . . . . .	L Near	 000015B6 _TEXT	
  $L000736 . . . . . . . . . . .	L Near	 000015C9 _TEXT	
  $L000737 . . . . . . . . . . .	L Near	 000015CB _TEXT	
  $L000738 . . . . . . . . . . .	L Near	 000015D8 _TEXT	
  $L000739 . . . . . . . . . . .	L Near	 000015E5 _TEXT	
  $L000714 . . . . . . . . . . .	L Near	 000015F8 _TEXT	
  $L000740 . . . . . . . . . . .	L Near	 0000162A _TEXT	
  $L000712 . . . . . . . . . . .	L Near	 0000162A _TEXT	
  $L000742 . . . . . . . . . . .	L Near	 0000164E _TEXT	
  $L000713 . . . . . . . . . . .	L Near	 00001656 _TEXT	
  $L000743 . . . . . . . . . . .	L Near	 00001663 _TEXT	
  $L000745 . . . . . . . . . . .	L Near	 0000167B _TEXT	
  $L000674 . . . . . . . . . . .	L Near	 00001680 _TEXT	
  $L000576 . . . . . . . . . . .	L Near	 00001680 _TEXT	
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringCompare . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringCopy  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringLCase . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringLength2 . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringLength  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringSet . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StringHandling_StringUCase . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_BreakPoint  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_CommandLineArgs . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Debug_OutputString  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Execute . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Exit  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_GetCommandLineArgv  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_GetTickCount  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_IsDebuggerPresent . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_LastError . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Alloc  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Destroy  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Free . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_GetProcessHeap . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Memset . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_New  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_SizeFor  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Memory_Size . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_ShowMessage . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
System_Sleep . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
__System_Hpp_Runtime_Init  . . .	P Near	 00001687 _TEXT	Length= 0000006E Public STDCALL
__purecall . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

$S000529 . . . . . . . . . . . .	Byte	 00000541 _DATA	
$S000531 . . . . . . . . . . . .	Byte	 00000000 _DATA	
$S000532 . . . . . . . . . . . .	Byte	 00000551 _DATA	
$S000541 . . . . . . . . . . . .	Byte	 00000444 _DATA	
$S000543 . . . . . . . . . . . .	Byte	 0000054A _DATA	
$S000575 . . . . . . . . . . . .	Byte	 00000200 _DATA	
$S000582 . . . . . . . . . . . .	Byte	 00000452 _DATA	
$S000583 . . . . . . . . . . . .	Byte	 000002F0 _DATA	
$S000584 . . . . . . . . . . . .	Byte	 00000318 _DATA	
$S000586 . . . . . . . . . . . .	Byte	 00000469 _DATA	
$S000588 . . . . . . . . . . . .	Byte	 0000049F _DATA	
$S000590 . . . . . . . . . . . .	Byte	 00000484 _DATA	
$S000594 . . . . . . . . . . . .	Byte	 00000240 _DATA	
$S000598 . . . . . . . . . . . .	Byte	 00000118 _DATA	
$S000599 . . . . . . . . . . . .	Byte	 0000032F _DATA	
$S000600 . . . . . . . . . . . .	Byte	 0000054E _DATA	
$S000604 . . . . . . . . . . . .	Byte	 0000029F _DATA	
$S000605 . . . . . . . . . . . .	Byte	 00000545 _DATA	
$S000606 . . . . . . . . . . . .	Byte	 000004B7 _DATA	
$S000607 . . . . . . . . . . . .	Byte	 000002AE _DATA	
$S000608 . . . . . . . . . . . .	Byte	 00000447 _DATA	
$S000609 . . . . . . . . . . . .	Byte	 000004F9 _DATA	
$S000610 . . . . . . . . . . . .	Byte	 0000052C _DATA	
$S000611 . . . . . . . . . . . .	Byte	 00000003 _DATA	
$S000612 . . . . . . . . . . . .	Byte	 00000115 _DATA	
$S000614 . . . . . . . . . . . .	Byte	 00000402 _DATA	
$S000615 . . . . . . . . . . . .	Byte	 000003ED _DATA	
$S000617 . . . . . . . . . . . .	Byte	 000003AB _DATA	
$S000618 . . . . . . . . . . . .	Byte	 000001BD _DATA	
$S000620 . . . . . . . . . . . .	Byte	 000003CC _DATA	
$S000621 . . . . . . . . . . . .	Byte	 0000017A _DATA	
$S000623 . . . . . . . . . . . .	Byte	 000004DC _DATA	
$S000626 . . . . . . . . . . . .	Byte	 0000038C _DATA	
$S000627 . . . . . . . . . . . .	Byte	 00000353 _DATA	
$S000630 . . . . . . . . . . . .	Byte	 000002BD _DATA	
$S000631 . . . . . . . . . . . .	Byte	 00000506 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
ConsoleHandle  . . . . . . . . .	DWord	 00000000 FLAT	External STDCALL
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
File_INVALID_HANDLE_VALUE  . . .	Number	 FFFFFFFFh   
File_INVALID_SET_FILE_POINTER  .	Number	 FFFFFFFFh   
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
___argc  . . . . . . . . . . . .	DWord	 00000588 _DATA	
___argv  . . . . . . . . . . . .	DWord	 00000584 _DATA	
__computer . . . . . . . . . . .	Byte	 00000564 _DATA	
__osver  . . . . . . . . . . . .	DWord	 00000554 _DATA	
__winmajor . . . . . . . . . . .	DWord	 0000055C _DATA	
__winminor . . . . . . . . . . .	DWord	 00000558 _DATA	
__winver . . . . . . . . . . . .	DWord	 00000560 _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0

	   0 Warnings
	   0 Errors
