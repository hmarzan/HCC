TITLE	 unittesting1.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE stdhpp\hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{389}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000469
;}
$L000469:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000486
;}
$L000486:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000492
;}
$L000492:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000490
;}
$L000490:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000483
;}
$L000483:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000500
;}
$L000500:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000506
;}
$L000506:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000497
;}
$L000497:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000502
;}
$L000502:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{384}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
Math_RadiansToDegrees ENDP

UnitTesting_Circle_Circumference PROC NEAR 
;double Circumference(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{78}:return Math::pi() * Radius
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Circle_get_Radius
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000667
;}
$L000667:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Circumference ENDP

UnitTesting_Circle_ComputeArea PROC NEAR 
;double ComputeArea(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{97}:return 2 * Circumference()
	mov	EAX,000000002h
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Circle_Circumference
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000673
;}
$L000673:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_ComputeArea ENDP

UnitTesting_Circle_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{102}:System::Debug::OutputString("destroying a Circle object...");
	lea	EAX,OFFSET $S000675
	push	EAX
	call	 System_Debug_OutputString

;{103}:Console::WriteLn("destroying a Circle object...");
	lea	EAX,OFFSET $S000675
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000674:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Destructor ENDP

UnitTesting_Circle_Draw PROC NEAR 
;void Draw(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{92}:Console::WriteLn("Drawing a Circle!");
	lea	EAX,OFFSET $S000672
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000671:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Draw ENDP

UnitTesting_Circle_DrawSphere PROC NEAR 
;void DrawSphere(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{108}:Console::WriteLn("Drawing a Sphere!");
	lea	EAX,OFFSET $S000677
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000676:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_DrawSphere ENDP

UnitTesting_Circle_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{87}:return "Circle"
	lea	EAX,OFFSET $S000670
	jmp	OFFSET $L000669
;}
$L000669:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Name ENDP

UnitTesting_Circle_get_Radius PROC NEAR 
;double get::Radius(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{68}:return radius
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000664
;}
$L000664:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_get_Radius ENDP

UnitTesting_Circle_put_Radius PROC NEAR 
;void put::Radius(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{73}:radius= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]
;}
$L000665:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Circle_put_Radius ENDP

UnitTesting_Circle_Type PROC NEAR 
;UnitTesting::ShapeType Type(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{83}:return UnitTesting::stCircle
	mov	EAX,000000001h
	jmp	OFFSET $L000668
;}
$L000668:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle_Type ENDP

UnitTesting_Circle PROC NEAR 
;void UnitTesting::Circle(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Shape ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Circle 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_Circle 
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Circle ENDP

UnitTesting_DoubleProxy_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{138}:Console::WriteLn("Destroying a Double Proxy object...");
	lea	EAX,OFFSET $S000806
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000805:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_DoubleProxy_Destructor ENDP

UnitTesting_DoubleProxy_Swap PROC NEAR 
;void Swap(UnitTesting::SimpleObject ref obj);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
	lea	EDI,dword ptr [EBP-000Ch]
	mov	ECX,000000003h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0010h] 
;{

;{129}:tmp= val;
	mov	ECX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{131}:ptr= dynamic_cast(&obj);
	pop	EDX
	pop	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,dword ptr [EBP-000Ch]
	mov	dword ptr [EBX],EAX

;{132}:val= ptr.val;
	mov	ECX,dword ptr [EBP-12]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0010h]
	fstp	qword ptr [ECX+0004h]

;{133}:ptr.val= tmp;
	pop	EDX
	pop	EAX 
	mov	ECX,dword ptr [EBP-12]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
$L000801:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_DoubleProxy_Swap ENDP

UnitTesting_DoubleProxy PROC NEAR 
;void UnitTesting::DoubleProxy(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_SimpleObject ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_DoubleProxy 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_DoubleProxy 
;{

;{111}:Console::WriteLn("Constructing a Double Proxy...");
	lea	EAX,OFFSET $S000794
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_DoubleProxy ENDP

UnitTesting_DoubleProxy_isEqual PROC NEAR 
;bool isEqual(UnitTesting::SimpleObject ref obj);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{122}:ptr= dynamic_cast(UnitTesting::DoubleProxy, &obj);
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{124}:return val < ptr.val
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	jmp	OFFSET $L000798
;}
$L000798:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_DoubleProxy_isEqual ENDP

UnitTesting_DoubleProxy_lessThan PROC NEAR 
;bool lessThan(UnitTesting::SimpleObject ref obj);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{115}:ptr= dynamic_cast(&obj);
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{117}:return val < ptr.val
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	jmp	OFFSET $L000795
;}
$L000795:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_DoubleProxy_lessThan ENDP

UnitTesting_DoubleSwapper_Swap PROC NEAR 
;void Swap(UnitTesting::SimpleObject ref obj1, UnitTesting::SimpleObject ref obj2);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
	lea	EDI,dword ptr [EBP-0010h]
	mov	ECX,000000004h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0014h] 
;{

;{163}:ptr1= dynamic_cast(&obj1);
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{164}:ptr2= dynamic_cast(&obj2);
	mov	EAX,dword ptr [EBP+000Ch]
	lea	EBX,dword ptr [EBP-0008h]
	mov	dword ptr [EBX],EAX

;{166}:tmp= ptr1.val;
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0010h]

;{167}:ptr1.val= ptr2.val;
	pop	EDX
	pop	EAX 
	mov	ECX,dword ptr [EBP-4]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	ECX,dword ptr [EBP-8]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{168}:ptr2.val= tmp;
	mov	ECX,dword ptr [EBP-8]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
$L000830:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_DoubleSwapper_Swap ENDP

UnitTesting_DoubleSwapper_SwapEx PROC NEAR 
;void SwapEx(UnitTesting::SimpleObject UnitTesting::SimpleObject [] array, unsigned left, unsigned right);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
	lea	EDI,dword ptr [EBP-0010h]
	mov	ECX,000000004h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0014h] 
;{

;{180}:ptr1= dynamic_cast(UnitTesting::DoubleProxy, &array[left]);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,ECX
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{181}:ptr2= dynamic_cast(&array[right]);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,ECX
	lea	EBX,dword ptr [EBP-0008h]
	mov	dword ptr [EBX],EAX

;{183}:tmp= ptr1.val;
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0010h]

;{184}:ptr1.val= ptr2.val;
	pop	EDX
	pop	EAX 
	mov	ECX,dword ptr [EBP-4]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	ECX,dword ptr [EBP-8]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{185}:ptr2.val= tmp;
	mov	ECX,dword ptr [EBP-8]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]
;}
$L000842:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_DoubleSwapper_SwapEx ENDP

UnitTesting_DoubleSwapper_lessThan PROC NEAR 
;bool lessThan(UnitTesting::SimpleObject ref obj1, UnitTesting::SimpleObject ref obj2);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{156}:ptr1= dynamic_cast(&obj1);
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{157}:ptr2= dynamic_cast(&obj2);
	mov	EAX,dword ptr [EBP+000Ch]
	lea	EBX,dword ptr [EBP-0008h]
	mov	dword ptr [EBX],EAX

;{159}:return ptr1.val < ptr2.val
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-8]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	jmp	OFFSET $L000825
;}
$L000825:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_DoubleSwapper_lessThan ENDP

UnitTesting_DoubleSwapper_lessThanEx PROC NEAR 
;bool lessThanEx(UnitTesting::SimpleObject UnitTesting::SimpleObject [] array, unsigned left, unsigned right);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{173}:ptr1= dynamic_cast(&array[left]);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,ECX
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{174}:ptr2= dynamic_cast(UnitTesting::DoubleProxy, &array[right]);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+0010h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,ECX
	lea	EBX,dword ptr [EBP-0008h]
	mov	dword ptr [EBX],EAX

;{176}:return ptr1.val < ptr2.val
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-8]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	jmp	OFFSET $L000836
;}
$L000836:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_DoubleSwapper_lessThanEx ENDP

UnitTesting_DoubleSwapper PROC NEAR 
;void UnitTesting::DoubleSwapper(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_SwapperObject ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_DoubleSwapper 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_DoubleSwapper ENDP

UnitTesting_HObject_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{
;}
;}
$L000877:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_HObject_Destructor ENDP

UnitTesting_HObject PROC NEAR 
;void UnitTesting::HObject(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_HObject 
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_HObject ENDP

UnitTesting_HelloWorld_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{431}:Console::WriteLn("The HelloWorld destructor");
	lea	EAX,OFFSET $S000926
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000925:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_HelloWorld_Destructor ENDP

UnitTesting_HelloWorld_SayHello PROC NEAR 
;void SayHello(string text);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{421}:Console::WriteLn("this is what I have to say for the first time in H++ :", text);
	lea	EAX,OFFSET $S000921
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP+0008h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 
;}
$L000919:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_HelloWorld_SayHello ENDP

UnitTesting_HelloWorld_ShowHello PROC NEAR 
;void ShowHello(string text);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{426}:System::ShowMessage(text, "H++ First program", System::IconInformation);
	mov	EAX,000000040h
	push	EAX 
	lea	EAX,OFFSET $S000924
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	call	 System_ShowMessage
;}
$L000922:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_HelloWorld_ShowHello ENDP

UnitTesting_HelloWorld PROC NEAR 
;void UnitTesting::HelloWorld(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{416}:Console::WriteLn("The HelloWorld constructor");
	lea	EAX,OFFSET $S000918
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_HelloWorld ENDP

UnitTesting_Integers_Inline_Test PROC NEAR 
;void UnitTesting::Integers_Inline::Test(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0010h]
	mov	ECX,000000004h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{93}:a= 5, b= 4;
	mov	EAX,000000005h
	mov	dword ptr [EBP-0004h],EAX
	mov	EAX,000000004h
	mov	dword ptr [EBP-0008h],EAX

;{95}:Console::WriteLn("The values: a = ", a, ", and b = ", b);
	lea	EAX,OFFSET $S000626
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S000627
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{97}:c= max(a, b);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EBX
	xor	ECX,ECX
	cmp	EBX,EAX
	setle	CL
	sub	ECX,000000001h
	sub	EBX,EAX 
	and	ECX,EBX
	add	EAX,ECX
	mov	dword ptr [EBP-000Ch],EAX

;{99}:Console::WriteLn("The max value is = ", c);
	lea	EAX,OFFSET $S000629
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{101}:d= min(a, b);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	EBX
	sub	EBX,EAX
	sbb	ECX,ECX
	and	ECX,EBX
	add	EAX,ECX
	mov	dword ptr [EBP-0010h],EAX

;{103}:Console::WriteLn("The min value is = ", d);
	lea	EAX,OFFSET $S000631
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L000621:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Integers_Inline_Test ENDP

UnitTesting_MonteCarlo_PI PROC NEAR 
;double UnitTesting::MonteCarlo::PI(unsigned trials);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000001Ch
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0018h]
	mov	ECX,000000006h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{273}:hits= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{274}:for(i= 0; i < trials; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001419
$L001420:
	inc	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001419:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001421
;{

;{276}:x= UnitTesting::Rnd::NextDblEx();
	call	 UnitTesting_Rnd_NextDblEx
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0010h]

;{277}:y= UnitTesting::Rnd::NextDblEx();
	pop	EDX
	pop	EAX 
	call	 UnitTesting_Rnd_NextDblEx
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0018h]

;{278}:if(x * x + y * y < 1.0)
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [EBP-000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP-0018h]
	mov	EAX,dword ptr [EBP-0014h] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP-0018h]
	mov	EAX,dword ptr [EBP-0014h] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld1
	push	ECX
	push	ECX 
	fstp	qword ptr [ESP]
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001422
;{

;{280}:++hits;
	inc	dword ptr [EBP-4]
	mov	EAX,dword ptr [EBP-4]
;}
$L001422:
;}
	jmp	OFFSET $L001420 
$L001421:

;{284}:return 4.0 * hits / trials
	xor	EDX,EDX
	mov	EAX,040100000h
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP-0004h]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP+0008h]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX 
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000880
;}
$L000880:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_MonteCarlo_PI ENDP

UnitTesting_Objects_Array_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{59}:if(array != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001424

;{60}:destroy []array;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	test	EAX,EAX
	jz	OFFSET $L001426
	mov	ESI,EAX
	add	ESI,0FFFFFFFCh
	push	ESI
	call	 System_Memory_Destroy
$L001426:
$L001424:
;}
$L000763:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Objects_Array_Destructor ENDP

UnitTesting_Objects_Array_get_length PROC NEAR 
;unsigned get::length(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{54}:return _length
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	jmp	OFFSET $L000762
;}
$L000762:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Objects_Array_get_length ENDP

UnitTesting_Objects_Array PROC NEAR 
;void UnitTesting::Objects::Array(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0008h],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Objects_Array 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_Objects_Array

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Objects_Array ENDP

UnitTesting_Objects_ArrayOfAutomobiles_Swap PROC NEAR 
;void Swap(UnitTesting::Objects::__uint i, UnitTesting::Objects::__uint j);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0010h],ECX
	lea	EDI,dword ptr [EBP-000Ch]
	mov	ECX,000000003h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0010h] 
;{

;{82}:tmp= array[i];
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_Objects_Automobile
	mov	ECX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,dword ptr [ESI+EAX]
	mov	ESI,ECX
	lea	EBX,dword ptr [EBP-000Ch]
	mov	EDI,EBX 
	mov	ECX,00000000Ch 
	cld	
	rep movsb	

;{83}:array[i]= array[j];
	mov	ECX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	EAX,dword ptr [ESI+EAX]
	push	EAX
	mov	ECX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,dword ptr [ESI+EAX]
	pop	EBX
	mov	dword ptr [EBX],EAX

;{84}:array[j]= tmp;
	mov	ECX,dword ptr [EBP-0010h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	imul	EAX,00000000Ch
	lea	EAX,dword ptr [ESI+EAX]
	push	EAX
	lea	ECX,dword ptr [EBP-000Ch]
	pop	EBX
	mov	dword ptr [EBX],EAX
;}
$L000776:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Objects_ArrayOfAutomobiles_Swap ENDP

UnitTesting_Objects_ArrayOfAutomobiles PROC NEAR 
;void UnitTesting::Objects::ArrayOfAutomobiles(UnitTesting::Objects::__uint len);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Objects_Array ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX+0008h],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Objects_ArrayOfAutomobiles 
;{

;{72}:array= new UnitTesting::Objects::Automobile[_length= len];
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],EAX
	imul	EAX,00000000Ch
	lea	EBX,dword ptr [EAX+4]
	push	EBX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001431
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI]
	mov	ECX,EBX 
	mov	EAX,0CDCDCDCDh 
	rep stos	byte ptr [EDI]
	mov	dword ptr [ESI],EBX 
	add	ESI,000000004h
	jmp	 $L001432
$L001431:
	xor	ESI,ESI
$L001432:
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],ESI 
	mov	ECX,dword ptr [ESI-0004h] 
	lea	EDI,dword ptr [ESI+ECX] 
	mov	EBX,ESI 
$L001433:
	mov	ECX,EBX 
	call	 UnitTesting_Objects_Automobile
	add	EBX,00000000Ch 
	cmp	EBX,EDI
	jnz	OFFSET $L001433
	mov	EAX,ESI 
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_Objects_ArrayOfAutomobiles ENDP

UnitTesting_Objects_ArrayOfAutomobiles_getAt PROC NEAR 
;UnitTesting::Objects::ProxyObject getAt(UnitTesting::Objects::__uint x);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{77}:return dynamic_cast(UnitTesting::Objects::Automobile, &array[x])
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,ECX
	jmp	OFFSET $L000774
;}
$L000774:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_Objects_ArrayOfAutomobiles_getAt ENDP

UnitTesting_Objects_Automobile_Compare PROC NEAR 
;int Compare(UnitTesting::Objects::ProxyObject ^ obj);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{36}:other= dynamic_cast(obj);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{37}:if(speed < other.speed)
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001434

;{38}:return -1
	mov	EAX,000000001h
	neg	EAX
	jmp	OFFSET $L000754

; else {
$L001434:

;{39}:if(speed > other.speed)
	mov	ECX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001436

;{40}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L000754
$L001436:
$L001435:

; }

;{42}:return 0
	xor	EAX,EAX
	jmp	OFFSET $L000754
;}
$L000754:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_Objects_Automobile_Compare ENDP

UnitTesting_Objects_Automobile_get_Speed PROC NEAR 
;double get::Speed(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{27}:return speed
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000751
;}
$L000751:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Objects_Automobile_get_Speed ENDP

UnitTesting_Objects_Automobile_put_Speed PROC NEAR 
;void put::Speed(double val);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{31}:speed= val;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]
;}
$L000752:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Objects_Automobile_put_Speed ENDP

UnitTesting_Objects_Automobile PROC NEAR 
;void UnitTesting::Objects::Automobile(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Objects_ProxyObject ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Objects_Automobile 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_Objects_Automobile 
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Objects_Automobile ENDP

UnitTesting_Objects_ProxyObject PROC NEAR 
;void UnitTesting::Objects::ProxyObject(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Objects_ProxyObject 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Objects_ProxyObject ENDP

UnitTesting_Rnd_NextDbl PROC NEAR 
;double NextDbl(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{45}:return UnitTesting::Rnd::NextDblEx()
	call	 UnitTesting_Rnd_NextDblEx
	jmp	OFFSET $L000540
;}
$L000540:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Rnd_NextDbl ENDP

UnitTesting_Rnd_NextInt PROC NEAR 
;double NextInt(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{50}:return UnitTesting::Rnd::NextIntEx()
	call	 UnitTesting_Rnd_NextIntEx
	jmp	OFFSET $L000541
;}
$L000541:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Rnd_NextInt ENDP

UnitTesting_Rnd PROC NEAR 
;void UnitTesting::Rnd(int seedx);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 __member_Init@UnitTesting_Rnd
;{

;{15}:UnitTesting::Rnd::seed= seedx;
	mov	EAX,dword ptr [EBP+0008h]
	mov	 UnitTesting_Rnd_seed,EAX
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_Rnd ENDP

UnitTesting_Rnd_setSeed PROC NEAR 
;void setSeed(long s);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{21}:UnitTesting::Rnd::seed= s;
	mov	EAX,dword ptr [EBP+0008h]
	mov	 UnitTesting_Rnd_seed,EAX
;}
$L000535:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_Rnd_setSeed ENDP

UnitTesting_Rnd_NextDblEx PROC NEAR 
;double UnitTesting::Rnd::NextDblEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{26}:UnitTesting::Rnd::seed= UnitTesting::Rnd::a * (UnitTesting::Rnd::seed % UnitTesting::Rnd::q) - UnitTesting::Rnd::r * (UnitTesting::Rnd::seed / UnitTesting::Rnd::q);
	lea	EBX,OFFSET UnitTesting_Rnd_a
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_q
	mov	EAX,dword ptr [EBX]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_r
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_q
	mov	EAX,dword ptr [EBX]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	mov	 UnitTesting_Rnd_seed,EAX

;{28}:UnitTesting::Rnd::seed+= (UnitTesting::Rnd::seed < 0 ? UnitTesting::Rnd::m : 0);
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	 $L001439
	lea	EBX,OFFSET UnitTesting_Rnd_m
	mov	EAX,dword ptr [EBX]
	jmp	 $L001440
$L001439:
	xor	EAX,EAX
$L001440:
	clc	
	add	 UnitTesting_Rnd_seed,EAX

;{30}:return UnitTesting::Rnd::seed / UnitTesting::Rnd::m
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_m
	mov	EAX,dword ptr [EBX]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000537
;}
$L000537:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Rnd_NextDblEx ENDP

UnitTesting_Rnd_NextIntEx PROC NEAR 
;double UnitTesting::Rnd::NextIntEx(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{36}:UnitTesting::Rnd::seed= UnitTesting::Rnd::a * (UnitTesting::Rnd::seed % UnitTesting::Rnd::q) - UnitTesting::Rnd::r * (UnitTesting::Rnd::seed * UnitTesting::Rnd::q);
	lea	EBX,OFFSET UnitTesting_Rnd_a
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_q
	mov	EAX,dword ptr [EBX]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_r
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_q
	mov	EAX,dword ptr [EBX]
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	ECX
	cdq	
	imul	EAX,ECX
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	 UnitTesting_Rnd_seed,EAX

;{38}:UnitTesting::Rnd::seed+= (UnitTesting::Rnd::seed < 0 ? UnitTesting::Rnd::m : 0);
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	 $L001441
	lea	EBX,OFFSET UnitTesting_Rnd_m
	mov	EAX,dword ptr [EBX]
	jmp	 $L001442
$L001441:
	xor	EAX,EAX
$L001442:
	clc	
	add	 UnitTesting_Rnd_seed,EAX

;{40}:return UnitTesting::Rnd::seed % UnitTesting::Rnd::m
	lea	EBX,OFFSET UnitTesting_Rnd_seed
	mov	EAX,dword ptr [EBX]
	push	EAX
	lea	EBX,OFFSET UnitTesting_Rnd_m
	mov	EAX,dword ptr [EBX]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	call	 FloatingPoint_FromInt
	jmp	OFFSET $L000539
;}
$L000539:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Rnd_NextIntEx ENDP

UnitTesting_Shape PROC NEAR 
;void UnitTesting::Shape(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Shape 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Shape ENDP

UnitTesting_ShapeFactoryCreator_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{299}:if(ptr3 != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	ECX
	xor	EAX,EAX
	pop	EBX
	cmp	EBX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001444

;{300}:destroy ptr3;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001447
	mov	EAX,dword ptr [ECX] 
	call	dword ptr [EAX+0010h]
$L001447:
	push	ESI
	call	 System_Memory_Destroy
$L001444:

;{302}:if(null != ptr3)
	xor	EAX,EAX
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	pop	ECX
	cmp	ECX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001448

;{303}:destroy ptr3;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001451
	mov	EAX,dword ptr [ECX] 
	call	dword ptr [EAX+0010h]
$L001451:
	push	ESI
	call	 System_Memory_Destroy
$L001448:
;}
$L000729:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_ShapeFactoryCreator_Destructor ENDP

UnitTesting_ShapeFactoryCreator PROC NEAR 
;void UnitTesting::ShapeFactoryCreator(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 __member_Init@UnitTesting_ShapeFactoryCreator

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_ShapeFactoryCreator ENDP

UnitTesting_ShapeFactoryCreator_Create PROC NEAR 
;UnitTesting::Shape UnitTesting::ShapeFactoryCreator::Create(string name);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{245}:obj_ptr= new UnitTesting::Circle();
	push	00000000Ch
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001453
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000003h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001454
$L001453:
	xor	ESI,ESI
$L001454:
	mov	dword ptr [EBP-0004h],ESI 
	mov	ECX,ESI
	call	 UnitTesting_Circle
	mov	EAX,ESI 

;{251}:destroy dynamic_cast(UnitTesting::Circle, obj_ptr);
	mov	ECX,dword ptr [EBP-4]
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001456
	mov	EAX,dword ptr [ECX] 
	call	dword ptr [EAX+0010h]
$L001456:
	push	ESI
	call	 System_Memory_Destroy

;{277}:if(name == "Circle")
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	lea	EAX,OFFSET $S000670
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setz	AL
	test	AL,AL
	jz	OFFSET $L001457
;{

;{279}:return new UnitTesting::Circle()
	push	00000000Ch
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001459
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000003h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001460
$L001459:
	xor	ESI,ESI
$L001460:
	mov	ECX,ESI
	call	 UnitTesting_Circle
	mov	EAX,ESI 
	jmp	OFFSET $L000726
;}
	jmp	OFFSET $L001458

; else {
$L001457:

;{280}:if(name == "Square")
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	lea	EAX,OFFSET $S000696
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setz	AL
	test	AL,AL
	jz	OFFSET $L001461
;{

;{282}:return new UnitTesting::Square()
	push	000000014h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001463
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000005h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001464
$L001463:
	xor	ESI,ESI
$L001464:
	mov	ECX,ESI
	call	 UnitTesting_Square
	mov	EAX,ESI 
	jmp	OFFSET $L000726
;}
	jmp	OFFSET $L001462

; else {
$L001461:

;{283}:if(name == "Triangle")
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	lea	EAX,OFFSET $S000716
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setz	AL
	test	AL,AL
	jz	OFFSET $L001465
;{

;{285}:return new UnitTesting::Triangle()
	push	000000014h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001467
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000005h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001468
$L001467:
	xor	ESI,ESI
$L001468:
	mov	ECX,ESI
	call	 UnitTesting_Triangle
	mov	EAX,ESI 
	jmp	OFFSET $L000726
;}
$L001465:
$L001462:

; }
$L001458:

; }

;{288}:return null
	xor	EAX,EAX
	jmp	OFFSET $L000726
;}
$L000726:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_ShapeFactoryCreator_Create ENDP

UnitTesting_SimpleObject_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{100}:Console::WriteLn("Destroying a Simple Object...");
	lea	EAX,OFFSET $S000789
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000788:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_SimpleObject_Destructor ENDP

UnitTesting_SimpleObject PROC NEAR 
;void UnitTesting::SimpleObject(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_SimpleObject 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_SimpleObject ENDP

UnitTesting_SortDoubleProxy_PrintObject PROC NEAR 
;void PrintObject(UnitTesting::SimpleObject ref obj);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{250}:dbl= dynamic_cast(&obj);
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{252}:Console::WriteLn("A double proxy = ", dbl.val);
	lea	EAX,OFFSET $S000874
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	ECX,dword ptr [EBP-4]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
$L000871:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_SortDoubleProxy_PrintObject ENDP

UnitTesting_SortDoubleProxy_Sort PROC NEAR 
;void Sort(UnitTesting::DoubleProxy UnitTesting::DoubleProxy [] array, int n, UnitTesting::SwapperObject ref swapper);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{194}:for(index= 1; index < n; index++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001470
$L001471:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L001470:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001472
;{

;{196}:for(left= index - 1; left >= 0; --left)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001473
$L001474:
	dec	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001473:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001475
;{

;{199}:if(swapper.lessThan(array[left + 1], array[left]))
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	ECX,dword ptr [EBP+0010h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	test	AL,AL
	jz	OFFSET $L001476
;{

;{202}:swapper.Swap(array[left + 1], array[left]);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	mov	ECX,dword ptr [EBP+0010h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
;}
$L001476:
;}
	jmp	OFFSET $L001474 
$L001475:
;}
	jmp	OFFSET $L001471 
$L001472:
;}
$L000850:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_SortDoubleProxy_Sort ENDP

UnitTesting_SortDoubleProxy_Sort2 PROC NEAR 
;void Sort2(double double [] array, int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{217}:for(index= 1; index < n; index++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001478
$L001479:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L001478:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001480
;{

;{219}:for(left= index - 1; left >= 0; left-- )
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001481
$L001482:
	mov	EAX,dword ptr [EBP-8]
	dec	dword ptr [EBP-8]
$L001481:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001483
;{

;{221}:if(array[left + 1] < array[left])
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001484
;{

;{228}:Swap(array[left + 1], array[left]);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_SortDoubleProxy_Swap
;}
$L001484:
;}
	jmp	OFFSET $L001482 
$L001483:
;}
	jmp	OFFSET $L001479 
$L001480:
;}
$L000860:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SortDoubleProxy_Sort2 ENDP

UnitTesting_SortDoubleProxy_SortEx PROC NEAR 
;void SortEx(UnitTesting::SimpleObject UnitTesting::SimpleObject [] array, int n, UnitTesting::SwapperObject ref swapper);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{236}:for(index= 1; index < n; index++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001486
$L001487:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L001486:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001488
;{

;{238}:for(left= index - 1; left >= 0; --left)
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001489
$L001490:
	dec	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001489:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001491
;{

;{240}:if(swapper.lessThanEx(array, left + 1, left))
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP+0010h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0008h]
	test	AL,AL
	jz	OFFSET $L001492
;{

;{242}:swapper.SwapEx(array, left + 1, left);
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX 
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	ECX,dword ptr [EBP+0010h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]
;}
$L001492:
;}
	jmp	OFFSET $L001490 
$L001491:
;}
	jmp	OFFSET $L001487 
$L001488:
;}
$L000865:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_SortDoubleProxy_SortEx ENDP

UnitTesting_SortDoubleProxy_Swap PROC NEAR 
;void Swap(double ref val1, double ref val2);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{210}:tmp= val1;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX+4]
	mov	EDX,dword ptr [EBX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{211}:val1= val2;
	pop	EDX
	pop	EAX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX+4]
	mov	EDX,dword ptr [EBX] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	EBX,dword ptr [EBP+0008h]
	fstp	qword ptr [EBX]

;{212}:val2= tmp;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	EBX,dword ptr [EBP+000Ch]
	fstp	qword ptr [EBX]
;}
$L000856:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SortDoubleProxy_Swap ENDP

UnitTesting_Square_ComputeArea PROC NEAR 
;double ComputeArea(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{149}:return Width * Height
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Square_get_Width
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Square_get_Height
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000693
;}
$L000693:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_ComputeArea ENDP

UnitTesting_Square_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{122}:System::Debug::OutputString("destroying a Square object...");
	lea	EAX,OFFSET $S000684
	push	EAX
	call	 System_Debug_OutputString

;{123}:Console::WriteLn("destroying a Square object...");
	lea	EAX,OFFSET $S000684
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000683:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_Destructor ENDP

UnitTesting_Square_Draw PROC NEAR 
;void Draw(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{162}:Console::WriteLn("Drawing a Square!");
	lea	EAX,OFFSET $S000698
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000697:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_Draw ENDP

UnitTesting_Square_DrawCube PROC NEAR 
;void DrawCube(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{167}:Console::WriteLn("Drawing a Cube!");
	lea	EAX,OFFSET $S000700
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000699:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_DrawCube ENDP

UnitTesting_Square_get_Height PROC NEAR 
;double get::Height(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{139}:return dHeight
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0010h]
	mov	EDX,dword ptr [ECX+000Ch] 
	jmp	OFFSET $L000690
;}
$L000690:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_get_Height ENDP

UnitTesting_Square_put_Height PROC NEAR 
;void put::Height(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{144}:dHeight= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+000Ch]
;}
$L000691:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Square_put_Height ENDP

UnitTesting_Square_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{157}:return "Square"
	lea	EAX,OFFSET $S000696
	jmp	OFFSET $L000695
;}
$L000695:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_Name ENDP

UnitTesting_Square_Type PROC NEAR 
;UnitTesting::ShapeType Type(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{153}:return UnitTesting::stSquare
	mov	EAX,000000002h
	jmp	OFFSET $L000694
;}
$L000694:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_Type ENDP

UnitTesting_Square PROC NEAR 
;void UnitTesting::Square(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Shape ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Square 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_Square 
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square ENDP

UnitTesting_Square_get_Width PROC NEAR 
;double get::Width(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{129}:return dWidth
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000686
;}
$L000686:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Square_get_Width ENDP

UnitTesting_Square_put_Width PROC NEAR 
;void put::Width(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{134}:dWidth= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]
;}
$L000687:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Square_put_Width ENDP

UnitTesting_SummationSeries_Ackermman PROC NEAR 
;int UnitTesting::SummationSeries::Ackermman(int m, int n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{80}:if(m == 0 && n >= 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001496
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
$L001496:
	test	AL,AL
	jz	OFFSET $L001494

;{81}:return n + 1
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	jmp	OFFSET $L000617

; else {
$L001494:

;{82}:if(m >= 1 && n == 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001499
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
$L001499:
	test	AL,AL
	jz	OFFSET $L001497

;{83}:return UnitTesting::SummationSeries::Ackermman(m - 1, 1)
	mov	EAX,000000001h
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	call	 UnitTesting_SummationSeries_Ackermman
	jmp	OFFSET $L000617

; else {
$L001497:

;{85}:return UnitTesting::SummationSeries::Ackermman(m - 1, UnitTesting::SummationSeries::Ackermman(m, n - 1))
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	call	 UnitTesting_SummationSeries_Ackermman
	push	EAX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	call	 UnitTesting_SummationSeries_Ackermman
	jmp	OFFSET $L000617
$L001498:

; }
$L001495:

; }
;}
$L000617:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SummationSeries_Ackermman ENDP

UnitTesting_SummationSeries_ComputeRenderGamma PROC NEAR 
;void UnitTesting::SummationSeries::ComputeRenderGamma(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000010h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-000Ch]
	mov	ECX,000000003h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{69}:result= 0;
	xor	EAX,EAX
	push	EAX
	fild	dword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{70}:for(i= 1; i <= 50; ++i)
	pop	EAX
	mov	EAX,000000001h
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L001500
$L001501:
	inc	dword ptr [EBP-12]
	mov	EAX,dword ptr [EBP-12]
$L001500:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000032h
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001502
;{

;{71}:result+= 1.0 / i - Math::log10((i + 1.0) / i);
	fld1
	push	ECX
	push	ECX 
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP-000Ch]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	fld1
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP-000Ch]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_log10
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	clc	
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	lea	EBX,dword ptr [EBP-0008h]
	fadd	qword ptr [EBX]
	fstp	qword ptr [EBX]

;{72}:Console::WriteLn("Partial results = ", result);
	lea	EAX,OFFSET $S000615
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001501 
$L001502:

;{75}:Console::WriteLn("Gamma y = ", result);
	lea	EAX,OFFSET $S000616
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
$L000610:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_SummationSeries_ComputeRenderGamma ENDP

UnitTesting_SummationSeries_GeometricSeriesClosedSum PROC NEAR 
;int UnitTesting::SummationSeries::GeometricSeriesClosedSum(int x, unsigned n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{62}:return FloatingPoint::ToInt((Math::Pow(x, n + 1) - 1) / (x - 1))
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 Math_Pow
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	jmp	OFFSET $L000607
;}
$L000607:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SummationSeries_GeometricSeriesClosedSum ENDP

UnitTesting_SummationSeries_GeometricSeriesSum PROC NEAR 
;int UnitTesting::SummationSeries::GeometricSeriesSum(int x, unsigned n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000018h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0014h]
	mov	ECX,000000005h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{21}:nx= FloatingPoint::ToInt(3.145464654);
	mov	EDX,05F5D3B4Eh
	mov	EAX,0400929E9h 
	push	EAX
	push	EDX 
	call	 FloatingPoint_ToInt
	mov	dword ptr [EBP-0004h],EAX

;{23}:sum= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX

;{24}:for(i= 0; i <= n; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-000Ch],EAX
	jmp	OFFSET $L001503
$L001504:
	inc	dword ptr [EBP-12]
	mov	EAX,dword ptr [EBP-12]
$L001503:
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001505
;{

;{26}:prod= 1;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0010h],EAX

;{27}:for(j= 0; j < i; ++j)
	xor	EAX,EAX
	mov	dword ptr [EBP-0014h],EAX
	jmp	OFFSET $L001506
$L001507:
	inc	dword ptr [EBP-20]
	mov	EAX,dword ptr [EBP-20]
$L001506:
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBP-000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001508

;{28}:prod*= x;
	mov	EAX,dword ptr [EBP+0008h]
	lea	EBX,dword ptr [EBP-0010h]
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX
	jmp	OFFSET $L001507 
$L001508:

;{29}:sum+= prod;
	mov	EAX,dword ptr [EBP-0010h]
	clc	
	add	dword ptr [EBP-0008h],EAX
;}
	jmp	OFFSET $L001504 
$L001505:

;{31}:return sum
	mov	EAX,dword ptr [EBP-0008h]
	jmp	OFFSET $L000586
;}
$L000586:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SummationSeries_GeometricSeriesSum ENDP

UnitTesting_SummationSeries_Horner_GeometricSeriesSum PROC NEAR 
;int UnitTesting::SummationSeries::Horner::GeometricSeriesSum(int x, unsigned n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{49}:sum= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{50}:for(i= 0; i <= n; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001509
$L001510:
	inc	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001509:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001511

;{51}:sum= sum * x + 1;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001510 
$L001511:

;{53}:return sum
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000602
;}
$L000602:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_SummationSeries_Horner_GeometricSeriesSum ENDP

UnitTesting_SummationSeries_Horner_Horner PROC NEAR 
;int UnitTesting::SummationSeries::Horner::Horner(int int [] a, unsigned n, int x);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{39}:result= a[n];
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	mov	dword ptr [EBP-0004h],EAX

;{41}:for(i= n - 1; i >= 0; --i)
	mov	EAX,dword ptr [EBP+000Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001512
$L001513:
	dec	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001512:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001514

;{42}:result*= x + a[i];
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0008h]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	pop	EDX
	add	EAX,EDX
	lea	EBX,dword ptr [EBP-0004h]
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX
	jmp	OFFSET $L001513 
$L001514:

;{43}:return result
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000596
;}
$L000596:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_SummationSeries_Horner_Horner ENDP

UnitTesting_SummationSeries_SimpleSum PROC NEAR 
;unsigned UnitTesting::SummationSeries::SimpleSum(unsigned n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{11}:result= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{12}:for(i= 1; i <= n; ++i)
	mov	EAX,000000001h
	mov	dword ptr [EBP-0008h],EAX
	jmp	OFFSET $L001515
$L001516:
	inc	dword ptr [EBP-8]
	mov	EAX,dword ptr [EBP-8]
$L001515:
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001517

;{13}:result+= i;
	mov	EAX,dword ptr [EBP-0008h]
	clc	
	add	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001516 
$L001517:

;{15}:return result
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L000582
;}
$L000582:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_SummationSeries_SimpleSum ENDP

UnitTesting_SwapperObject PROC NEAR 
;void UnitTesting::SwapperObject(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_SwapperObject 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_SwapperObject ENDP

UnitTesting_TestArrays_get_Name PROC NEAR 
;string get::Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{911}:return name
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	jmp	OFFSET $L001134
;}
$L001134:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestArrays_get_Name ENDP

UnitTesting_TestArrays_put_Name PROC NEAR 
;void put::Name(string value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{915}:name= value;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX
;}
$L001135:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestArrays_put_Name ENDP

UnitTesting_TestArrays PROC NEAR 
;void UnitTesting::TestArrays(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestArrays ENDP

UnitTesting_TestArrays_DoTest PROC NEAR 
;void UnitTesting::TestArrays::DoTest(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,0000002E0h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-02DCh]
	mov	ECX,0000000B7h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{946}:array2;
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX

;{948}:array2[0].Width= 100;
	xor	EAX,EAX
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	push	ECX
	mov	EAX,000000064h
	pop	ECX
	push	EAX
	call	 UnitTesting_TestIntegers_put_Width

;{949}:array2[0].Height= 200;
	xor	EAX,EAX
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	push	ECX
	mov	EAX,0000000C8h
	pop	ECX
	push	EAX
	call	 UnitTesting_TestIntegers_put_Height

;{951}:nArea= array2[0].Width;
	xor	EAX,EAX
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	call	 UnitTesting_TestIntegers_get_Width
	cdq	
	lea	EBX,dword ptr [EBP-00C8h]
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBX+4],EDX 

;{953}:nArea= array2[0].Width * array2[0].Height;
	xor	EAX,EAX
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	xor	EAX,EAX
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	cdq	
	lea	EBX,dword ptr [EBP-00C8h]
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBX+4],EDX 

;{955}:array2[0].member1= Math::pi();
	xor	EAX,EAX
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0008h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{956}:array2[0].member1= Math::log_e_base2();
	xor	EAX,EAX
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0008h]
	push	EAX
	call	 Math_log_e_base2
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{958}:Console::WriteLn("(1)", "nArea = 100 * 200 == ", nArea);
	lea	EAX,OFFSET $S001148
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	EAX,OFFSET $S001149
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-00C8h]
	mov	EDX,dword ptr [EBP-00C4h] 
	push	EDX 
	push	EAX 
	call	 Console_WriteInteger64 
	call	 Console_WriteCrLf 

;{960}:array2[1].Width= 100;
	mov	EAX,000000001h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	push	ECX
	mov	EAX,000000064h
	pop	ECX
	push	EAX
	call	 UnitTesting_TestIntegers_put_Width

;{961}:array2[1].Height= 200;
	mov	EAX,000000001h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	push	ECX
	mov	EAX,0000000C8h
	pop	ECX
	push	EAX
	call	 UnitTesting_TestIntegers_put_Height

;{963}:nArea= array2[1].Width * array2[1].Height;
	mov	EAX,000000001h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	mov	EAX,000000001h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	cdq	
	lea	EBX,dword ptr [EBP-00C8h]
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBX+4],EDX 

;{965}:Console::WriteLn("(2)", "nArea = 100 * 200 == ", nArea);
	lea	EAX,OFFSET $S001150
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	EAX,OFFSET $S001149
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-00C8h]
	mov	EDX,dword ptr [EBP-00C4h] 
	push	EDX 
	push	EAX 
	call	 Console_WriteInteger64 
	call	 Console_WriteCrLf 

;{967}:array2[2].Width= 100;
	mov	EAX,000000002h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	push	ECX
	mov	EAX,000000064h
	pop	ECX
	push	EAX
	call	 UnitTesting_TestIntegers_put_Width

;{968}:array2[2].Height= 200;
	mov	EAX,000000002h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	push	ECX
	mov	EAX,0000000C8h
	pop	ECX
	push	EAX
	call	 UnitTesting_TestIntegers_put_Height

;{970}:nArea= array2[2].Width * array2[2].Height;
	mov	EAX,000000002h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	mov	EAX,000000002h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	cdq	
	lea	EBX,dword ptr [EBP-00C8h]
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBX+4],EDX 

;{972}:Console::WriteLn("(3)", "nArea = 100 * 200 == ", nArea);
	lea	EAX,OFFSET $S001151
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	EAX,OFFSET $S001149
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-00C8h]
	mov	EDX,dword ptr [EBP-00C4h] 
	push	EDX 
	push	EAX 
	call	 Console_WriteInteger64 
	call	 Console_WriteCrLf 

;{975}:array2[3].my_array1[0]= 9.99;
	mov	EAX,000000003h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0018h] ;array data member as element on an object
	mov	ESI,EAX
	push	ESI
	xor	EAX,EAX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,047AE147Bh
	mov	EAX,04023FAE1h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{976}:array2[3].my_array1[1]= 3.1415927;
	mov	EAX,000000003h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0018h] ;array data member as element on an object
	mov	ESI,EAX
	push	ESI
	mov	EAX,000000001h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0008h]
	push	EAX
	mov	EDX,05A7ED197h
	mov	EAX,0400921FBh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{977}:array2[3].my_array2[0]= FloatingPoint::ToInt(9.99);
	mov	EAX,000000003h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0028h] ;array data member as element on an object
	mov	ESI,EAX
	push	ESI
	xor	EAX,EAX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EDX,047AE147Bh
	mov	EAX,04023FAE1h 
	push	EAX
	push	EDX 
	call	 FloatingPoint_ToInt
	pop	EBX
	mov	dword ptr [EBX],EAX

;{978}:array2[3].my_array2[1]= FloatingPoint::ToInt(3.1415927);
	mov	EAX,000000003h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0028h] ;array data member as element on an object
	mov	ESI,EAX
	push	ESI
	mov	EAX,000000001h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EDX,05A7ED197h
	mov	EAX,0400921FBh 
	push	EAX
	push	EDX 
	call	 FloatingPoint_ToInt
	pop	EBX
	mov	dword ptr [EBX],EAX

;{980}:Console::WriteLn("array2[3].my_array1[0] (double)== 9.99 == ", array2[3].my_array1[0]);
	lea	EAX,OFFSET $S001154
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0018h] ;array data member as element on an object
	mov	ESI,EAX
	push	ESI
	xor	EAX,EAX
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{981}:Console::WriteLn("array2[3].my_array1[1] (double)== 3.1415927 == ", array2[3].my_array1[1]);
	lea	EAX,OFFSET $S001155
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0018h] ;array data member as element on an object
	mov	ESI,EAX
	push	ESI
	mov	EAX,000000001h
	pop	ESI
	mov	EDX,dword ptr [ESI+EAX*0008h]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [ESI+EAX] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{983}:Console::WriteLn("array2[3].my_array2[0] (int)== 10 == ", array2[3].my_array2[0]);
	lea	EAX,OFFSET $S001156
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0028h] ;array data member as element on an object
	mov	ESI,EAX
	push	ESI
	xor	EAX,EAX
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{984}:Console::WriteLn("array2[3].my_array2[1] (int)== 3 == ", array2[3].my_array2[1]);
	lea	EAX,OFFSET $S001157
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	imul	EAX,EAX,000000030h
	lea	ECX,dword ptr [EBP+EAX-00C0h]
	lea	EAX,dword ptr [ECX+0028h] ;array data member as element on an object
	mov	ESI,EAX
	push	ESI
	mov	EAX,000000001h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{987}:UnitTesting::array3;
	lea	EAX, UnitTesting_array3
	mov	ESI,EAX
	mov	EBX,ESI
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch 
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch 
	mov	ECX,EBX 
	call	 UnitTesting_Circle

;{989}:UnitTesting::array3[0].Draw();
	xor	EAX,EAX
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [EAX+UnitTesting_array3]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{991}:UnitTesting::array3[2].Draw();
	mov	EAX,000000002h
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [EAX+UnitTesting_array3]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{993}:UnitTesting::array4;
	lea	EAX, UnitTesting_array4

;{995}:UnitTesting::array4[0]= Math::pi();
	xor	EAX,EAX
	lea	EAX,dword ptr [EAX*8+UnitTesting_array4]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{996}:UnitTesting::array4[1]= Math::pi() * 2.1;
	mov	EAX,000000001h
	lea	EAX,dword ptr [EAX*8+UnitTesting_array4]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,0CCCCCCCDh
	mov	EAX,04000CCCCh 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{997}:UnitTesting::array4[2]= Math::pi() * 4.1;
	mov	EAX,000000002h
	lea	EAX,dword ptr [EAX*8+UnitTesting_array4]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,066666667h
	mov	EAX,040106666h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{998}:UnitTesting::array4[3]= Math::pi() * 8.1;
	mov	EAX,000000003h
	lea	EAX,dword ptr [EAX*8+UnitTesting_array4]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,033333333h
	mov	EAX,040203333h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1000}:for(x= 0; x < 4; x++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-00CCh],EAX
	jmp	OFFSET $L001520
$L001521:
	mov	EAX,dword ptr [EBP-204]
	inc	dword ptr [EBP-204]
$L001520:
	mov	EAX,dword ptr [EBP-00CCh]
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001522

;{1001}:Console::WriteLn("array4[", x, "] = ", UnitTesting::array4[x]);
	lea	EAX,OFFSET $S001164
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-00CCh]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001165
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-00CCh]
	mov	EDX,dword ptr [EAX*8+UnitTesting_array4]
	lea	EAX,dword ptr [EAX*0008h+4] ;low part
	mov	EAX,dword ptr [EAX+UnitTesting_array4] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001521 
$L001522:

;{1005}:name= "Harold L. Marzan";
	lea	EAX,OFFSET $S001167
	mov	dword ptr [EBP-00D0h],EAX

;{1006}:UnitTesting::TestArrays::printChars(name, StringHandling::StringLength(name));
	mov	EAX,dword ptr [EBP-00D0h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	mov	EAX,dword ptr [EBP-00D0h]
	push	EAX
	call	 UnitTesting_TestArrays_printChars

;{1008}:my_name_is;
	lea	EAX,dword ptr [EBP-00E4h]

;{1010}:StringHandling::StringSet(my_name_is, 0, sizeof (my_name_is));
	mov	EAX,000000014h
	push	EAX 
	xor	EAX,EAX
	push	EAX 
	lea	EAX,dword ptr [EBP-00E4h]
	push	EAX
	call	 StringHandling_StringSet

;{1012}:my_name_is[0]= 'H';
	xor	EAX,EAX
	imul	EAX,EAX,000000001h
	lea	EAX,dword ptr [EBP+EAX-00E4h]
	push	EAX
	mov	EAX,000000048h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1013}:my_name_is[1]= 'a';
	mov	EAX,000000001h
	imul	EAX,EAX,000000001h
	lea	EAX,dword ptr [EBP+EAX-00E4h]
	push	EAX
	mov	EAX,000000061h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1014}:my_name_is[2]= 'r';
	mov	EAX,000000002h
	imul	EAX,EAX,000000001h
	lea	EAX,dword ptr [EBP+EAX-00E4h]
	push	EAX
	mov	EAX,000000072h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1015}:my_name_is[3]= 'o';
	mov	EAX,000000003h
	imul	EAX,EAX,000000001h
	lea	EAX,dword ptr [EBP+EAX-00E4h]
	push	EAX
	mov	EAX,00000006Fh
	pop	EBX
	mov	byte ptr [EBX],AL

;{1016}:my_name_is[4]= 'l';
	mov	EAX,000000004h
	imul	EAX,EAX,000000001h
	lea	EAX,dword ptr [EBP+EAX-00E4h]
	push	EAX
	mov	EAX,00000006Ch
	pop	EBX
	mov	byte ptr [EBX],AL

;{1017}:my_name_is[5]= 'd';
	mov	EAX,000000005h
	imul	EAX,EAX,000000001h
	lea	EAX,dword ptr [EBP+EAX-00E4h]
	push	EAX
	mov	EAX,000000064h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1018}:my_name_is[6]= ' ';
	mov	EAX,000000006h
	imul	EAX,EAX,000000001h
	lea	EAX,dword ptr [EBP+EAX-00E4h]
	push	EAX
	xor	EAX,EAX
	pop	EBX
	mov	byte ptr [EBX],AL

;{1022}:Console::WriteLn("My name is :", my_name_is);
	lea	EAX,OFFSET $S001176
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	EAX,dword ptr [EBP-00E4h]
	push	000000014h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1024}:UnitTesting::TestArrays::printChars(my_name_is, StringHandling::StringLength(my_name_is));
	lea	EAX,dword ptr [EBP-00E4h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	lea	EAX,dword ptr [EBP-00E4h]
	push	EAX
	call	 UnitTesting_TestArrays_printChars

;{1027}:arr;
	lea	EAX,dword ptr [EBP-01ACh]

;{1029}:arr[0][0]= 'H';
	xor	EAX,EAX
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	xor	EAX,EAX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,000000048h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1030}:arr[0][1]= 'E';
	xor	EAX,EAX
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000001h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,000000045h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1031}:arr[0][2]= 'L';
	xor	EAX,EAX
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000002h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,00000004Ch
	pop	EBX
	mov	byte ptr [EBX],AL

;{1032}:arr[0][3]= 'L';
	xor	EAX,EAX
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000003h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,00000004Ch
	pop	EBX
	mov	byte ptr [EBX],AL

;{1033}:arr[0][4]= 'O';
	xor	EAX,EAX
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000004h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,00000004Fh
	pop	EBX
	mov	byte ptr [EBX],AL

;{1034}:arr[0][5]= '!';
	xor	EAX,EAX
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000005h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,000000021h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1036}:arr[0][0]= 'H';
	xor	EAX,EAX
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	xor	EAX,EAX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,000000048h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1037}:arr[1][1]= 'E';
	mov	EAX,000000001h
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000001h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,000000045h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1038}:arr[2][2]= 'L';
	mov	EAX,000000002h
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000002h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,00000004Ch
	pop	EBX
	mov	byte ptr [EBX],AL

;{1039}:arr[3][3]= 'L';
	mov	EAX,000000003h
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000003h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,00000004Ch
	pop	EBX
	mov	byte ptr [EBX],AL

;{1040}:arr[4][4]= 'O';
	mov	EAX,000000004h
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000004h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,00000004Fh
	pop	EBX
	mov	byte ptr [EBX],AL

;{1041}:arr[5][5]= '!';
	mov	EAX,000000005h
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,000000005h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX
	mov	EAX,000000021h
	pop	EBX
	mov	byte ptr [EBX],AL

;{1043}:for(i= 0; i < 6; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-01B0h],EAX
	jmp	OFFSET $L001523
$L001524:
	mov	EAX,dword ptr [EBP-432]
	inc	dword ptr [EBP-432]
$L001523:
	mov	EAX,dword ptr [EBP-01B0h]
	push	EAX
	mov	EAX,000000006h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001525

;{1044}:Console::WriteLn("Char at [", i, ", ", i, "]=", arr[i][i]);
	lea	EAX,OFFSET $S001183
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-01B0h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001184
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-01B0h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001185
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-01B0h]
	imul	EAX,EAX,000000014h
	lea	EDX,dword ptr [EBP+EAX-01ACh]
	push	EDX
	mov	EAX,dword ptr [EBP-01B0h]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX 
	call	 Console_WriteChar 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001524 
$L001525:

;{1048}:testt;
	lea	EAX,dword ptr [EBP-0278h]

;{1049}:test= "Testing!!!";
	lea	EAX,OFFSET $S001188
	mov	dword ptr [EBP-027Ch],EAX

;{1050}:StringHandling::StringCopy(testt, test, StringHandling::StringLength(test));
	mov	EAX,dword ptr [EBP-027Ch]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	mov	EAX,dword ptr [EBP-027Ch]
	push	EAX 
	lea	EAX,dword ptr [EBP-0278h]
	push	EAX
	call	 StringHandling_StringCopy

;{1052}:UnitTesting::TestArrays::printChars(testt, StringHandling::StringLength(testt));
	lea	EAX,dword ptr [EBP-0278h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	lea	EAX,dword ptr [EBP-0278h]
	push	EAX
	call	 UnitTesting_TestArrays_printChars

;{1057}:arr_of_strings;
	lea	EAX,dword ptr [EBP-028Ch]

;{1059}:arr_of_strings[0]= "Harold ";
	xor	EAX,EAX
	imul	EAX,EAX,000000004h
	lea	EAX,dword ptr [EBP+EAX-028Ch]
	push	EAX
	lea	EAX,OFFSET $S001190
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1060}:arr_of_strings[1]= "Lawrence ";
	mov	EAX,000000001h
	imul	EAX,EAX,000000004h
	lea	EAX,dword ptr [EBP+EAX-028Ch]
	push	EAX
	lea	EAX,OFFSET $S001191
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1061}:arr_of_strings[2]= "Marzan ";
	mov	EAX,000000002h
	imul	EAX,EAX,000000004h
	lea	EAX,dword ptr [EBP+EAX-028Ch]
	push	EAX
	lea	EAX,OFFSET $S001192
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1062}:arr_of_strings[3]= "Mercado.";
	mov	EAX,000000003h
	imul	EAX,EAX,000000004h
	lea	EAX,dword ptr [EBP+EAX-028Ch]
	push	EAX
	lea	EAX,OFFSET $S001193
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1064}:for(i= 0; i < 4; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-01B0h],EAX
	jmp	OFFSET $L001526
$L001527:
	inc	dword ptr [EBP-432]
	mov	EAX,dword ptr [EBP-432]
$L001526:
	mov	EAX,dword ptr [EBP-01B0h]
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001528
;{

;{1066}:UnitTesting::TestArrays::printChars(arr_of_strings[i], StringHandling::StringLength(arr_of_strings[i]));
	mov	EAX,dword ptr [EBP-01B0h]
	imul	EAX,EAX,000000004h
	mov	EAX,dword ptr [EBP+EAX-028Ch]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	mov	EAX,dword ptr [EBP-01B0h]
	imul	EAX,EAX,000000004h
	mov	EAX,dword ptr [EBP+EAX-028Ch]
	push	EAX
	call	 UnitTesting_TestArrays_printChars
;}
	jmp	OFFSET $L001527 
$L001528:

;{1069}:StringHandling::StringCopy(my_name_is, name, StringHandling::StringLength(name));
	mov	EAX,dword ptr [EBP-00D0h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	mov	EAX,dword ptr [EBP-00D0h]
	push	EAX 
	lea	EAX,dword ptr [EBP-00E4h]
	push	EAX
	call	 StringHandling_StringCopy

;{1070}:UnitTesting::TestArrays::printChars(my_name_is, StringHandling::StringLength(my_name_is));
	lea	EAX,dword ptr [EBP-00E4h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	lea	EAX,dword ptr [EBP-00E4h]
	push	EAX
	call	 UnitTesting_TestArrays_printChars
;}
$L001144:
	lea	EAX,dword ptr [EBP-00C0h]
	mov	ESI,EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestArrays_DoTest ENDP

UnitTesting_TestArrays_printChars PROC NEAR 
;void UnitTesting::TestArrays::printChars(char char [] array, int n);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;try
	push	ESP ;pPrevESP
	push	EBP ;pPrevEBP
	push	OFFSET __except_handlerXXX001532 
	assume FS:nothing
	push	dword ptr  FS:[0] 
	mov	dword ptr  FS:[0],ESP

;{924}:for(i= 0; i < n; ++i)
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001535
$L001536:
	inc	dword ptr [EBP-4]
	mov	EAX,dword ptr [EBP-4]
$L001535:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001537

;{925}:Console::WriteLn("Char at i:[", i, "] == ", array[i]);
	lea	EAX,OFFSET $S001141
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001142
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0001h]
	push	EAX 
	call	 Console_WriteChar 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001536 
$L001537:
;}
	jmp	OFFSET $L001531
__except_handlerXXX001532:
	mov	EBX,dword ptr [ESP+0004h] ;_ExceptionRecord
	mov	ECX,dword ptr [EBX] ;_ExceptionRecord->ExceptionCode // The reason the exception occurred.
	mov	EBX,dword ptr  FS:[0] 
	mov	ESP,dword ptr [EBX] 
	pop	dword ptr  FS:[0]
	mov	EBP,dword ptr [ESP+0004h] ;the prev EBP
	mov	ESP,dword ptr [ESP+0008h] ;the prev ESP

;{925}:(System::Exception::ACCESS_VIOLATION);
	mov	EAX,0C0000005h
	cmp	EAX,ECX
	jnz	OFFSET $L001538

;{934}:Console::WriteLn("Oops! there was a serious bug in this code!");
	lea	EAX,OFFSET $S001143
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001534 
$L001538:

;{934}:(System::Exception::INTEGER_DIVIDE_BY_ZERO);
	mov	EAX,0C0000094h
	cmp	EAX,ECX 
	jnz	OFFSET $L001539 

;{938}:Console::WriteLn("Oops! there was a serious bug in this code!");
	lea	EAX,OFFSET $S001143
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001534 
$L001539:
	jmp	OFFSET $L001534 
$L001531:
	mov	ESP,dword ptr  FS:[0] 
	pop	dword ptr  FS:[0] 
	mov	EBP,dword ptr [ESP+0004h] ;the prev EBP
	mov	ESP,dword ptr [ESP+0008h] ;the prev ESP
$L001534:
;}
$L001137:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestArrays_printChars ENDP

UnitTesting_TestFloatingPoint_Area PROC NEAR 
;double Area(double minor_base, double major_base, double height);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{899}:area= ((minor_base + major_base) * height) / 2.0;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBP+0014h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0018h]
	mov	EAX,dword ptr [EBP+001Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	xor	EDX,EDX
	mov	EAX,040000000h
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0008h]

;{901}:return area
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0008h]
	mov	EAX,dword ptr [EBP-0004h] 
	jmp	OFFSET $L001126
;}
$L001126:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000018h
UnitTesting_TestFloatingPoint_Area ENDP

UnitTesting_TestFloatingPoint_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{877}:System::Debug::OutputString("destroying a TestFloatingPoint() object...");
	lea	EAX,OFFSET $S001119
	push	EAX
	call	 System_Debug_OutputString

;{878}:Console::WriteLn("destroying a TestFloatingPoint() object...");
	lea	EAX,OFFSET $S001119
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001118:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestFloatingPoint_Destructor ENDP

UnitTesting_TestFloatingPoint_Power PROC NEAR 
;double Power(double X, int n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{882}:if(n == 0)
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001540

;{883}:return 1
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	jmp	OFFSET $L001120
$L001540:

;{885}:if(n % 2 == 0)
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001542

;{886}:return Power(X * X, n div 2)
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestFloatingPoint_Power
	jmp	OFFSET $L001120

; else {
$L001542:

;{888}:return X * Power(X * X, n div 2)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,dword ptr [EBP+0010h]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestFloatingPoint_Power
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L001120
$L001543:

; }
;}
$L001120:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestFloatingPoint_Power ENDP

UnitTesting_TestFloatingPoint PROC NEAR 
;void UnitTesting::TestFloatingPoint(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{872}:System::Debug::OutputString("constructing a TestFloatingPoint() object...");
	lea	EAX,OFFSET $S001117
	push	EAX
	call	 System_Debug_OutputString
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestFloatingPoint ENDP

UnitTesting_TestFloatingPoint_speed PROC NEAR 
;double UnitTesting::TestFloatingPoint::speed(double distance, double time);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{894}:return distance / time
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBP+0014h] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L001123
;}
$L001123:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000010h
UnitTesting_TestFloatingPoint_speed ENDP

UnitTesting_TestIntegers_Calc1 PROC NEAR 
;int Calc1(int i, int ref j);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{766}:nArea= j * Height;
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-0004h],EAX

;{768}:j= Width;
	mov	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_TestIntegers_get_Width
	mov	EBX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBX],EAX

;{770}:j= i div 5;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000005h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EBX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBX],EAX

;{772}:nArea= FloatingPoint::ToInt(j * Height * 1.0);
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX
	mov	ECX,dword ptr [EBP-0008h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	fld1
	fclex
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	mov	dword ptr [EBP-0004h],EAX

;{775}:j*= 3;
	mov	EAX,000000003h
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX

;{777}:return nArea
	mov	EAX,dword ptr [EBP-0004h]
	jmp	OFFSET $L001055
;}
$L001055:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_Calc1 ENDP

UnitTesting_TestIntegers_Calc2 PROC NEAR 
;void Calc2(Int32 ref x, Int32 ref y);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{789}:a= 1000;
	mov	EAX,0000003E8h
	mov	dword ptr [EBP-0004h],EAX

;{790}:x= 9 * 3 * a;
	mov	EAX,000000009h
	push	EAX
	mov	EAX,000000003h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ECX 
	cdq	
	imul	EAX,ECX 
	mov	EBX,dword ptr [EBP+0008h]
	mov	dword ptr [EBX],EAX

;{791}:y= a * 4 * 5;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000000004h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000005h
	pop	ECX 
	xor	EDX,EDX 
	imul	EAX,ECX 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBX],EAX
;}
$L001063:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_Calc2 ENDP

UnitTesting_TestIntegers_Factorial PROC NEAR 
;int Factorial(int n);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{848}:if(n == 0)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001544

;{849}:return 1
	mov	EAX,000000001h
	jmp	OFFSET $L001105

; else {
$L001544:

;{851}:return n * Factorial(n - 1)
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestIntegers_Factorial
	pop	ECX
	cdq	
	imul	EAX,ECX
	jmp	OFFSET $L001105
$L001545:

; }
;}
$L001105:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestIntegers_Factorial ENDP

UnitTesting_TestIntegers_get_Height PROC NEAR 
;int get::Height(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return nHeight
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	jmp	OFFSET $L000967
;}
$L000967:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_get_Height ENDP

UnitTesting_TestIntegers_put_Height PROC NEAR 
;void put::Height(int value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{500}:nHeight= value;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],EAX
;}
$L000968:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestIntegers_put_Height ENDP

UnitTesting_TestIntegers_Swap PROC NEAR 
;void Swap(int ref value1, int ref value2);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0008h],ECX
	lea	EDI,dword ptr [EBP-0004h]
	mov	ECX,000000001h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0008h] 
;{

;{782}:tmp= value1;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	mov	dword ptr [EBP-0004h],EAX

;{783}:value1= value2;
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	mov	EBX,dword ptr [EBP+0008h]
	mov	dword ptr [EBX],EAX

;{784}:value2= tmp;
	mov	EAX,dword ptr [EBP-0004h]
	mov	EBX,dword ptr [EBP+000Ch]
	mov	dword ptr [EBX],EAX
;}
$L001059:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_Swap ENDP

UnitTesting_TestIntegers_SwapDebug PROC NEAR 
;void SwapDebug(int ref value1, int ref value2);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{856}:System::Debug::OutputString("Swaping values...");
	lea	EAX,OFFSET $S001110
	push	EAX
	call	 System_Debug_OutputString

;{857}:Swap(value1, value2);
	push	dword ptr [EBP+000Ch]
	push	dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestIntegers_Swap
;}
$L001107:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_SwapDebug ENDP

UnitTesting_TestIntegers_get_Width PROC NEAR 
;int get::Width(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{485}:return nWidth
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	jmp	OFFSET $L000963
;}
$L000963:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_get_Width ENDP

UnitTesting_TestIntegers_put_Width PROC NEAR 
;void put::Width(int value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{490}:nWidth= value;
	mov	EAX,dword ptr [EBP+0008h]
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX
;}
$L000964:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestIntegers_put_Width ENDP

UnitTesting_TestIntegers_add PROC NEAR 
;void add(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{797}:res= v1 + v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	add	EAX,EDX
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{799}:Console::WriteLn("(+) the result is: ", res);
	lea	EAX,OFFSET $S001072
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L001068:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_add ENDP

UnitTesting_TestIntegers_divide PROC NEAR 
;void divide(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{818}:res= v1 div v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{820}:Console::WriteLn("(div) the result is: ", res);
	lea	EAX,OFFSET $S001087
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L001083:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_divide ENDP

UnitTesting_TestIntegers_divide2 PROC NEAR 
;void divide2(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{832}:res= Math::Round(v1 / v2);
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Round
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{834}:Console::WriteLn("(round(/)) the result is: ", res);
	lea	EAX,OFFSET $S001097
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L001093:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_divide2 ENDP

UnitTesting_TestIntegers_getArea PROC NEAR 
;int getArea(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{505}:return Width * Height
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	jmp	OFFSET $L000970
;}
$L000970:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_getArea ENDP

UnitTesting_TestIntegers_getArea2 PROC NEAR 
;double getArea2(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{510}:return nWidth * nHeight * 1.0
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	push	EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	fld1
	fclex
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000971
;}
$L000971:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_getArea2 ENDP

UnitTesting_TestIntegers_modulus PROC NEAR 
;void modulus(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{825}:res= v1 % v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{827}:Console::WriteLn("(mod) the result is: ", res);
	lea	EAX,OFFSET $S001092
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L001088:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_modulus ENDP

UnitTesting_TestIntegers_multiple_assignments PROC NEAR 
;void multiple_assignments(int ref param1, int param2);
	push	EBP
	mov	EBP,ESP
	sub	ESP,00000000Ch
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-000Ch],ECX
	lea	EDI,dword ptr [EBP-0008h]
	mov	ECX,000000002h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-000Ch] 
;{

;{839}:local= param2= param1= (0x400 * 1024) / 0x10;
	mov	EAX,000000400h
	push	EAX
	mov	EAX,000000400h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,000000010h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	mov	EBX,dword ptr [EBP+0008h]
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBP+000Ch],EAX
	mov	dword ptr [EBP-0004h],EAX

;{841}:what= (local == 0x10000);
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,000010000h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0008h],AL
;}
$L001098:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestIntegers_multiple_assignments ENDP

UnitTesting_TestIntegers_multiply PROC NEAR 
;void multiply(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{811}:res= v1 * v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{813}:Console::WriteLn("(*) the result is: ", res);
	lea	EAX,OFFSET $S001082
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L001078:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_multiply ENDP

UnitTesting_TestIntegers_subs PROC NEAR 
;void subs(int v1, int v2, int ref res);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{804}:res= v1 - v2;
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,dword ptr [EBP+000Ch]
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	mov	EBX,dword ptr [EBP+0010h]
	mov	dword ptr [EBX],EAX

;{806}:Console::WriteLn("(-) the result is: ", res);
	lea	EAX,OFFSET $S001077
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EBX,dword ptr [EBP+0010h]
	mov	EAX,EBX 
	mov	EAX,dword ptr [EBX]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
$L001073:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	00000000Ch
UnitTesting_TestIntegers_subs ENDP

UnitTesting_TestIntegers PROC NEAR 
;void UnitTesting::TestIntegers(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 __member_Init@UnitTesting_TestIntegers

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers ENDP

UnitTesting_TestIntegers_TestExpressions PROC NEAR 
;void UnitTesting::TestIntegers::TestExpressions(void);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000084h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-0080h]
	mov	ECX,000000020h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{517}:hex_value= 0xDEADC0DEh;
	mov	EAX,0DEADC0DEh
	mov	dword ptr [EBP-0004h],EAX

;{519}:hex_value= hex_value << 0x10;
	mov	EAX,dword ptr [EBP-0004h]
	shl	EAX,000000010h
	mov	dword ptr [EBP-0004h],EAX

;{521}:hex_value= hex_value >> 8;
	mov	EAX,dword ptr [EBP-0004h]
	shr	EAX,000000008h
	mov	dword ptr [EBP-0004h],EAX

;{523}:hex_value= hex_value >> 8;
	mov	EAX,dword ptr [EBP-0004h]
	shr	EAX,000000008h
	mov	dword ptr [EBP-0004h],EAX

;{525}:shift= 0x10;
	mov	EAX,000000010h
	mov	word ptr [EBP-0008h],AX

;{527}:hex_value= hex_value << shift;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	movsx	EAX,word ptr [EBP-0008h]
	mov	CL,AL
	pop	EAX
	shl	EAX,CL
	mov	dword ptr [EBP-0004h],EAX

;{529}:hex_value= hex_value >> shift;
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	movsx	EAX,word ptr [EBP-0008h]
	mov	CL,AL
	pop	EAX
	shr	EAX,CL
	mov	dword ptr [EBP-0004h],EAX

;{532}:j= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-000Ch],EAX

;{534}:what= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-0010h],AL

;{543}:hex_value= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX

;{545}:while(true)
$L001547:
	mov	EAX,000000001h
	test	AL,AL
	jz	OFFSET $L001548
;{

;{547}:j= (4 + (--j)) % 4;
	mov	EAX,000000004h
	push	EAX
	lea	EBX,dword ptr [EBP-000Ch]
	dec	dword ptr [EBX]
	mov	EAX,dword ptr [EBX]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000004h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-000Ch],EAX

;{549}:Console::WriteLn(" j = (4 + (--j))%4 ==", j);
	lea	EAX,OFFSET $S000982
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{551}:if(++hex_value < 12)
	inc	dword ptr [EBP-4]
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	mov	EAX,00000000Ch
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001549

;continue;
	jmp	OFFSET $L001547
$L001549:

;{554}:what= (j % 2) == 0;
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000002h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;break;
	jmp	OFFSET $L001548
;}
	jmp	OFFSET $L001547
$L001548:

;{559}:what= j == 3;
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	mov	EAX,000000003h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;do
$L001551:
;{

;{562}:j= (4 + (--j)) % 4;
	mov	EAX,000000004h
	push	EAX
	lea	EBX,dword ptr [EBP-000Ch]
	dec	dword ptr [EBX]
	mov	EAX,dword ptr [EBX]
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,000000004h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-000Ch],EAX

;{563}:Console::WriteLn(" j = (4 + (--j))%4 ==", j);
	lea	EAX,OFFSET $S000982
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{565}:if(j == 0)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001554

;break;
	jmp	OFFSET $L001553
$L001554:
;}
$L001552:

;{566}:while(j > 0)
	mov	EAX,dword ptr [EBP-000Ch]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jne	OFFSET $L001551
$L001553:

;{570}:x= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0014h],EAX

;{572}:y= 1, z= 2;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0018h],EAX
	mov	EAX,000000002h
	mov	dword ptr [EBP-001Ch],EAX

;{574}:result= (y + 1) * z;
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-0020h],EAX

;{576}:x++ ;
	mov	EAX,dword ptr [EBP-20]
	inc	dword ptr [EBP-20]

;{577}:++x;
	inc	dword ptr [EBP-20]
	mov	EAX,dword ptr [EBP-20]

;{579}:x+= 14;
	mov	EAX,00000000Eh
	clc	
	add	dword ptr [EBP-0014h],EAX

;{583}:what= x == 0x10h;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000010h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{585}:Console::WriteLn("(what = x==0x10h)		= ", what);
	lea	EAX,OFFSET $S000990
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{587}:x/= 4;
	mov	EAX,000000004h
	lea	EBX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBX]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBX],EAX 
	pop	ECX

;{589}:--x;
	dec	dword ptr [EBP-20]
	mov	EAX,dword ptr [EBP-20]

;{590}:x-- ;
	mov	EAX,dword ptr [EBP-20]
	dec	dword ptr [EBP-20]

;{592}:x= 7 % x;
	mov	EAX,000000007h
	push	EAX
	mov	EAX,dword ptr [EBP-0014h]
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-0014h],EAX

;{594}:what= x == 1;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{596}:Console::WriteLn("(what = x==1)			= ", what);
	lea	EAX,OFFSET $S000992
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{598}:x++ ;
	mov	EAX,dword ptr [EBP-20]
	inc	dword ptr [EBP-20]

;{600}:x*= 10;
	mov	EAX,00000000Ah
	lea	EBX,dword ptr [EBP-0014h]
	imul	dword ptr [EBX]
	mov	dword ptr [EBX],EAX

;{602}:x/= 5;
	mov	EAX,000000005h
	lea	EBX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBX]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBX],EAX 
	pop	ECX

;{604}:x/= 4;
	mov	EAX,000000004h
	lea	EBX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBX]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBX],EAX 
	pop	ECX

;{606}:x%= 4;
	mov	EAX,000000004h
	lea	EBX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,dword ptr [EBX]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBX],EDX 
	pop	ECX

;{608}:y= 0x400h;
	mov	EAX,000000400h
	mov	dword ptr [EBP-0018h],EAX

;{610}:x= y div 15;
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,00000000Fh
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0014h],EAX

;{612}:what= x == 68;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000044h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{614}:Console::WriteLn("(what = x == 68) 		= ", what);
	lea	EAX,OFFSET $S000996
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{618}:z= 0x10;
	mov	EAX,000000010h
	mov	dword ptr [EBP-001Ch],EAX

;{620}:x= y * z;
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,dword ptr [EBP-001Ch]
	pop	ECX
	cdq	
	imul	EAX,ECX
	mov	dword ptr [EBP-0014h],EAX

;{622}:what= x == 0x4000;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000004000h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{624}:Console::WriteLn("(what = x==0x4000) 		= ", what);
	lea	EAX,OFFSET $S000998
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{626}:y= z= x;
	mov	EAX,dword ptr [EBP-0014h]
	mov	dword ptr [EBP-001Ch],EAX
	mov	dword ptr [EBP-0018h],EAX

;{628}:x= y div 4;
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,000000004h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0014h],EAX

;{630}:what= x == 4096;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000001000h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{632}:Console::WriteLn("(what = x==4096) 		= ", what);
	lea	EAX,OFFSET $S001000
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{634}:z= x % 3;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-001Ch],EAX

;{636}:what= z == 1;
	mov	EAX,dword ptr [EBP-001Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{638}:y= x div 3;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0018h],EAX

;{640}:what= y == 1365;
	mov	EAX,dword ptr [EBP-0018h]
	push	EAX
	mov	EAX,000000555h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{642}:Console::WriteLn("(what = y==1365) 		= ", what);
	lea	EAX,OFFSET $S001002
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{644}:result= FloatingPoint::ToInt(x / 3);
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000003h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	mov	dword ptr [EBP-0020h],EAX

;{646}:what= (result == 1365.0);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	xor	EDX,EDX
	mov	EAX,040955400h
	push	EAX
	push	EDX 
	call	 FloatingPoint_CompareToInteger
	cmp	EAX,000000000h
	neg	EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{648}:Console::WriteLn("(what = (result==1365.0)) 	= ", what);
	lea	EAX,OFFSET $S001004
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{650}:result= x div (3 + 1);
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,000000003h
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	dword ptr [EBP-0020h],EAX

;{652}:what= (result == 1024);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,000000400h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{654}:Console::WriteLn("(what = (result==1024)) 	= ", what);
	lea	EAX,OFFSET $S001006
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{656}:a= 20000, b= 4, c= 10;
	mov	EAX,000004E20h
	mov	word ptr [EBP-0024h],AX
	mov	EAX,000000004h
	mov	word ptr [EBP-0028h],AX
	mov	EAX,00000000Ah
	mov	word ptr [EBP-002Ch],AX

;{658}:result= a * b * c;
	movsx	EAX,word ptr [EBP-0024h]
	push	EAX
	movsx	EAX,word ptr [EBP-0028h]
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	movsx	EAX,word ptr [EBP-002Ch]
	pop	ECX 
	xor	EDX,EDX 
	imul	EAX,ECX 
	mov	dword ptr [EBP-0020h],EAX

;{660}:what= result == 0xC3500h;
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,0000C3500h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{662}:Console::WriteLn("(what = result==0xC3500h) 	= ", what);
	lea	EAX,OFFSET $S001012
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{664}:result/= 0x10;
	mov	EAX,000000010h
	lea	EBX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,dword ptr [EBX]
	cdq	
	idiv	dword ptr [ESP]
	mov	dword ptr [EBX],EAX 
	pop	ECX

;{666}:what= (result == 50000);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,00000C350h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{668}:Console::WriteLn("(what = (result==50000)) 	= ", what);
	lea	EAX,OFFSET $S001014
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{670}:x= result % 3;
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,000000003h
	mov	ECX,EAX
	pop	EAX
	xor	EDX,EDX
	idiv	ECX
	mov	EAX,EDX 
	mov	dword ptr [EBP-0014h],EAX

;{672}:result= Math::Round(a / 3) * 5;
	movsx	EAX,word ptr [EBP-0024h]
	push	EAX
	mov	EAX,000000003h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Round
	push	EAX
	mov	EAX,000000005h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	mov	dword ptr [EBP-0020h],EAX

;{674}:what= (result == 33335);
	mov	EAX,dword ptr [EBP-0020h]
	push	EAX
	mov	EAX,000008237h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{676}:Console::WriteLn("(what = (result==33335)) 	= ", what);
	lea	EAX,OFFSET $S001016
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{678}:a= 1;
	mov	EAX,000000001h
	mov	word ptr [EBP-0024h],AX

;{678}:b= 4;
	mov	EAX,000000004h
	mov	word ptr [EBP-0028h],AX

;{678}:c= 4;
	mov	EAX,000000004h
	mov	word ptr [EBP-002Ch],AX

;{680}:disc= Math::Sqr(b) - 4 * a * c;
	movsx	EAX,word ptr [EBP-0028h]
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 Math_Sqr
	push	EAX
	push	EDX 
	mov	EAX,000000004h
	push	EAX
	movsx	EAX,word ptr [EBP-0024h]
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	movsx	EAX,word ptr [EBP-002Ch]
	pop	ECX 
	xor	EDX,EDX 
	imul	EAX,ECX 
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0034h]

;{683}:what= disc == 0.0;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0034h]
	mov	EAX,dword ptr [EBP-0030h] 
	push	EAX
	push	EDX 
	fldz
	push	ECX
	push	ECX 
	fstp	qword ptr [ESP]
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{685}:Console::WriteLn("(what = disc==0.0) 		= ", what);
	lea	EAX,OFFSET $S001018
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{687}:x1= (-b + Math::Sqrt(disc)) / 2 * a;
	movsx	EAX,word ptr [EBP-0028h]
	neg	EAX
	push	EAX
	mov	EDX,dword ptr [EBP-0034h]
	mov	EAX,dword ptr [EBP-0030h] 
	push	EAX
	push	EDX 
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	movsx	EAX,word ptr [EBP-0024h]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX 
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-003Ch]

;{688}:what= x1 == -2.0;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-003Ch]
	mov	EAX,dword ptr [EBP-0038h] 
	push	EAX
	push	EDX 
	xor	EDX,EDX
	mov	EAX,040000000h
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{690}:Console::WriteLn("(what = x1==-2.0) 		= ", what);
	lea	EAX,OFFSET $S001021
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{692}:x2= (-b - Math::Sqrt(disc)) / 2 * a;
	movsx	EAX,word ptr [EBP-0028h]
	neg	EAX
	push	EAX
	mov	EDX,dword ptr [EBP-0034h]
	mov	EAX,dword ptr [EBP-0030h] 
	push	EAX
	push	EDX 
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	movsx	EAX,word ptr [EBP-0024h]
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX 
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0044h]

;{693}:what= x2 == -2.0;
	pop	EDX
	pop	EAX 
	mov	EDX,dword ptr [EBP-0044h]
	mov	EAX,dword ptr [EBP-0040h] 
	push	EAX
	push	EDX 
	xor	EDX,EDX
	mov	EAX,040000000h
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{695}:Console::WriteLn("(what = x2==-2.0) 		= ", what);
	lea	EAX,OFFSET $S001023
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0010h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{697}:x= 1;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0014h],EAX

;{698}:Console::WriteLn("the value of x is: ", x);
	lea	EAX,OFFSET $S001024
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{700}:++x;
	inc	dword ptr [EBP-20]
	mov	EAX,dword ptr [EBP-20]

;{701}:Console::WriteLn("the value of x is: ", x);
	lea	EAX,OFFSET $S001024
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{703}:--x;
	dec	dword ptr [EBP-20]
	mov	EAX,dword ptr [EBP-20]

;{704}:Console::WriteLn("the value of x is (1): ", x);
	lea	EAX,OFFSET $S001025
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{706}:Console::WriteLn("the value of x is (1): ", x++ );
	lea	EAX,OFFSET $S001025
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-20]
	inc	dword ptr [EBP-20]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{708}:Console::WriteLn("the value of x is (2): ", x-- );
	lea	EAX,OFFSET $S001026
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-20]
	dec	dword ptr [EBP-20]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{710}:Console::WriteLn("the value is (5): ", x++ -4 / (-1));
	lea	EAX,OFFSET $S001027
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-20]
	inc	dword ptr [EBP-20]
	push	EAX
	mov	EAX,000000004h
	push	EAX
	mov	EAX,000000001h
	neg	EAX
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{712}:Console::WriteLn("the value is (5): ", --x - 4 / (-1));
	lea	EAX,OFFSET $S001027
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	dec	dword ptr [EBP-20]
	mov	EAX,dword ptr [EBP-20]
	push	EAX
	mov	EAX,000000004h
	push	EAX
	mov	EAX,000000001h
	neg	EAX
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{714}:Console::WriteLn("the value is (3): ", (x++ -4) / (-1));
	lea	EAX,OFFSET $S001028
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-20]
	inc	dword ptr [EBP-20]
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	neg	EAX
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{716}:Console::WriteLn("the value is (3): ", (--x - 4) / (-1));
	lea	EAX,OFFSET $S001028
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	dec	dword ptr [EBP-20]
	mov	EAX,dword ptr [EBP-20]
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	mov	EAX,000000001h
	neg	EAX
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{718}:x= UnitTesting::ten * 100;
	mov	EAX,00000000Ah
	push	EAX
	mov	EAX,000000064h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	mov	dword ptr [EBP-0014h],EAX

;{720}:what= x == 1000;
	mov	EAX,dword ptr [EBP-0014h]
	push	EAX
	mov	EAX,0000003E8h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{722}:what= UnitTesting::ten * 50 == 500;
	mov	EAX,00000000Ah
	push	EAX
	mov	EAX,000000032h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	mov	EAX,0000001F4h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-0010h],AL

;{726}:alett= UnitTesting::misc1::alpha;
	mov	EAX,000000000h
	mov	dword ptr [EBP-0048h],EAX

;{728}:lundi= UnitTesting::misc1::monday, mardi= UnitTesting::misc1::tuesday;
	mov	EAX,000000001h
	mov	dword ptr [EBP-004Ch],EAX
	mov	EAX,000000002h
	mov	dword ptr [EBP-0050h],EAX

;{731}:length= 15, width= 10;
	mov	EAX,00000000Fh
	mov	dword ptr [EBP-0054h],EAX
	mov	EAX,00000000Ah
	mov	dword ptr [EBP-0058h],EAX

;{732}:area= length * width;
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	mov	EAX,dword ptr [EBP-0058h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	fild	dword ptr [ESP]
	fstp	qword ptr [EBP-0060h]

;{734}:Console::WriteLn("l = ", length, "w = ", width);
	pop	EAX
	lea	EAX,OFFSET $S001038
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001039
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{735}:Console::WriteLn("(a = l * w) =", area);
	lea	EAX,OFFSET $S001040
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0060h]
	mov	EAX,dword ptr [EBP-005Ch] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{737}:radius, ;
	mov	EDX,dword ptr [EBP-0068h]
	mov	EAX,dword ptr [EBP-0064h] 

;{737}:circ;
	mov	EDX,dword ptr [EBP-0070h]
	mov	EAX,dword ptr [EBP-006Ch] 

;{739}:letter= 'x';
	mov	EAX,000000078h
	mov	byte ptr [EBP-0074h],AL

;{741}:darea= (length * width) * 0.9;
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	mov	EAX,dword ptr [EBP-0058h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	push	EAX
	mov	EDX,0CCCCCCCDh
	mov	EAX,03FECCCCCh 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-007Ch]

;{743}:Console::WriteLn("(a = l * w * 0.9) = ", darea);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001047
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-007Ch]
	mov	EAX,dword ptr [EBP-0078h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{745}:a= 2;
	mov	EAX,000000002h
	mov	word ptr [EBP-0024h],AX

;{749}:ternary= 4 >= a ? 999 < 1000 && 1 > 0 : 777 == 77.7 * 10;
	mov	EAX,000000004h
	push	EAX
	movsx	EAX,word ptr [EBP-0024h]
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	 $L001556
	mov	EAX,0000003E7h
	push	EAX
	mov	EAX,0000003E8h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001558
	mov	EAX,000000001h
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
$L001558:
	jmp	 $L001557
$L001556:
	mov	EAX,000000309h
	push	EAX
	mov	EDX,0CCCCCCCDh
	mov	EAX,040536CCCh 
	push	EAX
	push	EDX 
	mov	EAX,00000000Ah
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_CompareToInteger
	cmp	EAX,000000000h
	neg	EAX
	setz	AL
$L001557:
	mov	byte ptr [EBP-0080h],AL

;{749}:7 == 111;
	mov	EAX,000000007h
	push	EAX
	mov	EAX,00000006Fh
	pop	EDX
	cmp	EDX,EAX
	setz	AL

;{751}:Console::WriteLn("Ternary (true) = ", ternary);
	lea	EAX,OFFSET $S001053
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0080h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{753}:ternary= (4 >= a) ? 999 > 1000 && 1 > 0 : 777 / 7 == 111;
	mov	EAX,000000004h
	push	EAX
	movsx	EAX,word ptr [EBP-0024h]
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	 $L001559
	mov	EAX,0000003E7h
	push	EAX
	mov	EAX,0000003E8h
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001561
	mov	EAX,000000001h
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
$L001561:
	jmp	 $L001560
$L001559:
	mov	EAX,000000309h
	push	EAX
	mov	EAX,000000007h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,00000006Fh
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setz	AL
$L001560:
	mov	byte ptr [EBP-0080h],AL

;{755}:Console::WriteLn("Ternary (false ) = ", ternary);
	lea	EAX,OFFSET $S001054
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0080h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{757}:ternary= 4 < a ? 999 > 1000 && 1 > 0 : 777 / (3 + 4) == 111;
	mov	EAX,000000004h
	push	EAX
	movsx	EAX,word ptr [EBP-0024h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	 $L001562
	mov	EAX,0000003E7h
	push	EAX
	mov	EAX,0000003E8h
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001564
	mov	EAX,000000001h
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setg	AL
$L001564:
	jmp	 $L001563
$L001562:
	mov	EAX,000000309h
	push	EAX
	mov	EAX,000000003h
	push	EAX
	mov	EAX,000000004h
	pop	EDX
	add	EAX,EDX
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,00000006Fh
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setz	AL
$L001563:
	mov	byte ptr [EBP-0080h],AL

;{759}:Console::WriteLn("Ternary (true) = ", ternary);
	lea	EAX,OFFSET $S001053
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-0080h]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{761}:return 
	jmp	OFFSET $L000974
;}
$L000974:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestIntegers_TestExpressions ENDP

UnitTesting_TestProperties_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{401}:Console::WriteLn("**Before destroying all object in shapes1:");
	lea	EAX,OFFSET $S000914
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{402}:if(shapes1 != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001565

;{403}:destroy []shapes1;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	test	EAX,EAX
	jz	OFFSET $L001567
	mov	ESI,EAX
	mov	ECX,dword ptr [ESI-0004h]
	lea	EDI,dword ptr [ESI+ECX]
	mov	EBX,ESI 
$L001568:
	mov	ECX,EBX 
	test	ECX,ECX
	jz	OFFSET $L001569
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001569:
	add	EBX,00000000Ch
	cmp	EBX,EDI
	jnz	OFFSET $L001568

	add	ESI,0FFFFFFFCh
	push	ESI
	call	 System_Memory_Destroy
$L001567:
$L001565:

;{405}:Console::WriteLn("**Before destroying all object in shapes2:");
	lea	EAX,OFFSET $S000915
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{406}:destroy []shapes2;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	mov	ECX,EAX 
	test	EAX,EAX
	jz	OFFSET $L001570
	mov	ESI,EAX
	mov	ECX,dword ptr [ESI-0004h]
	lea	EDI,dword ptr [ESI+ECX]
	mov	EBX,ESI 
$L001571:
	mov	ECX,EBX 
	test	ECX,ECX
	jz	OFFSET $L001572
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001572:
	add	EBX,00000000Ch
	cmp	EBX,EDI
	jnz	OFFSET $L001571

	add	ESI,0FFFFFFFCh
	push	ESI
	call	 System_Memory_Destroy
$L001570:
;}
$L000911:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestProperties_Destructor ENDP

UnitTesting_TestProperties_get_Shapes PROC NEAR 
;UnitTesting::Shape get::Shapes(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{323}:return shapes1
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	jmp	OFFSET $L000900
;}
$L000900:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestProperties_get_Shapes ENDP

UnitTesting_TestProperties_put_Shapes PROC NEAR 
;void put::Shapes(UnitTesting::Shape ^ _shape);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000098h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0098h],ECX
	lea	EDI,dword ptr [EBP-0094h]
	mov	ECX,000000025h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0098h] 
;{

;{330}:link;
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_TestProperties_node

;{332}:link.left= new UnitTesting::TestProperties::node();
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX]
	push	EAX
	push	00000000Ch
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001573
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000003h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001574
$L001573:
	xor	ESI,ESI
$L001574:
	pop	EBX
	mov	dword ptr [EBX],ESI 
	mov	ECX,ESI
	call	 UnitTesting_TestProperties_node
	mov	EAX,ESI 

;{333}:link.right= new UnitTesting::TestProperties::node();
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	push	00000000Ch
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001575
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000003h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001576
$L001575:
	xor	ESI,ESI
$L001576:
	pop	EBX
	mov	dword ptr [EBX],ESI 
	mov	ECX,ESI
	call	 UnitTesting_TestProperties_node
	mov	EAX,ESI 

;{334}:link.value= new UnitTesting::HObject();
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX+0008h]
	push	EAX
	push	000000004h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001577
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000001h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001578
$L001577:
	xor	ESI,ESI
$L001578:
	pop	EBX
	mov	dword ptr [EBX],ESI 
	mov	ECX,ESI
	call	 UnitTesting_HObject
	mov	EAX,ESI 

;{342}:left= link.left;
	lea	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	lea	EBX,dword ptr [EBP-0010h]
	mov	dword ptr [EBX],EAX

;{343}:destroy left;
	mov	ECX,dword ptr [EBP-16]
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001580
	call	 UnitTesting_TestProperties_node_Destructor
$L001580:
	push	ESI
	call	 System_Memory_Destroy

;{344}:link.left= null;
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX]
	push	EAX
	xor	EAX,EAX
	pop	EBX
	mov	dword ptr [EBX],EAX

;{346}:link.left= link.right;
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX]
	push	EAX
	lea	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX+0004h]
	mov	ECX,EAX 
	pop	EBX
	mov	dword ptr [EBX],EAX

;{347}:link.right= new UnitTesting::TestProperties::node();
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	push	00000000Ch
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001581
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000003h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001582
$L001581:
	xor	ESI,ESI
$L001582:
	pop	EBX
	mov	dword ptr [EBX],ESI 
	mov	ECX,ESI
	call	 UnitTesting_TestProperties_node
	mov	EAX,ESI 

;{349}:right= link.right;
	lea	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX+0004h]
	mov	ECX,EAX 
	lea	EBX,dword ptr [EBP-0014h]
	mov	dword ptr [EBX],EAX

;{350}:destroy right;
	mov	ECX,dword ptr [EBP-20]
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001584
	call	 UnitTesting_TestProperties_node_Destructor
$L001584:
	push	ESI
	call	 System_Memory_Destroy

;{352}:link.right= link.left;
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	lea	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	pop	EBX
	mov	dword ptr [EBX],EAX

;{353}:link.left= new UnitTesting::TestProperties::node();
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX]
	push	EAX
	push	00000000Ch
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001585
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000003h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001586
$L001585:
	xor	ESI,ESI
$L001586:
	pop	EBX
	mov	dword ptr [EBX],ESI 
	mov	ECX,ESI
	call	 UnitTesting_TestProperties_node
	mov	EAX,ESI 

;{355}:left= link.left;
	lea	ECX,dword ptr [EBP-000Ch]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	lea	EBX,dword ptr [EBP-0010h]
	mov	dword ptr [EBX],EAX

;{357}:link.left= left;
	lea	ECX,dword ptr [EBP-000Ch]
	lea	EAX,dword ptr [ECX]
	push	EAX
	mov	EAX,dword ptr [EBP-16]
	pop	EBX
	mov	dword ptr [EBX],EAX

;{359}:shapes1[0].Draw();
	mov	ECX,dword ptr [EBP-0098h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{360}:shapes2[0].Draw();
	mov	ECX,dword ptr [EBP-0098h]
	mov	EAX,dword ptr [ECX+0004h]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{362}:shapes_ptr[0].Draw();
	mov	ECX,dword ptr [EBP-0098h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{364}:shapes1[1].Draw();
	mov	ECX,dword ptr [EBP-0098h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000001h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{365}:shapes2[2].Draw();
	mov	ECX,dword ptr [EBP-0098h]
	mov	EAX,dword ptr [ECX+0004h]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000002h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{367}:shapes_ptr[3].Draw();
	mov	ECX,dword ptr [EBP-0098h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	ECX,EAX 
	push	EAX
	mov	EAX,000000003h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{374}:if(shapes1 != null)
	mov	ECX,dword ptr [EBP-0098h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001587

;{375}:destroy []shapes1;
	mov	ECX,dword ptr [EBP-0098h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	test	EAX,EAX
	jz	OFFSET $L001589
	mov	ESI,EAX
	mov	ECX,dword ptr [ESI-0004h]
	lea	EDI,dword ptr [ESI+ECX]
	mov	EBX,ESI 
$L001590:
	mov	ECX,EBX 
	test	ECX,ECX
	jz	OFFSET $L001591
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001591:
	add	EBX,00000000Ch
	cmp	EBX,EDI
	jnz	OFFSET $L001590

	add	ESI,0FFFFFFFCh
	push	ESI
	call	 System_Memory_Destroy
$L001589:
$L001587:

;{377}:shapes1= _shape;
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	mov	ECX,dword ptr [EBP-0098h]
	mov	dword ptr [ECX],EAX

;{380}:local_circles;
	lea	EAX,dword ptr [EBP-008Ch]
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI+120]
	mov	EBX,ESI
$L001592:
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch
	cmp	EBX,EDI
	jnz	OFFSET $L001592

;{382}:local_circles[0].Draw();
	xor	EAX,EAX
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-008Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{384}:local_circles[2].Draw();
	mov	EAX,000000002h
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-008Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{386}:for(i= 0; i < n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0090h],EAX
	jmp	OFFSET $L001593
$L001594:
	mov	EAX,dword ptr [EBP-144]
	inc	dword ptr [EBP-144]
$L001593:
	mov	EAX,dword ptr [EBP-0090h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001595

;{387}:local_circles[i].Draw();
	mov	EAX,dword ptr [EBP-0090h]
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-008Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]
	jmp	OFFSET $L001594 
$L001595:

;{390}:circlxx= new UnitTesting::Circle[5];
	mov	EAX,000000005h
	imul	EAX,00000000Ch
	lea	EBX,dword ptr [EAX+4]
	push	EBX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001596
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI]
	mov	ECX,EBX 
	mov	EAX,0CDCDCDCDh 
	rep stos	byte ptr [EDI]
	mov	dword ptr [ESI],EBX 
	add	ESI,000000004h
	jmp	 $L001597
$L001596:
	xor	ESI,ESI
$L001597:
	mov	dword ptr [EBP-0094h],ESI 
	mov	ECX,dword ptr [ESI-0004h] 
	lea	EDI,dword ptr [ESI+ECX] 
	mov	EBX,ESI 
$L001598:
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch 
	cmp	EBX,EDI
	jnz	OFFSET $L001598
	mov	EAX,ESI 

;{392}:circlxx[0].Draw();
	mov	EAX,dword ptr [EBP-148]
	push	EAX
	xor	EAX,EAX
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]
;}
$L000901:
	lea	EAX,dword ptr [EBP-008Ch]
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI+120]
	mov	EBX,ESI
$L001600:
	mov	ECX,EBX 
	test	ECX,ECX
	jz	OFFSET $L001601
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001601:
	add	EBX,00000000Ch
	cmp	EBX,EDI
	jnz	OFFSET $L001600

	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_TestProperties_node_Destructor
$L001602:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestProperties_put_Shapes ENDP

UnitTesting_TestProperties PROC NEAR 
;void UnitTesting::TestProperties(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0048h],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestProperties 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_TestProperties

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestProperties ENDP

UnitTesting_TestProperties_node_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{303}:if(left != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	push	ECX
	xor	EAX,EAX
	pop	EBX
	cmp	EBX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001604

;{304}:destroy left;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX]
	mov	ECX,EAX 
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001607
	call	 UnitTesting_TestProperties_node_Destructor
$L001607:
	push	ESI
	call	 System_Memory_Destroy
$L001604:

;{305}:if(right != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	mov	ECX,EAX 
	push	ECX
	xor	EAX,EAX
	pop	EBX
	cmp	EBX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001608

;{306}:destroy right;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0004h]
	mov	ECX,EAX 
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001611
	call	 UnitTesting_TestProperties_node_Destructor
$L001611:
	push	ESI
	call	 System_Memory_Destroy
$L001608:

;{307}:if(value != null)
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	ECX,EAX 
	push	ECX
	xor	EAX,EAX
	pop	EBX
	cmp	EBX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001612

;{308}:destroy value;
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	ECX,EAX 
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001615
	mov	EAX,dword ptr [ECX] 
	call	dword ptr [EAX]
$L001615:
	push	ESI
	call	 System_Memory_Destroy
$L001612:
;}
$L000893:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestProperties_node_Destructor ENDP

UnitTesting_TestProperties_node PROC NEAR 
;void UnitTesting::TestProperties::node(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 __member_Init@UnitTesting_TestProperties_node
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestProperties_node ENDP

UnitTesting_TestSwitch_RunTest PROC NEAR 
;void UnitTesting::TestSwitch::RunTest(int option);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{14}:switch(option)
	mov	EAX,dword ptr [EBP+0008h]
	mov	ESI,EAX
	mov	EAX,000000001h
	cmp	EAX,ESI
	jz	OFFSET $L001617
	mov	EAX,000000002h
	cmp	EAX,ESI
	jz	OFFSET $L001618
	mov	EAX,000000003h
	cmp	EAX,ESI
	jz	OFFSET $L001619
	mov	EAX,000000004h
	cmp	EAX,ESI
	jz	OFFSET $L001620
	mov	EAX,000000005h
	cmp	EAX,ESI
	jz	OFFSET $L001621
	mov	EAX,000000006h
	cmp	EAX,ESI 
	jz	OFFSET $L001622 
	jmp	OFFSET $L001623
$L001617:

;{17}:Console::WriteLn("Opening file...");
	lea	EAX,OFFSET $S000639
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001616
$L001618:

;{20}:Console::WriteLn("Closing file...");
	lea	EAX,OFFSET $S000640
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001616
$L001619:

;{23}:Console::WriteLn("Do Write to file...");
	lea	EAX,OFFSET $S000641
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001616
$L001620:

;{26}:Console::WriteLn("Do Read from file...");
	lea	EAX,OFFSET $S000642
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001616
$L001621:

;{29}:Console::WriteLn("Do for 5 and follow to 6");
	lea	EAX,OFFSET $S000643
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
$L001622:
;{

;{32}:Console::WriteLn("Do 6, then finish");
	lea	EAX,OFFSET $S000645
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001616
$L001623:

;{36}:Console::WriteLn("Invalid Option : ", option);
	lea	EAX,OFFSET $S000646
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
$L001616:
;}
$L000637:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_TestSwitch_RunTest ENDP

UnitTesting_TestVirtuals_ExponentialRV_get_MU PROC NEAR 
;double get::MU(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{125}:return mu
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000575
;}
$L000575:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_ExponentialRV_get_MU ENDP

UnitTesting_TestVirtuals_ExponentialRV_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{138}:return "An exponential variable"
	lea	EAX,OFFSET $S000580
	jmp	OFFSET $L000579
;}
$L000579:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_ExponentialRV_Name ENDP

UnitTesting_TestVirtuals_ExponentialRV_Sample PROC NEAR 
;double Sample(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{134}:return -MU * Math::log10(UnitTesting::Rnd::NextDblEx())
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_ExponentialRV_get_MU
	push	EAX
	push	EDX 
	call	 UnitTesting_Rnd_NextDblEx
	push	EAX
	push	EDX 
	call	 Math_log10
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000578
;}
$L000578:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_ExponentialRV_Sample ENDP

UnitTesting_TestVirtuals_ExponentialRV PROC NEAR 
;void UnitTesting::TestVirtuals::ExponentialRV(double _mu);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_RandomVariable ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestVirtuals_ExponentialRV 
;{

;{130}:mu= _mu;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]
;}
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestVirtuals_ExponentialRV ENDP

UnitTesting_TestVirtuals_RandomVariable_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{62}:return "(none)"
	lea	EAX,OFFSET $S000547
	jmp	OFFSET $L000546
;}
$L000546:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_RandomVariable_Name ENDP

UnitTesting_TestVirtuals_RandomVariable PROC NEAR 
;void UnitTesting::TestVirtuals::RandomVariable(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestVirtuals_RandomVariable 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_RandomVariable ENDP

UnitTesting_TestVirtuals_SimpleRV_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{75}:return "A simple variable"
	lea	EAX,OFFSET $S000552
	jmp	OFFSET $L000551
;}
$L000551:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_SimpleRV_Name ENDP

UnitTesting_TestVirtuals_SimpleRV_Sample PROC NEAR 
;double Sample(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{70}:return UnitTesting::Rnd::NextDblEx()
	call	 UnitTesting_Rnd_NextDblEx
	jmp	OFFSET $L000550
;}
$L000550:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_SimpleRV_Sample ENDP

UnitTesting_TestVirtuals_SimpleRV PROC NEAR 
;void UnitTesting::TestVirtuals::SimpleRV(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_RandomVariable ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestVirtuals_SimpleRV 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_SimpleRV ENDP

UnitTesting_TestVirtuals_UniformRV_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{115}:return "An uniform variable"
	lea	EAX,OFFSET $S000570
	jmp	OFFSET $L000569
;}
$L000569:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_UniformRV_Name ENDP

UnitTesting_TestVirtuals_UniformRV_Sample PROC NEAR 
;double Sample(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{111}:return u + (v - u) * UnitTesting::Rnd::NextDblEx()
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0010h]
	mov	EDX,dword ptr [ECX+000Ch] 
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 UnitTesting_Rnd_NextDblEx
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000568
;}
$L000568:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_UniformRV_Sample ENDP

UnitTesting_TestVirtuals_UniformRV_get_U PROC NEAR 
;double get::U(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{86}:return u
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000558
;}
$L000558:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_UniformRV_get_U ENDP

UnitTesting_TestVirtuals_UniformRV_put_U PROC NEAR 
;void put::U(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{91}:u= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]
;}
$L000559:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestVirtuals_UniformRV_put_U ENDP

UnitTesting_TestVirtuals_UniformRV PROC NEAR 
;void UnitTesting::TestVirtuals::UniformRV(double _u, double _v);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_RandomVariable ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_TestVirtuals_UniformRV 
;{

;{106}:U= _u;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_UniformRV_put_U

;{106}:V= _v;
	mov	EDX,dword ptr [EBP+0010h]
	mov	EAX,dword ptr [EBP+0014h] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_TestVirtuals_UniformRV_put_V
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000010h
UnitTesting_TestVirtuals_UniformRV ENDP

UnitTesting_TestVirtuals_UniformRV_get_V PROC NEAR 
;double get::V(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{96}:return v
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0010h]
	mov	EDX,dword ptr [ECX+000Ch] 
	jmp	OFFSET $L000562
;}
$L000562:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_TestVirtuals_UniformRV_get_V ENDP

UnitTesting_TestVirtuals_UniformRV_put_V PROC NEAR 
;void put::V(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{101}:v= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+000Ch]
;}
$L000563:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_TestVirtuals_UniformRV_put_V ENDP

UnitTesting_Triangle_get_Base PROC NEAR 
;double get::Base(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{181}:return dBase
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	jmp	OFFSET $L000707
;}
$L000707:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_get_Base ENDP

UnitTesting_Triangle_put_Base PROC NEAR 
;void put::Base(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{186}:dBase= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]
;}
$L000708:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Triangle_put_Base ENDP

UnitTesting_Triangle_ComputeArea PROC NEAR 
;double ComputeArea(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{215}:return Base * High / 2
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Triangle_get_Base
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Triangle_get_High
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX 
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000719
;}
$L000719:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_ComputeArea ENDP

UnitTesting_Triangle_Destructor PROC NEAR 
;void Destructor(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{220}:System::Debug::OutputString("destroying a Triangle object...");
	lea	EAX,OFFSET $S000721
	push	EAX
	call	 System_Debug_OutputString

;{221}:Console::WriteLn("destroying a Triangle object...");
	lea	EAX,OFFSET $S000721
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{222}:return 
	jmp	OFFSET $L000720
;}
$L000720:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_Destructor ENDP

UnitTesting_Triangle_Draw PROC NEAR 
;void Draw(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{209}:Console::WriteLn("Drawing a Triangle!");
	lea	EAX,OFFSET $S000718
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000717:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_Draw ENDP

UnitTesting_Triangle_DrawPiramid PROC NEAR 
;void DrawPiramid(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{227}:Console::WriteLn("Drawing a Piramid!");
	lea	EAX,OFFSET $S000723
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L000722:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_DrawPiramid ENDP

UnitTesting_Triangle_get_High PROC NEAR 
;double get::High(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{191}:return dHigh
	mov	ECX,dword ptr [EBP-0004h]
	mov	EAX,dword ptr [ECX+0010h]
	mov	EDX,dword ptr [ECX+000Ch] 
	jmp	OFFSET $L000711
;}
$L000711:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_get_High ENDP

UnitTesting_Triangle_put_High PROC NEAR 
;void put::High(double value);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{196}:dHigh= value;
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+000Ch]
;}
$L000712:
	pop	EDX
	pop	EAX 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Triangle_put_High ENDP

UnitTesting_Triangle_Name PROC NEAR 
;string Name(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{204}:return "Triangle"
	lea	EAX,OFFSET $S000716
	jmp	OFFSET $L000715
;}
$L000715:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_Name ENDP

UnitTesting_Triangle_Type PROC NEAR 
;UnitTesting::ShapeType Type(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{200}:return UnitTesting::stTriangle
	mov	EAX,000000003h
	jmp	OFFSET $L000714
;}
$L000714:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle_Type ENDP

UnitTesting_Triangle PROC NEAR 
;void UnitTesting::Triangle(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	ECX,dword ptr [EBP-0004h]
	call	 UnitTesting_Shape ;base constructor call
	mov	ECX,dword ptr [EBP-0004h] 
	mov	dword ptr [ECX],OFFSET  @@class_vptr_vtbl@@__UnitTesting_Triangle 
	mov	ECX,dword ptr [EBP-0004h] 
	call	 __member_Init@UnitTesting_Triangle 
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
UnitTesting_Triangle ENDP

UnitTesting_Visitor_Visit PROC NEAR 
;void Visit(UnitTesting::Shape ^ shape);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000014h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0014h],ECX
	lea	EDI,dword ptr [EBP-0010h]
	mov	ECX,000000004h 
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
	mov	ECX,dword ptr [EBP-0014h] 
;{

;{312}:shape.Draw();
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{314}:shape_ptr= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX

;{316}:switch(shape.Type())
	mov	ECX,dword ptr [EBP+0008h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	mov	ESI,EAX
	mov	EAX,000000001h
	cmp	EAX,ESI
	jz	OFFSET $L001627
	mov	EAX,000000002h
	cmp	EAX,ESI
	jz	OFFSET $L001628
	mov	EAX,000000003h
	cmp	EAX,ESI
	jz	OFFSET $L001629
	jmp	OFFSET $L001630
$L001627:
;{

;{320}:Console::WriteLn("type == stCircle");
	lea	EAX,OFFSET $S000734
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{322}:circle= dynamic_cast(shape);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	lea	EBX,dword ptr [EBP-0008h]
	mov	dword ptr [EBX],EAX

;{323}:circle.DrawSphere();
	mov	ECX,dword ptr [EBP-8]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0014h]

;{325}:shape_ptr= circle;
	mov	EAX,dword ptr [EBP-8]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX
;}
	jmp	OFFSET $L001626
$L001628:
;{

;{330}:Console::WriteLn("type == stSquare");
	lea	EAX,OFFSET $S000736
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{332}:square= dynamic_cast(shape);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	lea	EBX,dword ptr [EBP-000Ch]
	mov	dword ptr [EBX],EAX

;{333}:square.DrawCube();
	mov	ECX,dword ptr [EBP-12]
	call	 UnitTesting_Square_DrawCube

;{335}:shape_ptr= square;
	mov	EAX,dword ptr [EBP-12]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX
;}
	jmp	OFFSET $L001626
$L001629:
;{

;{340}:Console::WriteLn("type == stTriangle");
	lea	EAX,OFFSET $S000738
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{342}:triangle= dynamic_cast(shape);
	mov	EBX,dword ptr [EBP+0008h]
	mov	EAX,EBX 
	lea	EBX,dword ptr [EBP-0010h]
	mov	dword ptr [EBX],EAX

;{343}:triangle.DrawPiramid();
	mov	ECX,dword ptr [EBP-16]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0014h]

;{345}:shape_ptr= triangle;
	mov	EAX,dword ptr [EBP-16]
	lea	EBX,dword ptr [EBP-0004h]
	mov	dword ptr [EBX],EAX
;}
	jmp	OFFSET $L001626
$L001630:
	int	000000003h ;User breakpoint
$L001626:

;{353}:if(shape_ptr != null)
	mov	EAX,dword ptr [EBP-4]
	mov	ECX,EAX 
	push	ECX
	xor	EAX,EAX
	pop	EBX
	cmp	EBX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001631

;{354}:shape_ptr.Draw();
	mov	ECX,dword ptr [EBP-4]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]
$L001631:

;{356}:if(null != shape_ptr)
	xor	EAX,EAX
	push	EAX
	mov	EAX,dword ptr [EBP-4]
	pop	ECX
	cmp	ECX,EAX
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001633

;{357}:shape_ptr.Draw();
	mov	ECX,dword ptr [EBP-4]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]
$L001633:

;{360}:Console::WriteLn("**Visited object name = ", shape_ptr.Name());
	lea	EAX,OFFSET $S000740
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	ECX,dword ptr [EBP-4]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0008h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 
;}
$L000731:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000004h
UnitTesting_Visitor_Visit ENDP

__member_Init@UnitTesting_Circle PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:radius= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Circle ENDP
__member_Init@UnitTesting_DoubleProxy PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:val= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_DoubleProxy ENDP
__member_Init@UnitTesting_Objects_Array PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:array= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX

;{0}:_length= 0;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],EAX

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Objects_Array ENDP
__member_Init@UnitTesting_Objects_Automobile PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:speed= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Objects_Automobile ENDP
__member_Init@UnitTesting_Rnd PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:UnitTesting::Rnd::seed= 1;
	mov	EAX,000000001h
	mov	 UnitTesting_Rnd_seed,EAX

;{0}:UnitTesting::Rnd::a= 16807;
	mov	EAX,0000041A7h
	mov	 UnitTesting_Rnd_a,EAX

;{0}:UnitTesting::Rnd::m= 2147483647;
	mov	EAX,07FFFFFFFh
	mov	 UnitTesting_Rnd_m,EAX

;{0}:UnitTesting::Rnd::q= 127773;
	mov	EAX,00001F31Dh
	mov	 UnitTesting_Rnd_q,EAX

;{0}:UnitTesting::Rnd::r= 2836;
	mov	EAX,000000B14h
	mov	 UnitTesting_Rnd_r,EAX

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Rnd ENDP
__member_Init@UnitTesting_ShapeFactoryCreator PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:ptr3= new UnitTesting::Circle();
	push	00000000Ch
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001635
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000003h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001636
$L001635:
	xor	ESI,ESI
$L001636:
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],ESI 
	mov	ECX,ESI
	call	 UnitTesting_Circle
	mov	EAX,ESI 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_ShapeFactoryCreator ENDP
__member_Init@UnitTesting_Square PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:dWidth= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]

;{0}:dHeight= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+000Ch]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Square ENDP
__member_Init@UnitTesting_TestIntegers PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:nWidth= 0;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX

;{0}:nHeight= 0;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],EAX

;{0}:UnitTesting::TestIntegers::bigValue= 2147483648;
	mov	EAX,0FFFFFFFFh
	cdq	
	lea	EBX,OFFSET UnitTesting_TestIntegers_bigValue
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBX+4],EDX 

;{0}:member1= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0008h]

;{0}:member2= 1.0;
	fld1
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0010h]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_TestIntegers ENDP
__member_Init@UnitTesting_TestProperties PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:shapes1= new UnitTesting::Circle[10];
	mov	EAX,00000000Ah
	imul	EAX,00000000Ch
	lea	EBX,dword ptr [EAX+4]
	push	EBX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001637
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI]
	mov	ECX,EBX 
	mov	EAX,0CDCDCDCDh 
	rep stos	byte ptr [EDI]
	mov	dword ptr [ESI],EBX 
	add	ESI,000000004h
	jmp	 $L001638
$L001637:
	xor	ESI,ESI
$L001638:
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],ESI 
	mov	ECX,dword ptr [ESI-0004h] 
	lea	EDI,dword ptr [ESI+ECX] 
	mov	EBX,ESI 
$L001639:
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch 
	cmp	EBX,EDI
	jnz	OFFSET $L001639
	mov	EAX,ESI 

;{0}:shapes2= new UnitTesting::Circle[4];
	mov	EAX,000000004h
	imul	EAX,00000000Ch
	lea	EBX,dword ptr [EAX+4]
	push	EBX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001640
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI]
	mov	ECX,EBX 
	mov	EAX,0CDCDCDCDh 
	rep stos	byte ptr [EDI]
	mov	dword ptr [ESI],EBX 
	add	ESI,000000004h
	jmp	 $L001641
$L001640:
	xor	ESI,ESI
$L001641:
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],ESI 
	mov	ECX,dword ptr [ESI-0004h] 
	lea	EDI,dword ptr [ESI+ECX] 
	mov	EBX,ESI 
$L001642:
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch 
	cmp	EBX,EDI
	jnz	OFFSET $L001642
	mov	EAX,ESI 

;{0}:shapes_ptr= new UnitTesting::Circle[10];
	mov	EAX,00000000Ah
	imul	EAX,00000000Ch
	lea	EBX,dword ptr [EAX+4]
	push	EBX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001643
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI]
	mov	ECX,EBX 
	mov	EAX,0CDCDCDCDh 
	rep stos	byte ptr [EDI]
	mov	dword ptr [ESI],EBX 
	add	ESI,000000004h
	jmp	 $L001644
$L001643:
	xor	ESI,ESI
$L001644:
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0008h],ESI 
	mov	ECX,dword ptr [ESI-0004h] 
	lea	EDI,dword ptr [ESI+ECX] 
	mov	EBX,ESI 
$L001645:
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch 
	cmp	EBX,EDI
	jnz	OFFSET $L001645
	mov	EAX,ESI 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_TestProperties ENDP
__member_Init@UnitTesting_TestProperties_node PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:left= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX],EAX

;{0}:right= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0004h],EAX

;{0}:value= null;
	xor	EAX,EAX
	mov	ECX,dword ptr [EBP-0004h]
	mov	dword ptr [ECX+0008h],EAX

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_TestProperties_node ENDP
__member_Init@UnitTesting_Triangle PROC NEAR

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0004h],ECX

;{0}:dBase= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+0004h]

;{0}:dHigh= 0.0;
	fldz
	mov	ECX,dword ptr [EBP-0004h]
	fstp	qword ptr [ECX+000Ch]

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__member_Init@UnitTesting_Triangle ENDP
UnitTesting_Test1_TestRunner_main PROC NEAR 
;void UnitTesting::Test1::TestRunner::main(int argc, string string [] argv);
	push	EBP
	mov	EBP,ESP
	sub	ESP,0000004C8h
	push	EBX 
	push	ESI 
	push	EDI 
	lea	EDI,dword ptr [EBP-04C8h]
	mov	ECX,000000132h
	mov	EAX,0CCCCCCCCh 
	rep stos	dword ptr [EDI]
;{

;{1081}:for(ac= 0; ac < argc; ac++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0004h],EAX
	jmp	OFFSET $L001646
$L001647:
	mov	EAX,dword ptr [EBP-4]
	inc	dword ptr [EBP-4]
$L001646:
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001648
;{

;{1083}:Console::WriteLn("Argument: [", ac, "]= ", argv[ac]);
	lea	EAX,OFFSET $S001200
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0004h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001201
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,dword ptr [EBP-0004h]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001647 
$L001648:

;{1086}:bUnattended= argc > 1 && (argv[1] == "/Silent");
	mov	EAX,dword ptr [EBP+0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001649
	mov	EBX,dword ptr [EBP+000Ch]
	mov	EAX,EBX 
	push	EAX
	mov	EAX,000000001h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	lea	EAX,OFFSET $S001203
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setz	AL
$L001649:
	mov	byte ptr [EBP-0008h],AL

;{1088}:bUnattended= bUnattended || 5 >= 5.99;
	movzx	EAX,byte ptr [EBP-0008h]
	test	AL,AL
	jnz	OFFSET $L001650
	mov	EAX,000000005h
	push	EAX
	mov	EDX,08F5C28F6h
	mov	EAX,04017F5C2h 
	push	EAX
	push	EDX 
	call	 FloatingPoint_CompareToInteger
	cmp	EAX,000000000h
	neg	EAX
	setge	AL
$L001650:
	mov	byte ptr [EBP-0008h],AL

;{1090}:__HELLO_PART: hello();
__HELLO_PART:

;{1091}:hello();
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_HelloWorld

;{1093}:say= "Hello World from H++!!!";
	lea	EAX,OFFSET $S001208
	mov	dword ptr [EBP-0010h],EAX

;{1095}:hello.SayHello(say);
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_HelloWorld_SayHello

;{1097}:if(false == bUnattended)
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-0008h]
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L001651

;{1098}:hello.ShowHello(say);
	mov	EAX,dword ptr [EBP-0010h]
	push	EAX
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_HelloWorld_ShowHello
$L001651:

;{1101}:tester1;
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers

;{1103}:tester1.Width= 0x400h * 1024;
	mov	EAX,000000400h
	push	EAX
	mov	EAX,000000400h
	pop	ECX
	xor	EDX,EDX
	imul	EAX,ECX
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_put_Width

;{1104}:tester1.Height= 0x20h;
	mov	EAX,000000020h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_put_Height

;{1106}:nWidth= tester1.Width, nHeight= tester1.Height;
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_get_Width
	mov	dword ptr [EBP-0044h],EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_get_Height
	mov	dword ptr [EBP-0048h],EAX

;{1109}:nArea= tester1.Width * tester1.Height;
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_get_Height
	pop	ECX
	cdq	
	imul	EAX,ECX
	cdq	
	lea	EBX,dword ptr [EBP-0050h]
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBX+4],EDX 

;{1111}:Console::WriteLn("nArea = ", nArea);
	lea	EAX,OFFSET $S001214
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0050h]
	mov	EDX,dword ptr [EBP-004Ch] 
	push	EDX 
	push	EAX 
	call	 Console_WriteInteger64 
	call	 Console_WriteCrLf 

;{1113}:with(tester1)
;{
	mov	EAX,000000666h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_put_Width
	mov	EAX,000000777h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_put_Height
;}

;{1125}:nArea= nWidth * nHeight;
	mov	EAX,dword ptr [EBP-0044h]
	push	EAX
	mov	EAX,dword ptr [EBP-0048h]
	pop	ECX
	cdq	
	imul	EAX,ECX
	cdq	
	lea	EBX,dword ptr [EBP-0050h]
	mov	dword ptr [EBX],EAX
	mov	dword ptr [EBX+4],EDX 

;{1127}:Console::WriteLn("nArea = ", nArea);
	lea	EAX,OFFSET $S001214
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0050h]
	mov	EDX,dword ptr [EBP-004Ch] 
	push	EDX 
	push	EAX 
	call	 Console_WriteInteger64 
	call	 Console_WriteCrLf 

;{1129}:n= 10;
	mov	EAX,00000000Ah
	mov	dword ptr [EBP-0054h],EAX

;{1131}:UnitTesting::Integers_Inline::Test();
	call	 UnitTesting_Integers_Inline_Test

;{1133}:for(index= 0; index < 50; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0058h],EAX
	jmp	OFFSET $L001653
$L001654:
	mov	EAX,dword ptr [EBP-88]
	inc	dword ptr [EBP-88]
$L001653:
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,000000032h
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001655
;{

;{1135}:Console::WriteLn("Current Index :", index);
	lea	EAX,OFFSET $S001219
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001654 
$L001655:

;{1138}:for(; ; )
	jmp	OFFSET $L001656
$L001657:
$L001656:
;{

;{1141}:if(--index == 0)
	dec	dword ptr [EBP-88]
	mov	EAX,dword ptr [EBP-88]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001659

;break;
	jmp	OFFSET $L001658
$L001659:
;}
	jmp	OFFSET $L001657 
$L001658:

;{1146}:what= !(index == 0);
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	neg	EAX
	not	EAX
	mov	byte ptr [EBP-005Ch],AL

;{1148}:__CALC_FACTORIAL: nf= tester1.Factorial(n);
__CALC_FACTORIAL:

;{1150}:nf= tester1.Factorial(n);
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_Factorial
	mov	dword ptr [EBP-0060h],EAX

;{1152}:Console::WriteLn("Factorial of ", n, " = ", nf);
	lea	EAX,OFFSET $S001223
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001224
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0060h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1154}:--n;
	dec	dword ptr [EBP-84]
	mov	EAX,dword ptr [EBP-84]

;{1155}:if(n == 0)
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001661

;goto
	jmp	OFFSET __END_FACTORIAL
$L001661:

;goto
	jmp	OFFSET __CALC_FACTORIAL

;{1160}:__END_FACTORIAL: myRef1= 0;
__END_FACTORIAL:

;{1163}:myRef1= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0064h],EAX

;{1164}:myVar1= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-0068h],EAX

;{1168}:tester1.multiple_assignments(myRef1, myVar1);
	mov	EAX,dword ptr [EBP-0068h]
	push	EAX
	lea	EAX,dword ptr [EBP-0064h]
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_multiple_assignments

;{1170}:Console::WriteLn("The value of myRef1 must be 65536 ==", myRef1);
	lea	EAX,OFFSET $S001228
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0064h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1171}:Console::WriteLn("The value of myVar1 is not 65536 but zero (0) == ", myVar1);
	lea	EAX,OFFSET $S001229
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0068h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1173}:Console::WriteLn("(int)the area is: ", tester1.getArea());
	lea	EAX,OFFSET $S001230
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_getArea
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1174}:Console::WriteLn("(double)the area is: ", tester1.getArea2());
	lea	EAX,OFFSET $S001231
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_getArea2
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1176}:result= 0;
	xor	EAX,EAX
	mov	dword ptr [EBP-006Ch],EAX

;{1177}:tester1.add(1024, 3072, result);
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000000C00h
	push	EAX 
	mov	EAX,000000400h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_add

;{1179}:tester1.subs(1024, 3072, result);
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000000C00h
	push	EAX 
	mov	EAX,000000400h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_subs

;{1181}:tester1.subs(3072, 1024, result);
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000000400h
	push	EAX 
	mov	EAX,000000C00h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_subs

;{1183}:tester1.modulus(4096, 6, result);
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000000006h
	push	EAX 
	mov	EAX,000001000h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_modulus

;{1185}:tester1.multiply(3, 927, result);
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,00000039Fh
	push	EAX 
	mov	EAX,000000003h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_multiply

;{1187}:tester1.divide(4096, 6, result);
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000000006h
	push	EAX 
	mov	EAX,000001000h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_divide

;{1189}:tester1.divide2(4096, 6, result);
	lea	EAX,dword ptr [EBP-006Ch]
	push	EAX
	mov	EAX,000000006h
	push	EAX 
	mov	EAX,000001000h
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_divide2

;{1193}:UnitTesting::TestIntegers::TestExpressions();
	call	 UnitTesting_TestIntegers_TestExpressions

;{1195}:val1= 1, val2= 2;
	mov	EAX,000000001h
	mov	dword ptr [EBP-0070h],EAX
	mov	EAX,000000002h
	mov	dword ptr [EBP-0074h],EAX

;{1197}:what= false;
	xor	EAX,EAX
	mov	byte ptr [EBP-005Ch],AL

;{1199}:tester1.Swap(val1, val2);
	lea	EAX,dword ptr [EBP-0074h]
	push	EAX
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_Swap

;{1201}:what= val1 == 2 && val2 == 1;
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,000000002h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001663
	mov	EAX,dword ptr [EBP-0074h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
$L001663:
	mov	byte ptr [EBP-005Ch],AL

;{1203}:Console::WriteLn("what == True ?", what);
	lea	EAX,OFFSET $S001237
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-005Ch]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{1205}:tester1.Calc2(val1, val2);
	lea	EAX,dword ptr [EBP-0074h]
	push	EAX
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_Calc2

;{1208}:what= val1 == 27000 && val2 == 20000;
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,000006978h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001664
	mov	EAX,dword ptr [EBP-0074h]
	push	EAX
	mov	EAX,000004E20h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
$L001664:
	mov	byte ptr [EBP-005Ch],AL

;{1210}:Console::WriteLn("what == True ?", what);
	lea	EAX,OFFSET $S001237
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-005Ch]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{1212}:tester1.Swap(val1, val2);
	lea	EAX,dword ptr [EBP-0074h]
	push	EAX
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_Swap

;{1214}:what= val1 == 20000 && val2 == 27000;
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,000004E20h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001665
	mov	EAX,dword ptr [EBP-0074h]
	push	EAX
	mov	EAX,000006978h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
$L001665:
	mov	byte ptr [EBP-005Ch],AL

;{1216}:Console::WriteLn("what == True ?", what);
	lea	EAX,OFFSET $S001237
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-005Ch]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{1218}:tester1.SwapDebug(val1, val2);
	lea	EAX,dword ptr [EBP-0074h]
	push	EAX
	lea	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_SwapDebug

;{1220}:what= val1 == 27000 && val2 == 20000;
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,000006978h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jz	OFFSET $L001666
	mov	EAX,dword ptr [EBP-0074h]
	push	EAX
	mov	EAX,000004E20h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
$L001666:
	mov	byte ptr [EBP-005Ch],AL

;{1222}:Console::WriteLn("what == True ?", what);
	lea	EAX,OFFSET $S001237
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-005Ch]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{1224}:tester1.Calc1(val1, val2);
	lea	EAX,dword ptr [EBP-0074h]
	push	EAX
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	lea	ECX,dword ptr [EBP-0040h]
	call	 UnitTesting_TestIntegers_Calc1

;{1226}:what= val2 != 27000;
	mov	EAX,dword ptr [EBP-0074h]
	push	EAX
	mov	EAX,000006978h
	pop	EDX
	cmp	EDX,EAX
	setnz	AL
	mov	byte ptr [EBP-005Ch],AL

;{1228}:val1= val1 << 24;
	mov	EAX,dword ptr [EBP-0070h]
	shl	EAX,000000018h
	mov	dword ptr [EBP-0070h],EAX

;{1230}:what= val1 == 0x78000000;
	mov	EAX,dword ptr [EBP-0070h]
	push	EAX
	mov	EAX,078000000h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	mov	byte ptr [EBP-005Ch],AL

;{1232}:Console::WriteLn("(what = val1 == 0x78000000) = ", what);
	lea	EAX,OFFSET $S001241
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-005Ch]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{1234}:if(false == bUnattended)
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-0008h]
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L001667

;{1235}:hello.ShowHello("H++ Unit Testing : Second Phase");
	lea	EAX,OFFSET $S001242
	push	EAX
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_HelloWorld_ShowHello
$L001667:

;{1237}:fpTester();
	lea	ECX,dword ptr [EBP-0078h]
	call	 UnitTesting_TestFloatingPoint

;{1239}:for(index= 0; index <= 32; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0058h],EAX
	jmp	OFFSET $L001669
$L001670:
	mov	EAX,dword ptr [EBP-88]
	inc	dword ptr [EBP-88]
$L001669:
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,000000020h
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L001671
;{

;{1241}:_pow= fpTester.Power(2.0, index);
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	xor	EDX,EDX
	mov	EAX,040000000h
	push	EAX
	push	EDX 
	lea	ECX,dword ptr [EBP-0078h]
	call	 UnitTesting_TestFloatingPoint_Power
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0080h]

;{1243}:Console::WriteLn("pow(2, ", index, ") = ", _pow);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001246
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001247
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,dword ptr [EBP-0080h]
	mov	EAX,dword ptr [EBP-007Ch] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001670 
$L001671:

;{1246}:array1;
	lea	EAX,dword ptr [EBP-00D0h]

;{1249}:for(index= 0; index < sizeof (array1) / sizeof (int); )
	xor	EAX,EAX
	mov	dword ptr [EBP-0058h],EAX
	jmp	OFFSET $L001672
$L001673:
$L001672:
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,000000050h
	push	EAX
	mov	EAX,000000004h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_CompareToInteger
	cmp	EAX,000000000h
	neg	EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001674
;{

;{1251}:array1[index]= FloatingPoint::ToInt((index + 1) * 9.45);
	mov	EAX,dword ptr [EBP-0058h]
	imul	EAX,EAX,000000004h
	lea	EAX,dword ptr [EBP+EAX-00D0h]
	push	EAX
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EDX,066666667h
	mov	EAX,04022E666h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1252}:Console::WriteLn("Result for array1[", index, "] = ", array1[index]);
	lea	EAX,OFFSET $S001250
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001165
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0058h]
	imul	EAX,EAX,000000004h
	mov	EAX,dword ptr [EBP+EAX-00D0h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1253}:index++ ;
	mov	EAX,dword ptr [EBP-88]
	inc	dword ptr [EBP-88]
;}
	jmp	OFFSET $L001673 
$L001674:

;{1256}:UnitTesting::TestArrays::DoTest();
	call	 UnitTesting_TestArrays_DoTest

;{1260}:rnd(Math::Round(0x400 * Math::log_10_base2() + 1.0));
	mov	EAX,000000400h
	push	EAX
	call	 Math_log_10_base2
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld1
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Round
	push	EAX
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd

;{1264}:Console::WriteLn("Pseudo-Random Integer values:");
	lea	EAX,OFFSET $S001252
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{1265}:Console::WriteLn("(1)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S001253
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1266}:Console::WriteLn("(2)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S001254
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1267}:Console::WriteLn("(3)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S001255
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1268}:Console::WriteLn("(4)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S001256
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1269}:Console::WriteLn("(5)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S001257
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1270}:Console::WriteLn("(6)A pseudo-random value: ", rnd.NextInt());
	lea	EAX,OFFSET $S001258
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextInt
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1272}:_BlockRndDoubles: Console::WriteLn("Pseudo-Random Double values:");
_BlockRndDoubles:

;{1274}:Console::WriteLn("Pseudo-Random Double values:");
	lea	EAX,OFFSET $S001260
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{1275}:Console::WriteLn("(1)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S001253
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1276}:Console::WriteLn("(2)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S001254
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1277}:Console::WriteLn("(3)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S001255
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1278}:Console::WriteLn("(4)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S001256
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1279}:Console::WriteLn("(5)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S001257
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1280}:Console::WriteLn("(6)A pseudo-random value: ", rnd.NextDbl());
	lea	EAX,OFFSET $S001258
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00D4h]
	call	 UnitTesting_Rnd_NextDbl
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1285}:res= 0.0;
	fldz
	fstp	qword ptr [EBP-00DCh]

;{1287}:srv;
	lea	ECX,dword ptr [EBP-00E0h]
	call	 UnitTesting_TestVirtuals_SimpleRV

;{1289}:res= srv.Sample();
	lea	ECX,dword ptr [EBP-00E0h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1290}:Console::WriteLn("(1)A simple random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001263
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1291}:res= srv.Sample();
	lea	ECX,dword ptr [EBP-00E0h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1292}:Console::WriteLn("(2)A simple random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001265
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1293}:res= srv.Sample();
	lea	ECX,dword ptr [EBP-00E0h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1294}:Console::WriteLn("(3)A simple random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001266
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1295}:res= srv.Sample();
	lea	ECX,dword ptr [EBP-00E0h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1296}:Console::WriteLn("(4)A simple random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001267
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1297}:Console::WriteLn("my name is", srv.Name());
	lea	EAX,OFFSET $S001268
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00E0h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1299}:res= 1.0;
	fld1
	fstp	qword ptr [EBP-00DCh]

;{1301}:urv(Math::log_e_base2(), Math::log_2_base_e());
	call	 Math_log_2_base_e
	push	EAX 
	push	EDX 
	call	 Math_log_e_base2
	push	EAX
	push	EDX 
	lea	ECX,dword ptr [EBP-00F4h]
	call	 UnitTesting_TestVirtuals_UniformRV

;{1303}:res= urv.Sample();
	lea	ECX,dword ptr [EBP-00F4h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1304}:Console::WriteLn("(1)An uniform random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001270
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1305}:res= urv.Sample();
	lea	ECX,dword ptr [EBP-00F4h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1306}:Console::WriteLn("(2)An uniform random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001271
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1307}:res= urv.Sample();
	lea	ECX,dword ptr [EBP-00F4h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1308}:Console::WriteLn("(3)An uniform random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001272
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1309}:res= urv.Sample();
	lea	ECX,dword ptr [EBP-00F4h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1310}:Console::WriteLn("(4)An uniform random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001273
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1311}:Console::WriteLn("my name is", urv.Name());
	lea	EAX,OFFSET $S001268
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-00F4h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1313}:res= 0.0;
	fldz
	fstp	qword ptr [EBP-00DCh]

;{1315}:erv(Math::pi());
	call	 Math_pi
	push	EAX
	push	EDX 
	lea	ECX,dword ptr [EBP-0100h]
	call	 UnitTesting_TestVirtuals_ExponentialRV

;{1317}:res= erv.Sample();
	lea	ECX,dword ptr [EBP-0100h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1318}:Console::WriteLn("(1)An exponential random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001275
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1319}:res= erv.Sample();
	lea	ECX,dword ptr [EBP-0100h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1320}:Console::WriteLn("(2)An exponential random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001276
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1321}:res= erv.Sample();
	lea	ECX,dword ptr [EBP-0100h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1322}:Console::WriteLn("(3)An exponential random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001277
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1323}:res= erv.Sample();
	lea	ECX,dword ptr [EBP-0100h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1324}:Console::WriteLn("(4)An exponential random variable has : ", res, " as its value.");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001278
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001264
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1325}:Console::WriteLn("my name is", erv.Name());
	lea	EAX,OFFSET $S001268
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0100h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1329}:UnitTesting::TestSwitch::RunTest(UnitTesting::TestSwitch::open);
	mov	EAX,000000001h
	push	EAX
	call	 UnitTesting_TestSwitch_RunTest

;{1332}:obj;
	lea	ECX,dword ptr [EBP-010Ch]
	call	 UnitTesting_Circle

;{1334}:obj.Radius= 115.456;
	mov	EDX,01A9FBE77h
	mov	EAX,0405CDD2Fh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-010Ch]
	call	 UnitTesting_Circle_put_Radius

;{1338}:Console::WriteLn("Circle.Radius = ", obj.Radius);
	lea	EAX,OFFSET $S001282
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-010Ch]
	call	 UnitTesting_Circle_get_Radius
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1340}:area= obj.ComputeArea();
	lea	ECX,dword ptr [EBP-010Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0114h]

;{1342}:Console::WriteLn("Circle.Area = ", area);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001284
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-0114h]
	mov	EAX,dword ptr [EBP-0110h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1345}:obj2= obj;
	lea	ECX,dword ptr [EBP-0120h]
	call	 UnitTesting_Circle
	lea	ECX,dword ptr [EBP-010Ch]
	mov	ESI,ECX
	lea	EBX,dword ptr [EBP-0120h]
	mov	EDI,EBX 
	mov	ECX,00000000Ch 
	cld	
	rep movsb	

;{1347}:what= (area == obj2.ComputeArea());
	mov	EDX,dword ptr [EBP-0114h]
	mov	EAX,dword ptr [EBP-0110h] 
	push	EAX
	push	EDX 
	lea	ECX,dword ptr [EBP-0120h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	EAX
	push	EDX 
	call	 FloatingPoint_Compare
	cmp	EAX,000000000h
	neg	EAX
	setz	AL
	mov	byte ptr [EBP-005Ch],AL

;{1349}:Console::WriteLn("what must be true = ", what);
	lea	EAX,OFFSET $S001286
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	movzx	EAX,byte ptr [EBP-005Ch]
	push	EAX 
	call	 Console_WriteBoolean 
	call	 Console_WriteCrLf 

;{1351}:if(obj == obj2)
	lea	ECX,dword ptr [EBP-010Ch]
	push	ECX
	lea	ECX,dword ptr [EBP-0120h]
	pop	EDI
	mov	ESI,ECX
	mov	ECX,00000000Ch 
	cld	
	repe cmpsb	
	setz	AL
	test	AL,AL
	jz	OFFSET $L001675
;{

;{1353}:Console::WriteLn("obj==obj2");
	lea	EAX,OFFSET $S001287
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001675:

;{1356}:sq;
	lea	ECX,dword ptr [EBP-0134h]
	call	 UnitTesting_Square

;{1358}:sq.Width= 500.456;
	mov	EDX,0C6A7EF9Eh
	mov	EAX,0407F474Bh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-0134h]
	call	 UnitTesting_Square_put_Width

;{1359}:sq.Height= 1045.4564;
	mov	EDX,05A858794h
	mov	EAX,0409055D3h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-0134h]
	call	 UnitTesting_Square_put_Height

;{1361}:sq.ComputeArea();
	lea	ECX,dword ptr [EBP-0134h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]

;{1363}:Console::WriteLn("sq.Width = ", sq.Width, ", sq.Height = ", sq.Height, ", area = ", sq.ComputeArea());
	lea	EAX,OFFSET $S001291
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0134h]
	call	 UnitTesting_Square_get_Width
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001292
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	lea	ECX,dword ptr [EBP-0134h]
	call	 UnitTesting_Square_get_Height
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001293
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	lea	ECX,dword ptr [EBP-0134h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1365}:tri;
	lea	ECX,dword ptr [EBP-0148h]
	call	 UnitTesting_Triangle

;{1367}:tri.Base= 450.4564;
	mov	EDX,06A161E50h
	mov	EAX,0407C274Dh 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-0148h]
	call	 UnitTesting_Triangle_put_Base

;{1368}:tri.High= 4572.4564;
	mov	EDX,0D6A161E5h
	mov	EAX,040B1DC74h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	lea	ECX,dword ptr [EBP-0148h]
	call	 UnitTesting_Triangle_put_High

;{1370}:tri.ComputeArea();
	lea	ECX,dword ptr [EBP-0148h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]

;{1372}:Console::WriteLn("tri.Base = ", tri.Base, ", tri.High = ", tri.High, ", area = ", tri.ComputeArea());
	lea	EAX,OFFSET $S001297
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-0148h]
	call	 UnitTesting_Triangle_get_Base
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001298
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	lea	ECX,dword ptr [EBP-0148h]
	call	 UnitTesting_Triangle_get_High
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001293
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	lea	ECX,dword ptr [EBP-0148h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1376}:Console::WriteLn("I'm tired of waiting!!!");
	lea	EAX,OFFSET $S001300
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{1377}:cant;
	lea	ECX,dword ptr [EBP-014Ch]
	call	 UnitTesting_TestVirtuals_SimpleRV

;{1379}:Console::WriteLn("My Name is: ", cant.Name());
	lea	EAX,OFFSET $S001302
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-014Ch]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0004h]
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1381}:if(false == bUnattended)
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-0008h]
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L001677

;{1382}:hello.ShowHello("H++ Unit Testing : Third Phase");
	lea	EAX,OFFSET $S001303
	push	EAX
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_HelloWorld_ShowHello
$L001677:

;{1384}:xtarget, ;
	lea	ECX,dword ptr [EBP-017Ch]
	call	 UnitTesting_TestIntegers

;{1385}:ysource;
	lea	ECX,dword ptr [EBP-01ACh]
	call	 UnitTesting_TestIntegers

;{1387}:ysource.Width= 0x666;
	mov	EAX,000000666h
	push	EAX
	lea	ECX,dword ptr [EBP-01ACh]
	call	 UnitTesting_TestIntegers_put_Width

;{1388}:ysource.Height= 0x777;
	mov	EAX,000000777h
	push	EAX
	lea	ECX,dword ptr [EBP-01ACh]
	call	 UnitTesting_TestIntegers_put_Height

;{1390}:Console::WriteLn("ysource.Width = ", ysource.Width, ", ysource.Height = ", ysource.Height);
	lea	EAX,OFFSET $S001308
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-01ACh]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001309
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	lea	ECX,dword ptr [EBP-01ACh]
	call	 UnitTesting_TestIntegers_get_Height
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;try
	push	ESP ;pPrevESP
	push	EBP ;pPrevEBP
	push	OFFSET __except_handlerXXX001680 
	assume FS:nothing
	push	dword ptr  FS:[0] 
	mov	dword ptr  FS:[0],ESP
	int	000000003h ;User breakpoint

;{1395}:Console::WriteLn("This line will never be executed!");
	lea	EAX,OFFSET $S001310
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001679
__except_handlerXXX001680:
	mov	EBX,dword ptr [ESP+0004h] ;_ExceptionRecord
	mov	ECX,dword ptr [EBX] ;_ExceptionRecord->ExceptionCode // The reason the exception occurred.
	mov	EBX,dword ptr  FS:[0] 
	mov	ESP,dword ptr [EBX] 
	pop	dword ptr  FS:[0]
	mov	EBP,dword ptr [ESP+0004h] ;the prev EBP
	mov	ESP,dword ptr [ESP+0008h] ;the prev ESP

;{1395}:(System::Exception::BREAKPOINT);
	mov	EAX,080000003h
	cmp	EAX,ECX
	jnz	OFFSET $L001683

;{1399}:Console::WriteLn("**A breakpoint was catched!**");
	lea	EAX,OFFSET $S001311
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001682 
$L001683:
	jmp	OFFSET $L001682 
$L001679:
	mov	ESP,dword ptr  FS:[0] 
	pop	dword ptr  FS:[0] 
	mov	EBP,dword ptr [ESP+0004h] ;the prev EBP
	mov	ESP,dword ptr [ESP+0008h] ;the prev ESP
$L001682:

;{1403}:xtarget= ysource;
	lea	ECX,dword ptr [EBP-01ACh]
	mov	ESI,ECX
	lea	EBX,dword ptr [EBP-017Ch]
	mov	EDI,EBX 
	mov	ECX,000000030h 
	cld	
	rep movsb	

;{1405}:Console::WriteLn("(copied)xtarget.Width = ", xtarget.Width, ", (copied)xtarget.Height = ", xtarget.Height);
	lea	EAX,OFFSET $S001312
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-017Ch]
	call	 UnitTesting_TestIntegers_get_Width
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001313
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	lea	ECX,dword ptr [EBP-017Ch]
	call	 UnitTesting_TestIntegers_get_Height
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1407}:val1= 5, val2= 3;
	mov	EAX,000000005h
	mov	dword ptr [EBP-0070h],EAX
	mov	EAX,000000003h
	mov	dword ptr [EBP-0074h],EAX

;{1409}:UnitTesting::Integers_Inline::Test(void;
	call	 UnitTesting_Integers_Inline_Test

;{1411}:Console::WriteLn("SummationSeries::ComputeRenderGamma() series: ");
	lea	EAX,OFFSET $S001314
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{1412}:UnitTesting::SummationSeries::ComputeRenderGamma(void;
	call	 UnitTesting_SummationSeries_ComputeRenderGamma

;{1414}:Console::WriteLn("Degrees to Radians of ", 90, " is = ", Math::DegreesToRadians(90.0), " Radians.");
	lea	EAX,OFFSET $S001315
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,00000005Ah
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001317
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	xor	EDX,EDX
	mov	EAX,040568000h
	push	EAX
	push	EDX 
	call	 Math_DegreesToRadians
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001319
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1415}:Console::WriteLn("Radians to Degrees of ", 1.57079, " is = ", Math::RadiansToDegrees(1.57079), " Degrees.");
	lea	EAX,OFFSET $S001320
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,0B1EE2436h
	mov	EAX,03FF921F4h 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001317
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EDX,0B1EE2436h
	mov	EAX,03FF921F4h 
	push	EAX
	push	EDX 
	call	 Math_RadiansToDegrees
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001322
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 

;{1418}:p= new double;
	push	000000008h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001684
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000002h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001685
$L001684:
	xor	ESI,ESI
$L001685:
	mov	dword ptr [EBP-01B0h],ESI 

;{1421}:*p= 3.141516927;
	mov	EAX,dword ptr [EBP-432]
	push	EAX
	mov	EDX,0A06A5D05h
	mov	EAX,0400921D3h 
	pop	EBX
	mov	dword ptr [EBX],EDX
	mov	dword ptr [EBX+4],EAX 

;{1423}:Console::WriteLn("*p (3.1415...)= ", *p);
	lea	EAX,OFFSET $S001325
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-432]
	mov	EDX,dword ptr [EAX]
	mov	EAX,dword ptr [EAX+4] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1425}:res= *p;
	mov	EAX,dword ptr [EBP-432]
	mov	EDX,dword ptr [EAX]
	mov	EAX,dword ptr [EAX+4] 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-00DCh]

;{1427}:Console::WriteLn("res (3.1415...)= ", res);
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001326
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-00DCh]
	mov	EAX,dword ptr [EBP-00D8h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1429}:destroy p;
	mov	EAX,dword ptr [EBP-432]
	test	EAX,EAX
	jz	OFFSET $L001686
	push	EAX
	call	 System_Memory_Destroy
$L001686:

;{1439}:fpTester_ptr= new UnitTesting::TestFloatingPoint();
	push	000000001h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001687
	mov	ESI,EAX
	jmp	 $L001688
$L001687:
	xor	ESI,ESI
$L001688:
	mov	dword ptr [EBP-01B4h],ESI 
	mov	ECX,ESI
	call	 UnitTesting_TestFloatingPoint
	mov	EAX,ESI 

;{1441}:_pow= fpTester_ptr.Power(2.0, 64);
	mov	EAX,000000040h
	push	EAX 
	xor	EDX,EDX
	mov	EAX,040000000h
	push	EAX
	push	EDX 
	mov	ECX,dword ptr [EBP-436]
	call	 UnitTesting_TestFloatingPoint_Power
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-0080h]

;{1443}:destroy fpTester_ptr;
	pop	EDX
	pop	EAX 
	mov	ECX,dword ptr [EBP-436]
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001690
	call	 UnitTesting_TestFloatingPoint_Destructor
$L001690:
	push	ESI
	call	 System_Memory_Destroy

;{1446}:iptr= new int[10];
	mov	EAX,00000000Ah
	imul	EAX,000000004h
	push	EAX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001691
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI]
	mov	ECX,EBX 
	mov	EAX,0CDCDCDCDh 
	rep stos	byte ptr [EDI]
	jmp	 $L001692
$L001691:
	xor	ESI,ESI
$L001692:
	mov	dword ptr [EBP-01B8h],ESI 

;{1448}:iptr[0]= 145;
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	xor	EAX,EAX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,000000091h
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1449}:iptr[9]= 541;
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000009h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,00000021Dh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1450}:iptr[6]= 774;
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000006h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,000000306h
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1451}:iptr[7]= 991;
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000007h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,0000003DFh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1452}:iptr[2]= 123;
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000002h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,00000007Bh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1453}:iptr[1]= 667;
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000001h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,00000029Bh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1455}:Console::WriteLn("iptr[0] == 145 == ", iptr[0]);
	lea	EAX,OFFSET $S001336
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	xor	EAX,EAX
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1456}:Console::WriteLn("iptr[9] == 541 == ", iptr[9]);
	lea	EAX,OFFSET $S001337
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000009h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1457}:Console::WriteLn("iptr[7] == 991 == ", iptr[7]);
	lea	EAX,OFFSET $S001338
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000007h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1458}:Console::WriteLn("iptr[2] == 123 == ", iptr[2]);
	lea	EAX,OFFSET $S001339
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000002h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1459}:Console::WriteLn("iptr[1] == 667 == ", iptr[1]);
	lea	EAX,OFFSET $S001340
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000001h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1460}:Console::WriteLn("iptr[6] == 774 == ", iptr[6]);
	lea	EAX,OFFSET $S001341
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-440]
	push	EAX
	mov	EAX,000000006h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1462}:destroy iptr;
	mov	EAX,dword ptr [EBP-440]
	test	EAX,EAX
	jz	OFFSET $L001693
	push	EAX
	call	 System_Memory_Destroy
$L001693:

;{1464}:iptr= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-01B8h]
	mov	dword ptr [EBX],EAX

;{1466}:yes;
	lea	EAX,dword ptr [EBP-0348h]

;{1467}:yes[0][0]= 145;
	xor	EAX,EAX
	imul	EAX,EAX,000000028h
	lea	EDX,dword ptr [EBP+EAX-0348h]
	push	EDX
	xor	EAX,EAX
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,000000091h
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1468}:yes[1][9]= 541;
	mov	EAX,000000001h
	imul	EAX,EAX,000000028h
	lea	EDX,dword ptr [EBP+EAX-0348h]
	push	EDX
	mov	EAX,000000009h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,00000021Dh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1469}:yes[2][7]= 334;
	mov	EAX,000000002h
	imul	EAX,EAX,000000028h
	lea	EDX,dword ptr [EBP+EAX-0348h]
	push	EDX
	mov	EAX,000000007h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,00000014Eh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1470}:yes[3][9]= 123;
	mov	EAX,000000003h
	imul	EAX,EAX,000000028h
	lea	EDX,dword ptr [EBP+EAX-0348h]
	push	EDX
	mov	EAX,000000009h
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,00000007Bh
	pop	EBX
	mov	dword ptr [EBX],EAX

;{1472}:Console::WriteLn("yes[0][0] == 145 == ", yes[0][0]);
	lea	EAX,OFFSET $S001344
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	xor	EAX,EAX
	imul	EAX,EAX,000000028h
	lea	EDX,dword ptr [EBP+EAX-0348h]
	push	EDX
	xor	EAX,EAX
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1473}:Console::WriteLn("yes[1][9] == 541 == ", yes[1][9]);
	lea	EAX,OFFSET $S001345
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000001h
	imul	EAX,EAX,000000028h
	lea	EDX,dword ptr [EBP+EAX-0348h]
	push	EDX
	mov	EAX,000000009h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1474}:Console::WriteLn("yes[2][7] == 334 == ", yes[2][7]);
	lea	EAX,OFFSET $S001346
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000002h
	imul	EAX,EAX,000000028h
	lea	EDX,dword ptr [EBP+EAX-0348h]
	push	EDX
	mov	EAX,000000007h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1475}:Console::WriteLn("yes[3][9] == 123 == ", yes[3][9]);
	lea	EAX,OFFSET $S001347
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000003h
	imul	EAX,EAX,000000028h
	lea	EDX,dword ptr [EBP+EAX-0348h]
	push	EDX
	mov	EAX,000000009h
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX 
	call	 Console_WriteInteger 
	call	 Console_WriteCrLf 

;{1477}:numbers;
	lea	EAX,dword ptr [EBP-0398h]

;{1481}:numbers[0]= Math::pi();
	xor	EAX,EAX
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1482}:numbers[1]= Math::pi() * 2.1;
	mov	EAX,000000001h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,0CCCCCCCDh
	mov	EAX,04000CCCCh 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1483}:numbers[2]= Math::pi() * 4.1;
	mov	EAX,000000002h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,066666667h
	mov	EAX,040106666h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1484}:numbers[3]= Math::pi() * 8.1;
	mov	EAX,000000003h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,033333333h
	mov	EAX,040203333h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1485}:numbers[4]= Math::pi() * 16.1;
	mov	EAX,000000004h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,09999999Ah
	mov	EAX,040301999h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1486}:numbers[5]= Math::pi() * 32.1;
	mov	EAX,000000005h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,0CCCCCCCDh
	mov	EAX,040400CCCh 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1487}:numbers[6]= Math::pi() * 64.1;
	mov	EAX,000000006h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,066666667h
	mov	EAX,040500666h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1488}:numbers[7]= Math::pi() * 128.1;
	mov	EAX,000000007h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,033333333h
	mov	EAX,040600333h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1489}:numbers[8]= Math::pi() * 256.1;
	mov	EAX,000000008h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,09999999Ah
	mov	EAX,040700199h 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1490}:numbers[9]= Math::pi() * 512.1;
	mov	EAX,000000009h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-0398h]
	push	EAX
	call	 Math_pi
	push	EAX
	push	EDX 
	mov	EDX,0CCCCCCCDh
	mov	EAX,0408000CCh 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1492}:sz= sizeof (numbers) / sizeof (double);
	mov	EAX,000000050h
	push	EAX
	mov	EAX,000000008h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 FloatingPoint_ToInt
	mov	dword ptr [EBP-039Ch],EAX

;{1494}:for(index= 0; index < sz; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0058h],EAX
	jmp	OFFSET $L001694
$L001695:
	mov	EAX,dword ptr [EBP-88]
	inc	dword ptr [EBP-88]
$L001694:
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,dword ptr [EBP-039Ch]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001696
;{

;{1496}:Console::WriteLn("numbers[", index, "] = ", numbers[index]);
	lea	EAX,OFFSET $S001356
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001165
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0058h]
	imul	EAX,EAX,000000008h
	mov	EDX,dword ptr [EBP+EAX-0398h]
	add	EAX,000000004h ;low part
	mov	EAX,dword ptr [EBP+EAX-0398h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L001695 
$L001696:

;{1500}:objs;
	lea	EAX,dword ptr [EBP-03C0h]
	mov	ESI,EAX
	mov	EBX,ESI
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch 
	mov	ECX,EBX 
	call	 UnitTesting_Circle

;{1502}:objs[1].Radius= Math::pi();
	mov	EAX,000000001h
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-03C0h]
	push	ECX
	call	 Math_pi
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	ECX
	push	EAX
	push	EDX 
	call	 UnitTesting_Circle_put_Radius

;{1504}:objs[1].Draw();
	mov	EAX,000000001h
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-03C0h]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{1506}:Console::WriteLn("Circle[1].Radius = 3.14 = ", objs[1].Radius);
	lea	EAX,OFFSET $S001358
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000001h
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-03C0h]
	call	 UnitTesting_Circle_get_Radius
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1508}:objs[2]= objs[1];
	mov	EAX,000000002h
	imul	EAX,EAX,00000000Ch
	lea	EAX,dword ptr [EBP+EAX-03C0h]
	push	EAX
	mov	EAX,000000001h
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-03C0h]
	mov	EAX,dword ptr [EBP+EAX-03C0h]
	mov	ESI,ECX
	pop	EDI
	mov	ECX,00000000Ch 
	cld	
	rep movsb	

;{1510}:Console::WriteLn("Circle[2].Radius = 3.14 = ", objs[2].Radius);
	lea	EAX,OFFSET $S001359
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,000000002h
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-03C0h]
	call	 UnitTesting_Circle_get_Radius
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1512}:dest;
	lea	ECX,dword ptr [EBP-03CCh]
	call	 UnitTesting_Circle

;{1514}:dest= objs[1];
	mov	EAX,000000001h
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-03C0h]
	mov	EAX,dword ptr [EBP+EAX-03C0h]
	mov	ESI,ECX
	lea	EBX,dword ptr [EBP-03CCh]
	mov	EDI,EBX 
	mov	ECX,00000000Ch 
	cld	
	rep movsb	

;{1516}:Console::WriteLn("Circle.Radius = 3.14 = ", dest.Radius);
	lea	EAX,OFFSET $S001361
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	lea	ECX,dword ptr [EBP-03CCh]
	call	 UnitTesting_Circle_get_Radius
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1518}:objs[0]= dest;
	xor	EAX,EAX
	imul	EAX,EAX,00000000Ch
	lea	EAX,dword ptr [EBP+EAX-03C0h]
	push	EAX
	lea	ECX,dword ptr [EBP-03CCh]
	mov	ESI,ECX
	pop	EDI
	mov	ECX,00000000Ch 
	cld	
	rep movsb	

;{1520}:Console::WriteLn("Circle[0].Radius = 3.14 = ", objs[0].Radius);
	lea	EAX,OFFSET $S001362
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	xor	EAX,EAX
	imul	EAX,EAX,00000000Ch
	lea	ECX,dword ptr [EBP+EAX-03C0h]
	call	 UnitTesting_Circle_get_Radius
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 

;{1522}:xptr= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-03D0h]
	mov	dword ptr [EBX],EAX

;{1524}:xptr= new int;
	push	000000004h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001697
	mov	ESI,EAX
	lea	EDI,dword ptr [ESI]
	mov	ECX,000000001h 
	mov	EAX,0CDCDCDCDh 
	rep stos	dword ptr [EDI]
	jmp	 $L001698
$L001697:
	xor	ESI,ESI
$L001698:
	mov	dword ptr [EBP-03D0h],ESI 

;{1526}:if(false == bUnattended)
	xor	EAX,EAX
	push	EAX
	movzx	EAX,byte ptr [EBP-0008h]
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L001699

;{1527}:hello.ShowHello("H++ Unit Testing : Fourth Phase");
	lea	EAX,OFFSET $S001364
	push	EAX
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_HelloWorld_ShowHello
$L001699:

;{1531}:npi= sizeof (UnitTesting::misc1::pi);
	mov	EAX,000000008h
	mov	dword ptr [EBP-03D4h],EAX

;{1533}:npi= sizeof UnitTesting::misc1::pi;
	mov	EAX,000000008h
	mov	dword ptr [EBP-03D4h],EAX

;{1535}:nint= sizeof (int), ndbl= sizeof (double), ni64= sizeof Int64, ntit= sizeof (UnitTesting::TestIntegers), nptr= sizeof (p), narr= sizeof (iptr), nar2= sizeof (array1), nar3= sizeof (UnitTesting::misc1::array);
	mov	EAX,000000004h
	mov	dword ptr [EBP-03D8h],EAX
	mov	EAX,000000008h
	mov	dword ptr [EBP-03DCh],EAX
	mov	EAX,000000008h
	mov	dword ptr [EBP-03E0h],EAX
	mov	EAX,000000030h
	mov	dword ptr [EBP-03E4h],EAX
	mov	EAX,000000004h
	mov	dword ptr [EBP-03E8h],EAX
	mov	EAX,000000004h
	mov	dword ptr [EBP-03ECh],EAX
	mov	EAX,000000050h
	mov	dword ptr [EBP-03F0h],EAX
	mov	EAX,SIZEOF UnitTesting_misc1_array
	mov	dword ptr [EBP-03F4h],EAX

;{1544}:nint= sizeof int + sizeof double;
	mov	EAX,000000004h
	push	EAX
	mov	EAX,000000008h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-03D8h],EAX

;{1546}:nint= sizeof (int) + sizeof (Int64);
	mov	EAX,000000004h
	push	EAX
	mov	EAX,000000008h
	pop	EDX
	add	EAX,EDX
	mov	dword ptr [EBP-03D8h],EAX

;{1548}:if(nint >= ndbl && ni64 < ntit)
	mov	EAX,dword ptr [EBP-03D8h]
	push	EAX
	mov	EAX,dword ptr [EBP-03DCh]
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L001703
	mov	EAX,dword ptr [EBP-03E0h]
	push	EAX
	mov	EAX,dword ptr [EBP-03E4h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
$L001703:
	test	AL,AL
	jz	OFFSET $L001701
;{

;{1550}:Console::WriteLn("This is getting complex and better each time!");
	lea	EAX,OFFSET $S001374
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001701:

;{1553}:destroy xptr;
	mov	EAX,dword ptr [EBP-976]
	test	EAX,EAX
	jz	OFFSET $L001704
	push	EAX
	call	 System_Memory_Destroy
$L001704:

;{1555}:ii2ptr= null;
	xor	EAX,EAX
	lea	EBX,dword ptr [EBP-03F8h]
	mov	dword ptr [EBX],EAX

;{1557}:xptr= xptr + 1;
	mov	EAX,dword ptr [EBP-976]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	lea	EBX,dword ptr [EBP-03D0h]
	mov	dword ptr [EBX],EAX

;{1560}:name1= "Harold", name2= "Harold L.", name3= "Harold L. Marzan", name4= name1;
	lea	EAX,OFFSET $S001377
	mov	dword ptr [EBP-03FCh],EAX
	lea	EAX,OFFSET $S001379
	mov	dword ptr [EBP-0400h],EAX
	lea	EAX,OFFSET $S001167
	mov	dword ptr [EBP-0404h],EAX
	mov	EAX,dword ptr [EBP-03FCh]
	mov	dword ptr [EBP-0408h],EAX

;{1565}:if(name1 <= name2)
	mov	EAX,dword ptr [EBP-03FCh]
	push	EAX
	mov	EAX,dword ptr [EBP-0400h]
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setle	AL
	test	AL,AL
	jz	OFFSET $L001705
;{

;{1567}:Console::WriteLn("name1 =< name2");
	lea	EAX,OFFSET $S001382
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001705:

;{1569}:if(StringHandling::StringLength(name3) > StringHandling::StringLength(name2))
	mov	EAX,dword ptr [EBP-0404h]
	push	EAX
	call	 StringHandling_StringLength
	push	EAX
	mov	EAX,dword ptr [EBP-0400h]
	push	EAX
	call	 StringHandling_StringLength
	pop	EDX
	cmp	EDX,EAX
	setg	AL
	test	AL,AL
	jz	OFFSET $L001707
;{

;{1571}:Console::WriteLn("name3.length > name2.length");
	lea	EAX,OFFSET $S001383
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001707:

;{1574}:if(name2 <= name3)
	mov	EAX,dword ptr [EBP-0400h]
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setle	AL
	test	AL,AL
	jz	OFFSET $L001709
;{

;{1576}:Console::WriteLn("name2 <= name3");
	lea	EAX,OFFSET $S001384
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001709:

;{1580}:if(!(name3 < name2))
	mov	EAX,dword ptr [EBP-0404h]
	push	EAX
	mov	EAX,dword ptr [EBP-0400h]
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setl	AL
	neg	EAX
	not	EAX
	test	AL,AL
	jz	OFFSET $L001711
;{

;{1582}:Console::WriteLn("!(name3 < name2)");
	lea	EAX,OFFSET $S001385
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001711:

;{1585}:if(false == !(name2 < name3))
	xor	EAX,EAX
	push	EAX
	mov	EAX,dword ptr [EBP-0400h]
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setl	AL
	neg	EAX
	not	EAX
	pop	EDX
	cmp	DL,AL
	setz	AL
	test	AL,AL
	jz	OFFSET $L001713
;{

;{1587}:Console::WriteLn("false==!(name2 < name3)");
	lea	EAX,OFFSET $S001386
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001713:

;{1590}:if(name1 == name4)
	mov	EAX,dword ptr [EBP-03FCh]
	push	EAX
	mov	EAX,dword ptr [EBP-0408h]
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setz	AL
	test	AL,AL
	jz	OFFSET $L001715
;{

;{1592}:Console::WriteLn("It's working as designed!");
	lea	EAX,OFFSET $S001387
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001715:

;{1595}:if(name1 == name3)
	mov	EAX,dword ptr [EBP-03FCh]
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setz	AL
	test	AL,AL
	jz	OFFSET $L001717
;{

;{1597}:Console::WriteLn("I should never get here!");
	lea	EAX,OFFSET $S001388
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001717:

;{1600}:if(name1 != name3)
	mov	EAX,dword ptr [EBP-03FCh]
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDI
	mov	ESI,EAX
	push	EAX
	call	 StringHandling_StringLength
	push	EAX 
	push	ESI 
	push	EDI 
	call	 StringHandling_StringCompare 
	cmp	EAX,000000000h
	setnz	AL
	test	AL,AL
	jz	OFFSET $L001719
;{

;{1602}:Console::WriteLn("Yes (name1 != name3)!");
	lea	EAX,OFFSET $S001389
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 
;}
$L001719:

;{1606}:UnitTesting::TestIntegers::bigValue*= 4;
	mov	EAX,000000004h
	cdq	
	lea	EBX,OFFSET UnitTesting_TestIntegers_bigValue
	push	EDX
	push	EAX 
	fild	qword ptr [ESP]
	fild	qword ptr [EBX]
	fmul	st,st(1)
	fistp	qword ptr [ESP]
	pop	EAX
	pop	EDX 
	mov	dword ptr [EBX+4],EDX
	mov	dword ptr [EBX],EAX 

;{1609}:UnitTesting::TestIntegers::bigValue/= 4;
	mov	EAX,000000004h
	cdq	
	lea	EBX,OFFSET UnitTesting_TestIntegers_bigValue
	push	EDX
	push	EAX 
	fild	qword ptr [ESP]
	fild	qword ptr [EBX]
	fdiv	st,st(1)
	frndint
	fistp	qword ptr [ESP]
	pop	EAX
	pop	EDX 
	mov	dword ptr [EBX+4],EDX
	mov	dword ptr [EBX],EAX 

;{1612}:UnitTesting::TestIntegers::bigValue+= 1024;
	mov	EAX,000000400h
	clc	
	cdq	
	lea	EBX,OFFSET UnitTesting_TestIntegers_bigValue
	add	dword ptr [EBX],EAX
	adc	dword ptr [EBX+4],EDX

;{1615}:UnitTesting::TestIntegers::bigValue-= 1024;
	mov	EAX,000000400h
	clc	
	cdq	
	lea	EBX,OFFSET UnitTesting_TestIntegers_bigValue
	sub	dword ptr [EBX],EAX
	sbb	dword ptr [EBX+4],EDX

;{1618}:obj_ptr= UnitTesting::ShapeFactoryCreator::Create("Circle");
	lea	EAX,OFFSET $S000670
	push	EAX
	call	 UnitTesting_ShapeFactoryCreator_Create
	lea	EBX,dword ptr [EBP-040Ch]
	mov	dword ptr [EBX],EAX

;{1620}:obj_ptr.Draw();
	mov	ECX,dword ptr [EBP-1036]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+000Ch]

;{1622}:visitor;

;{1623}:visitor.Visit(obj_ptr);
	mov	EAX,dword ptr [EBP-1036]
	push	EAX
	lea	ECX,dword ptr [EBP-0410h]
	call	 UnitTesting_Visitor_Visit

;{1625}:circl= dynamic_cast(obj_ptr);
	mov	EAX,dword ptr [EBP-1036]
	lea	EBX,dword ptr [EBP-0414h]
	mov	dword ptr [EBX],EAX

;{1627}:circl= dynamic_cast(UnitTesting::Circle, obj_ptr);
	mov	EAX,dword ptr [EBP-1036]
	lea	EBX,dword ptr [EBP-0414h]
	mov	dword ptr [EBX],EAX

;{1632}:circl.DrawSphere();
	mov	ECX,dword ptr [EBP-1044]
	mov	EDX,dword ptr [ECX]
	call	dword ptr [EDX+0014h]

;{1634}:destroy dynamic_cast(UnitTesting::Circle, obj_ptr);
	mov	ECX,dword ptr [EBP-1036]
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001722
	mov	EAX,dword ptr [ECX] 
	call	dword ptr [EAX+0010h]
$L001722:
	push	ESI
	call	 System_Memory_Destroy

;{1638}:obj_ptr= UnitTesting::ShapeFactoryCreator::Create("Square");
	lea	EAX,OFFSET $S000696
	push	EAX
	call	 UnitTesting_ShapeFactoryCreator_Create
	lea	EBX,dword ptr [EBP-040Ch]
	mov	dword ptr [EBX],EAX

;{1639}:visitor.Visit(obj_ptr);
	mov	EAX,dword ptr [EBP-1036]
	push	EAX
	lea	ECX,dword ptr [EBP-0410h]
	call	 UnitTesting_Visitor_Visit

;{1641}:destroy obj_ptr;
	mov	ECX,dword ptr [EBP-1036]
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001724
	mov	EAX,dword ptr [ECX] 
	call	dword ptr [EAX+0010h]
$L001724:
	push	ESI
	call	 System_Memory_Destroy

;{1643}:obj_ptr= UnitTesting::ShapeFactoryCreator::Create("Triangle");
	lea	EAX,OFFSET $S000716
	push	EAX
	call	 UnitTesting_ShapeFactoryCreator_Create
	lea	EBX,dword ptr [EBP-040Ch]
	mov	dword ptr [EBX],EAX

;{1644}:visitor.Visit(obj_ptr);
	mov	EAX,dword ptr [EBP-1036]
	push	EAX
	lea	ECX,dword ptr [EBP-0410h]
	call	 UnitTesting_Visitor_Visit

;{1646}:destroy obj_ptr;
	mov	ECX,dword ptr [EBP-1036]
	mov	ESI,ECX
	test	ECX,ECX
	jz	OFFSET $L001726
	mov	EAX,dword ptr [ECX] 
	call	dword ptr [EAX+0010h]
$L001726:
	push	ESI
	call	 System_Memory_Destroy

;{1649}:testProp;
	lea	ECX,dword ptr [EBP-0460h]
	call	 UnitTesting_TestProperties

;{1651}:shapes= new UnitTesting::Circle[20];
	mov	EAX,000000014h
	imul	EAX,00000000Ch
	lea	EBX,dword ptr [EAX+4]
	push	EBX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001727
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI]
	mov	ECX,EBX 
	mov	EAX,0CDCDCDCDh 
	rep stos	byte ptr [EDI]
	mov	dword ptr [ESI],EBX 
	add	ESI,000000004h
	jmp	 $L001728
$L001727:
	xor	ESI,ESI
$L001728:
	mov	dword ptr [EBP-0464h],ESI 
	mov	ECX,dword ptr [ESI-0004h] 
	lea	EDI,dword ptr [ESI+ECX] 
	mov	EBX,ESI 
$L001729:
	mov	ECX,EBX 
	call	 UnitTesting_Circle
	add	EBX,00000000Ch 
	cmp	EBX,EDI
	jnz	OFFSET $L001729
	mov	EAX,ESI 

;{1652}:testProp.Shapes= shapes;
	mov	EAX,dword ptr [EBP-1124]
	push	EAX
	lea	ECX,dword ptr [EBP-0460h]
	call	 UnitTesting_TestProperties_put_Shapes

;{1654}:sorter;

;{1655}:n= 10;
	mov	EAX,00000000Ah
	mov	dword ptr [EBP-0054h],EAX

;{1656}:array= new UnitTesting::DoubleProxy[n];
	mov	EAX,dword ptr [EBP-0054h]
	imul	EAX,00000000Ch
	lea	EBX,dword ptr [EAX+4]
	push	EBX
	mov	EBX,EAX
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L001730
	mov	ESI,EAX 
	lea	EDI,dword ptr [ESI]
	mov	ECX,EBX 
	mov	EAX,0CDCDCDCDh 
	rep stos	byte ptr [EDI]
	mov	dword ptr [ESI],EBX 
	add	ESI,000000004h
	jmp	 $L001731
$L001730:
	xor	ESI,ESI
$L001731:
	mov	dword ptr [EBP-046Ch],ESI 
	mov	ECX,dword ptr [ESI-0004h] 
	lea	EDI,dword ptr [ESI+ECX] 
	mov	EBX,ESI 
$L001732:
	mov	ECX,EBX 
	call	 UnitTesting_DoubleProxy
	add	EBX,00000000Ch 
	cmp	EBX,EDI
	jnz	OFFSET $L001732
	mov	EAX,ESI 

;{1658}:array[0].val= 19.2;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	xor	EAX,EAX
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,033333334h
	mov	EAX,040333333h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1659}:array[1].val= 3.2345;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000001h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,089374BC7h
	mov	EAX,04009E041h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1660}:array[2].val= 6.3456;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000002h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,0F765FD8Bh
	mov	EAX,0401961E4h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1661}:array[3].val= 11.5676;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000003h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,0779A6B51h
	mov	EAX,04027229Ch 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1662}:array[4].val= 7.2345;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000004h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,0C49BA5E4h
	mov	EAX,0401CF020h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1663}:array[5].val= 12.4567;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000005h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,095182A9Ah
	mov	EAX,04028E9D4h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1664}:array[6].val= 9.2345;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000006h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,0624DD2F2h
	mov	EAX,040227810h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1665}:array[7].val= 15.123;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000007h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,0DB22D0E6h
	mov	EAX,0402E3EF9h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1666}:array[8].val= 1.2;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000008h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,033333334h
	mov	EAX,03FF33333h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1667}:array[9].val= 18.1234;
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000009h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	lea	EAX,dword ptr [ECX+0004h]
	push	EAX
	mov	EDX,02474538Fh
	mov	EAX,040321F97h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1669}:for(index= 0; index < n; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0058h],EAX
	jmp	OFFSET $L001733
$L001734:
	mov	EAX,dword ptr [EBP-88]
	inc	dword ptr [EBP-88]
$L001733:
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,dword ptr [EBP-0054h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001735

;{1670}:Console::WriteLn("array[", index, "]= ", array[index].val);
	lea	EAX,OFFSET $S001408
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001201
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,dword ptr [EBP-0058h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001734 
$L001735:

;{1672}:sorter.PrintObject(array[9]);
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000009h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	lea	ECX,dword ptr [EBP-0468h]
	call	 UnitTesting_SortDoubleProxy_PrintObject

;{1674}:swapper;
	lea	ECX,dword ptr [EBP-0470h]
	call	 UnitTesting_DoubleSwapper

;{1676}:sorter.Sort(array, n, swapper);
	lea	EAX,dword ptr [EBP-0470h]
	push	EAX
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX 
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	lea	ECX,dword ptr [EBP-0468h]
	call	 UnitTesting_SortDoubleProxy_Sort

;{1678}:sorter.SortEx(array, n, swapper);
	lea	EAX,dword ptr [EBP-0470h]
	push	EAX
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX 
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	lea	ECX,dword ptr [EBP-0468h]
	call	 UnitTesting_SortDoubleProxy_SortEx

;{1680}:Console::WriteLn("Now sorted:");
	lea	EAX,OFFSET $S001410
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{1682}:for(index= 0; index < n; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0058h],EAX
	jmp	OFFSET $L001736
$L001737:
	mov	EAX,dword ptr [EBP-88]
	inc	dword ptr [EBP-88]
$L001736:
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,dword ptr [EBP-0054h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001738

;{1683}:Console::WriteLn("array[", index, "]= ", array[index].val);
	lea	EAX,OFFSET $S001408
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001201
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,dword ptr [EBP-0058h]
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	mov	EAX,dword ptr [ECX+0008h]
	mov	EDX,dword ptr [ECX+0004h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001737 
$L001738:

;{1685}:sorter.PrintObject(array[9]);
	mov	EAX,dword ptr [EBP-1132]
	push	EAX
	mov	EAX,000000009h
	pop	ESI
	imul	EAX,00000000Ch
	lea	ECX,dword ptr [ESI+EAX]
	push	ECX
	lea	ECX,dword ptr [EBP-0468h]
	call	 UnitTesting_SortDoubleProxy_PrintObject

;{1687}:destroy []array;
	mov	EAX,dword ptr [EBP-1132]
	test	EAX,EAX
	jz	OFFSET $L001739
	mov	ESI,EAX
	mov	ECX,dword ptr [ESI-0004h]
	lea	EDI,dword ptr [ESI+ECX]
	mov	EBX,ESI 
$L001740:
	mov	ECX,EBX 
	test	ECX,ECX
	jz	OFFSET $L001741
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+000Ch]
$L001741:
	add	EBX,00000000Ch
	cmp	EBX,EDI
	jnz	OFFSET $L001740

	add	ESI,0FFFFFFFCh
	push	ESI
	call	 System_Memory_Destroy
$L001739:

;{1690}:arr;
	lea	EAX,dword ptr [EBP-04C0h]

;{1694}:arr[0]= 19.2;
	xor	EAX,EAX
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,033333334h
	mov	EAX,040333333h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1695}:arr[1]= 3.2345;
	mov	EAX,000000001h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,089374BC7h
	mov	EAX,04009E041h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1696}:arr[2]= 6.3456;
	mov	EAX,000000002h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,0F765FD8Bh
	mov	EAX,0401961E4h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1697}:arr[3]= 11.5676;
	mov	EAX,000000003h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,0779A6B51h
	mov	EAX,04027229Ch 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1698}:arr[4]= 7.2345;
	mov	EAX,000000004h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,0C49BA5E4h
	mov	EAX,0401CF020h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1699}:arr[5]= 12.4567;
	mov	EAX,000000005h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,095182A9Ah
	mov	EAX,04028E9D4h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1700}:arr[6]= 9.2345;
	mov	EAX,000000006h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,0624DD2F2h
	mov	EAX,040227810h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1701}:arr[7]= 15.123;
	mov	EAX,000000007h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,0DB22D0E6h
	mov	EAX,0402E3EF9h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1702}:arr[8]= 1.2;
	mov	EAX,000000008h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,033333334h
	mov	EAX,03FF33333h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1703}:arr[9]= 18.1234;
	mov	EAX,000000009h
	imul	EAX,EAX,000000008h
	lea	EAX,dword ptr [EBP+EAX-04C0h]
	push	EAX
	mov	EDX,02474538Fh
	mov	EAX,040321F97h 
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	pop	EBX
	fstp	qword ptr [EBX]

;{1705}:for(index= 0; index < nn; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0058h],EAX
	jmp	OFFSET $L001742
$L001743:
	mov	EAX,dword ptr [EBP-88]
	inc	dword ptr [EBP-88]
$L001742:
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001744

;{1706}:Console::WriteLn("array[", index, "]= ", arr[index]);
	lea	EAX,OFFSET $S001408
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001201
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0058h]
	imul	EAX,EAX,000000008h
	mov	EDX,dword ptr [EBP+EAX-04C0h]
	add	EAX,000000004h ;low part
	mov	EAX,dword ptr [EBP+EAX-04C0h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001743 
$L001744:

;{1708}:sorter.Sort2(arr, n);
	mov	EAX,dword ptr [EBP-0054h]
	push	EAX 
	lea	EAX,dword ptr [EBP-04C0h]
	push	EAX
	lea	ECX,dword ptr [EBP-0468h]
	call	 UnitTesting_SortDoubleProxy_Sort2

;{1710}:Console::WriteLn("Now sorted:");
	lea	EAX,OFFSET $S001410
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{1712}:for(index= 0; index < nn; index++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0058h],EAX
	jmp	OFFSET $L001745
$L001746:
	mov	EAX,dword ptr [EBP-88]
	inc	dword ptr [EBP-88]
$L001745:
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX
	mov	EAX,00000000Ah
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L001747

;{1713}:Console::WriteLn("array[", index, "]= ", arr[index]);
	lea	EAX,OFFSET $S001408
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EAX,dword ptr [EBP-0058h]
	push	EAX 
	call	 Console_WriteInteger 
	lea	EAX,OFFSET $S001201
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	mov	EAX,dword ptr [EBP-0058h]
	imul	EAX,EAX,000000008h
	mov	EDX,dword ptr [EBP+EAX-04C0h]
	add	EAX,000000004h ;low part
	mov	EAX,dword ptr [EBP+EAX-04C0h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	call	 Console_WriteCrLf 
	jmp	OFFSET $L001746 
$L001747:

;{1716}:Console::WriteLn("\nComputing the PI constant...\n");
	lea	EAX,OFFSET $S001413
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{1717}:PI= UnitTesting::MonteCarlo::PI(10000000);
	mov	EAX,000989680h
	push	EAX
	call	 UnitTesting_MonteCarlo_PI
	push	EAX
	push	EDX 
	ffree	st
	fld	qword ptr [ESP]
	fstp	qword ptr [EBP-04C8h]

;{1718}:Console::WriteLn("The PI value = ", PI, "\n\n");
	pop	EDX
	pop	EAX 
	lea	EAX,OFFSET $S001416
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	mov	EDX,dword ptr [EBP-04C8h]
	mov	EAX,dword ptr [EBP-04C4h] 
	push	EAX 
	push	EDX 
	call	 Console_WriteDouble 
	lea	EAX,OFFSET $S001417
	push	000000000h 
	push	EAX 
	call	 Console_WriteString 
	call	 Console_WriteCrLf 
;}
$L001196:
	lea	ECX,dword ptr [EBP-0460h]
	mov	EAX,dword ptr [ECX+0048h]
	call	dword ptr [EAX]
$L001750:
	lea	ECX,dword ptr [EBP-03CCh]
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001752:
	lea	ECX,dword ptr [EBP-0148h]
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001757:
	lea	ECX,dword ptr [EBP-0134h]
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001758:
	lea	ECX,dword ptr [EBP-0120h]
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001759:
	lea	ECX,dword ptr [EBP-010Ch]
	mov	EAX,dword ptr [ECX]
	call	dword ptr [EAX+0010h]
$L001760:
	lea	ECX,dword ptr [EBP-0078h]
	call	 UnitTesting_TestFloatingPoint_Destructor
$L001765:
	lea	ECX,dword ptr [EBP-000Ch]
	call	 UnitTesting_HelloWorld_Destructor
$L001767:

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	retn	000000008h
UnitTesting_Test1_TestRunner_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	lea	EBX,dword ptr ___argc
	push	EBX
	call	 System_GetCommandLineArgv 
	mov	dword ptr ___argv,EAX 
	push	EAX 
	mov	ECX,dword ptr ___argc 
	push	ECX 
	call	 UnitTesting_Test1_TestRunner_main ;user entry point (stdcall calling convention)
	push	EAX 
	mov	EAX,dword ptr ___argv 
	push	EAX 
	call	 System_Memory_GetProcessHeap 
	push	EAX 
	call	 System_Memory_Free 
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	leave	
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
@@class_vptr_vtbl@@__UnitTesting_Circle	DWORD	OFFSET UnitTesting_Circle_Type,
						OFFSET UnitTesting_Circle_ComputeArea,
						OFFSET UnitTesting_Circle_Name,
						OFFSET UnitTesting_Circle_Draw,
						OFFSET UnitTesting_Circle_Destructor,
						OFFSET UnitTesting_Circle_DrawSphere

@@class_vptr_vtbl@@__UnitTesting_Shape	DWORD	OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall

@@class_vptr_vtbl@@__UnitTesting_DoubleProxy	DWORD	OFFSET UnitTesting_DoubleProxy_lessThan,
						OFFSET UnitTesting_DoubleProxy_isEqual,
						OFFSET UnitTesting_DoubleProxy_Swap,
						OFFSET UnitTesting_DoubleProxy_Destructor

@@class_vptr_vtbl@@__UnitTesting_SimpleObject	DWORD	OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall,
						OFFSET UnitTesting_SimpleObject_Destructor

@@class_vptr_vtbl@@__UnitTesting_DoubleSwapper	DWORD	OFFSET UnitTesting_DoubleSwapper_lessThan,
						OFFSET UnitTesting_DoubleSwapper_Swap,
						OFFSET UnitTesting_DoubleSwapper_lessThanEx,
						OFFSET UnitTesting_DoubleSwapper_SwapEx

@@class_vptr_vtbl@@__UnitTesting_SwapperObject	DWORD	OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall,
						OFFSET __purecall

@@class_vptr_vtbl@@__UnitTesting_HObject	DWORD	OFFSET UnitTesting_HObject_Destructor

@@class_vptr_vtbl@@__UnitTesting_Objects_Array	DWORD	OFFSET UnitTesting_Objects_Array_Destructor,
						OFFSET __purecall,
						OFFSET __purecall

@@class_vptr_vtbl@@__UnitTesting_Objects_ArrayOfAutomobiles	DWORD	OFFSET UnitTesting_Objects_Array_Destructor,
						OFFSET UnitTesting_Objects_ArrayOfAutomobiles_getAt,
						OFFSET UnitTesting_Objects_ArrayOfAutomobiles_Swap

@@class_vptr_vtbl@@__UnitTesting_Objects_Automobile	DWORD	OFFSET UnitTesting_Objects_Automobile_Compare

@@class_vptr_vtbl@@__UnitTesting_Objects_ProxyObject	DWORD	OFFSET __purecall

@@class_vptr_vtbl@@__UnitTesting_Square	DWORD	OFFSET UnitTesting_Square_Type,
						OFFSET UnitTesting_Square_ComputeArea,
						OFFSET UnitTesting_Square_Name,
						OFFSET UnitTesting_Square_Draw,
						OFFSET UnitTesting_Square_Destructor

@@class_vptr_vtbl@@__UnitTesting_TestProperties	DWORD	OFFSET UnitTesting_TestProperties_Destructor

@@class_vptr_vtbl@@__UnitTesting_TestVirtuals_ExponentialRV	DWORD	OFFSET UnitTesting_TestVirtuals_ExponentialRV_Sample,
						OFFSET UnitTesting_TestVirtuals_ExponentialRV_Name

@@class_vptr_vtbl@@__UnitTesting_TestVirtuals_RandomVariable	DWORD	OFFSET __purecall,
						OFFSET UnitTesting_TestVirtuals_RandomVariable_Name

@@class_vptr_vtbl@@__UnitTesting_TestVirtuals_SimpleRV	DWORD	OFFSET UnitTesting_TestVirtuals_SimpleRV_Sample,
						OFFSET UnitTesting_TestVirtuals_SimpleRV_Name

@@class_vptr_vtbl@@__UnitTesting_TestVirtuals_UniformRV	DWORD	OFFSET UnitTesting_TestVirtuals_UniformRV_Sample,
						OFFSET UnitTesting_TestVirtuals_UniformRV_Name

@@class_vptr_vtbl@@__UnitTesting_Triangle	DWORD	OFFSET UnitTesting_Triangle_Type,
						OFFSET UnitTesting_Triangle_ComputeArea,
						OFFSET UnitTesting_Triangle_Name,
						OFFSET UnitTesting_Triangle_Draw,
						OFFSET UnitTesting_Triangle_Destructor,
						OFFSET UnitTesting_Triangle_DrawPiramid

File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh
UnitTesting_TestSwitch_open	=	000000001h
UnitTesting_TestSwitch_close	=	000000002h
UnitTesting_TestSwitch_write	=	000000003h
UnitTesting_TestSwitch_read	=	000000004h
UnitTesting_ten	=	00000000Ah
UnitTesting_minusten	=	0FFFFFFF6h
UnitTesting_hundred	=	000000064h
UnitTesting_max_length	=	000000050h
UnitTesting_max_64	QWORD	00000000002893052h
UnitTesting_max_64_neg	QWORD	0FFFFFFFFFD76CFAEh
UnitTesting_misc1_pi	REAL8	3.141593
UnitTesting_misc1_e	REAL4	2.211400
UnitTesting_misc1_ten_plus	=	00000000Ah
UnitTesting_misc1_ch1	=	'a'
UnitTesting_misc1_ch2	=	'z'
UnitTesting_misc1_hello	BYTE "hello, world.",0
UnitTesting_misc1_hell	BYTE "human",0
UnitTesting_misc1_boy	BYTE "mistakes",0
UnitTesting_misc1_dX	REAL8	4.990000
UnitTesting_misc1_dY	REAL8	9.456700

$S001224 		BYTE 	" = ",0
$S001322 		BYTE 	" Degrees.",0
$S001319 		BYTE 	" Radians.",0
$S001264 		BYTE 	" as its value.",0
$S001317 		BYTE 	" is = ",0
$S000982 		BYTE 	" j = (4 + (--j))%4 ==",0
$S001385 		BYTE 	"!(name3 < name2)",0
$S001082 		BYTE 	"(*) the result is: ",0
$S001072 		BYTE 	"(+) the result is: ",0
$S001077 		BYTE 	"(-) the result is: ",0
$S001148 		BYTE 	"(1)",0
$S001253 		BYTE 	"(1)A pseudo-random value: ",0
$S001263 		BYTE 	"(1)A simple random variable has : ",0
$S001275 		BYTE 	"(1)An exponential random variable has : ",0
$S001270 		BYTE 	"(1)An uniform random variable has : ",0
$S001150 		BYTE 	"(2)",0
$S001254 		BYTE 	"(2)A pseudo-random value: ",0
$S001265 		BYTE 	"(2)A simple random variable has : ",0
$S001276 		BYTE 	"(2)An exponential random variable has : ",0
$S001271 		BYTE 	"(2)An uniform random variable has : ",0
$S001151 		BYTE 	"(3)",0
$S001255 		BYTE 	"(3)A pseudo-random value: ",0
$S001266 		BYTE 	"(3)A simple random variable has : ",0
$S001277 		BYTE 	"(3)An exponential random variable has : ",0
$S001272 		BYTE 	"(3)An uniform random variable has : ",0
$S001256 		BYTE 	"(4)A pseudo-random value: ",0
$S001267 		BYTE 	"(4)A simple random variable has : ",0
$S001278 		BYTE 	"(4)An exponential random variable has : ",0
$S001273 		BYTE 	"(4)An uniform random variable has : ",0
$S001257 		BYTE 	"(5)A pseudo-random value: ",0
$S001258 		BYTE 	"(6)A pseudo-random value: ",0
$S001047 		BYTE 	"(a = l * w * 0.9) = ",0
$S001040 		BYTE 	"(a = l * w) =",0
$S001312 		BYTE 	"(copied)xtarget.Width = ",0
$S001087 		BYTE 	"(div) the result is: ",0
$S001231 		BYTE 	"(double)the area is: ",0
$S001230 		BYTE 	"(int)the area is: ",0
$S001092 		BYTE 	"(mod) the result is: ",0
$S000547 		BYTE 	"(none)",0
$S001097 		BYTE 	"(round(/)) the result is: ",0
$S001006 		BYTE 	"(what = (result==1024)) 	= ",0
$S001004 		BYTE 	"(what = (result==1365.0)) 	= ",0
$S001016 		BYTE 	"(what = (result==33335)) 	= ",0
$S001014 		BYTE 	"(what = (result==50000)) 	= ",0
$S001018 		BYTE 	"(what = disc==0.0) 		= ",0
$S001012 		BYTE 	"(what = result==0xC3500h) 	= ",0
$S001241 		BYTE 	"(what = val1 == 0x78000000) = ",0
$S000996 		BYTE 	"(what = x == 68) 		= ",0
$S001021 		BYTE 	"(what = x1==-2.0) 		= ",0
$S001023 		BYTE 	"(what = x2==-2.0) 		= ",0
$S000990 		BYTE 	"(what = x==0x10h)		= ",0
$S000998 		BYTE 	"(what = x==0x4000) 		= ",0
$S000992 		BYTE 	"(what = x==1)			= ",0
$S001000 		BYTE 	"(what = x==4096) 		= ",0
$S001002 		BYTE 	"(what = y==1365) 		= ",0
$S001247 		BYTE 	") = ",0
$S001311 		BYTE 	"**A breakpoint was catched!**",0
$S000914 		BYTE 	"**Before destroying all object in shapes1:",0
$S000915 		BYTE 	"**Before destroying all object in shapes2:",0
$S000740 		BYTE 	"**Visited object name = ",0
$S001325 		BYTE 	"*p (3.1415...)= ",0
$S001184 		BYTE 	", ",0
$S001313 		BYTE 	", (copied)xtarget.Height = ",0
$S000627 		BYTE 	", and b = ",0
$S001293 		BYTE 	", area = ",0
$S001292 		BYTE 	", sq.Height = ",0
$S001298 		BYTE 	", tri.High = ",0
$S001309 		BYTE 	", ysource.Height = ",0
$S001203 		BYTE 	"/Silent",0
$S000874 		BYTE 	"A double proxy = ",0
$S000552 		BYTE 	"A simple variable",0
$S000580 		BYTE 	"An exponential variable",0
$S000570 		BYTE 	"An uniform variable",0
$S001200 		BYTE 	"Argument: [",0
$S001183 		BYTE 	"Char at [",0
$S001141 		BYTE 	"Char at i:[",0
$S000670 		BYTE 	"Circle",0
$S001284 		BYTE 	"Circle.Area = ",0
$S001282 		BYTE 	"Circle.Radius = ",0
$S001361 		BYTE 	"Circle.Radius = 3.14 = ",0
$S001362 		BYTE 	"Circle[0].Radius = 3.14 = ",0
$S001358 		BYTE 	"Circle[1].Radius = 3.14 = ",0
$S001359 		BYTE 	"Circle[2].Radius = 3.14 = ",0
$S000640 		BYTE 	"Closing file...",0
$S000794 		BYTE 	"Constructing a Double Proxy...",0
$S001219 		BYTE 	"Current Index :",0
$S001315 		BYTE 	"Degrees to Radians of ",0
$S000806 		BYTE 	"Destroying a Double Proxy object...",0
$S000789 		BYTE 	"Destroying a Simple Object...",0
$S000645 		BYTE 	"Do 6, then finish",0
$S000642 		BYTE 	"Do Read from file...",0
$S000641 		BYTE 	"Do Write to file...",0
$S000643 		BYTE 	"Do for 5 and follow to 6",0
$S000672 		BYTE 	"Drawing a Circle!",0
$S000700 		BYTE 	"Drawing a Cube!",0
$S000723 		BYTE 	"Drawing a Piramid!",0
$S000677 		BYTE 	"Drawing a Sphere!",0
$S000698 		BYTE 	"Drawing a Square!",0
$S000718 		BYTE 	"Drawing a Triangle!",0
$S001223 		BYTE 	"Factorial of ",0
$S000616 		BYTE 	"Gamma y = ",0
$S000924 		BYTE 	"H++ First program",0
$S001364 		BYTE 	"H++ Unit Testing : Fourth Phase",0
$S001242 		BYTE 	"H++ Unit Testing : Second Phase",0
$S001303 		BYTE 	"H++ Unit Testing : Third Phase",0
$S001190 		BYTE 	"Harold ",0
$S001167 		BYTE 	"Harold L. Marzan",0
$S001379 		BYTE 	"Harold L.",0
$S001377 		BYTE 	"Harold",0
$S001208 		BYTE 	"Hello World from H++!!!",0
$S001388 		BYTE 	"I should never get here!",0
$S001300 		BYTE 	"I'm tired of waiting!!!",0
$S000646 		BYTE 	"Invalid Option : ",0
$S001387 		BYTE 	"It's working as designed!",0
$S001191 		BYTE 	"Lawrence ",0
$S001192 		BYTE 	"Marzan ",0
$S001193 		BYTE 	"Mercado.",0
$S001302 		BYTE 	"My Name is: ",0
$S001176 		BYTE 	"My name is :",0
$S001410 		BYTE 	"Now sorted:",0
$S001143 		BYTE 	"Oops! there was a serious bug in this code!",0
$S000639 		BYTE 	"Opening file...",0
$S000615 		BYTE 	"Partial results = ",0
$S001260 		BYTE 	"Pseudo-Random Double values:",0
$S001252 		BYTE 	"Pseudo-Random Integer values:",0
$S001320 		BYTE 	"Radians to Degrees of ",0
$S001250 		BYTE 	"Result for array1[",0
$S000696 		BYTE 	"Square",0
$S001314 		BYTE 	"SummationSeries::ComputeRenderGamma() series: ",0
$S001110 		BYTE 	"Swaping values...",0
$S001054 		BYTE 	"Ternary (false ) = ",0
$S001053 		BYTE 	"Ternary (true) = ",0
$S001188 		BYTE 	"Testing!!!",0
$S000918 		BYTE 	"The HelloWorld constructor",0
$S000926 		BYTE 	"The HelloWorld destructor",0
$S001416 		BYTE 	"The PI value = ",0
$S000629 		BYTE 	"The max value is = ",0
$S000631 		BYTE 	"The min value is = ",0
$S001228 		BYTE 	"The value of myRef1 must be 65536 ==",0
$S001229 		BYTE 	"The value of myVar1 is not 65536 but zero (0) == ",0
$S000626 		BYTE 	"The values: a = ",0
$S001374 		BYTE 	"This is getting complex and better each time!",0
$S001310 		BYTE 	"This line will never be executed!",0
$S000716 		BYTE 	"Triangle",0
$S001389 		BYTE 	"Yes (name1 != name3)!",0
$S001413 		BYTE 	0Ah,"Computing the PI constant...",0Ah,0
$S001417 		BYTE 	0Ah,0Ah,0
$S001165 		BYTE 	"] = ",0
$S001142 		BYTE 	"] == ",0
$S001201 		BYTE 	"]= ",0
$S001185 		BYTE 	"]=",0
$S001154 		BYTE 	"array2[3].my_array1[0] (double)== 9.99 == ",0
$S001155 		BYTE 	"array2[3].my_array1[1] (double)== 3.1415927 == ",0
$S001156 		BYTE 	"array2[3].my_array2[0] (int)== 10 == ",0
$S001157 		BYTE 	"array2[3].my_array2[1] (int)== 3 == ",0
$S001164 		BYTE 	"array4[",0
$S001408 		BYTE 	"array[",0
$S001117 		BYTE 	"constructing a TestFloatingPoint() object...",0
$S000675 		BYTE 	"destroying a Circle object...",0
$S000684 		BYTE 	"destroying a Square object...",0
$S001119 		BYTE 	"destroying a TestFloatingPoint() object...",0
$S000721 		BYTE 	"destroying a Triangle object...",0
$S001386 		BYTE 	"false==!(name2 < name3)",0
$S001336 		BYTE 	"iptr[0] == 145 == ",0
$S001340 		BYTE 	"iptr[1] == 667 == ",0
$S001339 		BYTE 	"iptr[2] == 123 == ",0
$S001341 		BYTE 	"iptr[6] == 774 == ",0
$S001338 		BYTE 	"iptr[7] == 991 == ",0
$S001337 		BYTE 	"iptr[9] == 541 == ",0
$S001038 		BYTE 	"l = ",0
$S001268 		BYTE 	"my name is",0
$S001214 		BYTE 	"nArea = ",0
$S001149 		BYTE 	"nArea = 100 * 200 == ",0
$S001382 		BYTE 	"name1 =< name2",0
$S001384 		BYTE 	"name2 <= name3",0
$S001383 		BYTE 	"name3.length > name2.length",0
$S001356 		BYTE 	"numbers[",0
$S001287 		BYTE 	"obj==obj2",0
$S001246 		BYTE 	"pow(2, ",0
$S001326 		BYTE 	"res (3.1415...)= ",0
$S001291 		BYTE 	"sq.Width = ",0
$S001028 		BYTE 	"the value is (3): ",0
$S001027 		BYTE 	"the value is (5): ",0
$S001025 		BYTE 	"the value of x is (1): ",0
$S001026 		BYTE 	"the value of x is (2): ",0
$S001024 		BYTE 	"the value of x is: ",0
$S000921 		BYTE 	"this is what I have to say for the first time in H++ :",0
$S001297 		BYTE 	"tri.Base = ",0
$S000734 		BYTE 	"type == stCircle",0
$S000736 		BYTE 	"type == stSquare",0
$S000738 		BYTE 	"type == stTriangle",0
$S001039 		BYTE 	"w = ",0
$S001237 		BYTE 	"what == True ?",0
$S001286 		BYTE 	"what must be true = ",0
$S001344 		BYTE 	"yes[0][0] == 145 == ",0
$S001345 		BYTE 	"yes[1][9] == 541 == ",0
$S001346 		BYTE 	"yes[2][7] == 334 == ",0
$S001347 		BYTE 	"yes[3][9] == 123 == ",0
$S001308 		BYTE 	"ysource.Width = ",0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000020h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count
UnitTesting_Rnd_seed	 DWORD	0
UnitTesting_Rnd_a	 DWORD	0
UnitTesting_Rnd_m	 DWORD	0
UnitTesting_Rnd_q	 DWORD	0
UnitTesting_Rnd_r	 DWORD	0
UnitTesting_misc1_array	 REAL8 00000000Ah DUP(?) 
UnitTesting_TestIntegers_bigValue	 DQ	0
UnitTesting_array3	 BYTE 000000004h DUP(?) 
UnitTesting_array4	 REAL8 000000004h DUP(?) 

END __System_Hpp_Runtime_Init

