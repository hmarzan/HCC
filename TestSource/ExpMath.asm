TITLE	 ExpMath.hpp
SUBTITLE This file was automatically generated by the 32-bit H++ Compiler


	.486P
	.MODEL flat,stdcall
	.STACK 000100000h
	INCLUDE stdhpp\hcclib32.INC	; the H++ library.

;Windows API prototypes
GetVersion PROTO

;This assembly file was generated by the 32-bit H++ Compiler

.CODE ;code segment
Math_DegreesToRadians PROC NEAR 
;double Math::DegreesToRadians(double deg);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{389}:return (deg * Math::pi()) / 180
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,0000000B4h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000469
;}
$L000469:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_DegreesToRadians ENDP

Math_Hyperbolic_HCos PROC NEAR 
;double Math::Hyperbolic::HCos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{452}:return (Math::Exp(X) + Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000486
;}
$L000486:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCos ENDP

Math_Hyperbolic_HCosec PROC NEAR 
;double Math::Hyperbolic::HCosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{464}:return 2 / (Math::Exp(X) - Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000492
;}
$L000492:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCosec ENDP

Math_Hyperbolic_HCotan PROC NEAR 
;double Math::Hyperbolic::HCotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{468}:return (Math::Exp(X) + Math::Exp(-X)) / (Math::Exp(X) - Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000494
;}
$L000494:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HCotan ENDP

Math_Hyperbolic_HSec PROC NEAR 
;double Math::Hyperbolic::HSec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{460}:return 2 / (Math::Exp(X) + Math::Exp(-X))
	mov	EAX,000000002h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000490
;}
$L000490:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSec ENDP

Math_Hyperbolic_HSin PROC NEAR 
;double Math::Hyperbolic::HSin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{448}:return (Math::Exp(X) - Math::Exp(-X)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000483
;}
$L000483:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HSin ENDP

Math_Hyperbolic_HTan PROC NEAR 
;double Math::Hyperbolic::HTan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{456}:return (Math::Exp(X) - Math::Exp(-X)) / (Math::Exp(X) + Math::Exp(-X))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Exp
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	call	 Math_Exp
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000488
;}
$L000488:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_HTan ENDP

Math_Hyperbolic_Inverse_HArccos PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccos(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{479}:return Math::Ln(X + Math::Sqrt(X * X - 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000500
;}
$L000500:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccos ENDP

Math_Hyperbolic_Inverse_HArccosec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccosec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{491}:return Math::Ln((Math::Sign(X) * Math::Sqrt(X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	call	 Math_Sign
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000506
;}
$L000506:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccosec ENDP

Math_Hyperbolic_Inverse_HArccotan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArccotan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{495}:return Math::Ln((X + 1) / (X - 1)) / 2
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000508
;}
$L000508:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArccotan ENDP

Math_Hyperbolic_Inverse_HArcsec PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsec(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{487}:return Math::Ln((Math::Sqrt(-X * X + 1) + 1) / X)
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	fld	qword ptr [ESP]
	fchs
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000504
;}
$L000504:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsec ENDP

Math_Hyperbolic_Inverse_HArcsin PROC NEAR 
;double Math::Hyperbolic::Inverse::HArcsin(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{475}:return Math::Ln(X + Math::Sqrt(X * X + 1))
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Sqrt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	jmp	OFFSET $L000497
;}
$L000497:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArcsin ENDP

Math_Hyperbolic_Inverse_HArctan PROC NEAR 
;double Math::Hyperbolic::Inverse::HArctan(double X);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{483}:return Math::Ln((1 + X) / (1 - X)) / 2
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fadd	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EAX,000000001h
	push	EAX
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	fsub	st,st(1)
	fstp	qword ptr [ESP]
	fclex
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	call	 Math_Ln
	push	EAX
	push	EDX 
	mov	EAX,000000002h
	fclex
	push	EAX
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000502
;}
$L000502:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_Hyperbolic_Inverse_HArctan ENDP

Math_RadiansToDegrees PROC NEAR 
;double Math::RadiansToDegrees(double rad);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{384}:return (180 / Math::pi()) * rad
	mov	EAX,0000000B4h
	push	EAX
	call	 Math_pi
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	call	 FloatingPoint_FromInt
	push	EAX
	push	EDX 
	fdivr	qword ptr [ESP]
	fstp	qword ptr [ESP]
	mov	EDX,dword ptr [EBP+0008h]
	mov	EAX,dword ptr [EBP+000Ch] 
	fclex
	push	EAX
	push	EDX 
	fld	qword ptr [ESP]
	pop	ECX
	pop	ECX 
	fmul	qword ptr [ESP]
	fstp	qword ptr [ESP]
	pop	EDX
	pop	EAX 
	jmp	OFFSET $L000466
;}
$L000466:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Math_RadiansToDegrees ENDP

Mathematics_Experiments_MatrixSuccesion PROC NEAR 
;void Mathematics::Experiments::MatrixSuccesion(void);
	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
;{
;}

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
Mathematics_Experiments_MatrixSuccesion ENDP

Mathematics_Experiments_MatrixSuccesion_ShowSuccesion PROC NEAR 
;void ShowSuccesion(int m);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000410h
	push	EBX 
	push	ESI 
	push	EDI 
	mov	dword ptr [EBP-0410h],ECX
;{

;{13}:A;
	lea	EAX,dword ptr [EBP-0400h]

;{14}:for(n= 1; n <= m; n++ )
	mov	EAX,000000001h
	mov	dword ptr [EBP-0404h],EAX
	jmp	OFFSET $L000547
$L000548:
	mov	EAX,dword ptr [EBP-1028]
	inc	dword ptr [EBP-1028]
$L000547:
	mov	EAX,dword ptr [EBP-0404h]
	push	EAX
	mov	EAX,dword ptr [EBP+0008h]
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000549
;{

;{16}:for(i= 0; i < n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0408h],EAX
	jmp	OFFSET $L000550
$L000551:
	mov	EAX,dword ptr [EBP-1032]
	inc	dword ptr [EBP-1032]
$L000550:
	mov	EAX,dword ptr [EBP-0408h]
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000552

;{17}:for(j= i; j < n; j++ )
	mov	EAX,dword ptr [EBP-0408h]
	mov	dword ptr [EBP-040Ch],EAX
	jmp	OFFSET $L000553
$L000554:
	mov	EAX,dword ptr [EBP-1036]
	inc	dword ptr [EBP-1036]
$L000553:
	mov	EAX,dword ptr [EBP-040Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000555
;{

;{19}:A[i][j]= 1;
	mov	EAX,dword ptr [EBP-0408h]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,000000001h
	pop	EBX
	mov	dword ptr [EBX],EAX

;{20}:if((j - 1) >= 0)
	mov	EAX,dword ptr [EBP-040Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L000556

;{21}:A[i][j]= A[i][j] + A[i][j - 1];
	mov	EAX,dword ptr [EBP-0408h]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0408h]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0408h]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	pop	EDX
	add	EAX,EDX
	pop	EBX
	mov	dword ptr [EBX],EAX
$L000556:

;{22}:if((i - 1) >= 0)
	mov	EAX,dword ptr [EBP-0408h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	push	EAX
	xor	EAX,EAX
	pop	EDX
	cmp	EDX,EAX
	setge	AL
	test	AL,AL
	jz	OFFSET $L000558

;{23}:A[i][j]= A[i][j] + A[i - 1][j];
	mov	EAX,dword ptr [EBP-0408h]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0408h]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0408h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	sub	EDX,EAX
	mov	EAX,EDX
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	pop	EDX
	add	EAX,EDX
	pop	EBX
	mov	dword ptr [EBX],EAX
$L000558:

;{26}:A[j][i]= A[i][j];
	mov	EAX,dword ptr [EBP-040Ch]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-0408h]
	pop	ESI
	lea	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	mov	EAX,dword ptr [EBP-0408h]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	pop	EBX
	mov	dword ptr [EBX],EAX
;}
	jmp	OFFSET $L000554 
$L000555:
	jmp	OFFSET $L000551 
$L000552:

;{29}:Console::Write("\n[");
	lea	EAX,OFFSET $S000533
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{30}:for(i= 0; i < n; i++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-0408h],EAX
	jmp	OFFSET $L000560
$L000561:
	mov	EAX,dword ptr [EBP-1032]
	inc	dword ptr [EBP-1032]
$L000560:
	mov	EAX,dword ptr [EBP-0408h]
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000562
;{

;{31}:for(j= 0; j < n; j++ )
	xor	EAX,EAX
	mov	dword ptr [EBP-040Ch],EAX
	jmp	OFFSET $L000563
$L000564:
	mov	EAX,dword ptr [EBP-1036]
	inc	dword ptr [EBP-1036]
$L000563:
	mov	EAX,dword ptr [EBP-040Ch]
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000565
;{

;{33}:Console::Write(A[i][j]);
	mov	EAX,dword ptr [EBP-0408h]
	imul	EAX,EAX,000000040h
	lea	EDX,dword ptr [EBP+EAX-0400h]
	push	EDX
	mov	EAX,dword ptr [EBP-040Ch]
	pop	ESI
	mov	EAX,dword ptr [ESI+EAX*0004h]
	push	EAX
	call	 Console_WriteInteger

;{34}:if((j + 1) < n)
	mov	EAX,dword ptr [EBP-040Ch]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000566

;{35}:Console::Write(",\t");
	lea	EAX,OFFSET $S000534
	push	000000000h
	push	EAX 
	call	 Console_WriteString
$L000566:
;}
	jmp	OFFSET $L000564 
$L000565:

;{37}:if((i + 1) < n)
	mov	EAX,dword ptr [EBP-0408h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	add	EAX,EDX
	push	EAX
	mov	EAX,dword ptr [EBP-0404h]
	pop	EDX
	cmp	EDX,EAX
	setl	AL
	test	AL,AL
	jz	OFFSET $L000568

;{38}:Console::Write(",\n ");
	lea	EAX,OFFSET $S000535
	push	000000000h
	push	EAX 
	call	 Console_WriteString
$L000568:
;}
	jmp	OFFSET $L000561 
$L000562:

;{40}:Console::WriteLn("]");
	mov	EAX,00000005Dh
	push	EAX
	call	 Console_WriteChar
	call	 Console_WriteCrLf 
;}
	jmp	OFFSET $L000548 
$L000549:
;}
$L000526:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000004h
Mathematics_Experiments_MatrixSuccesion_ShowSuccesion ENDP

Mathematics_Experiments_Application_main PROC NEAR 
;void Mathematics::Experiments::Application::main(int argc, string string [] argv);
	push	EBP
	mov	EBP,ESP
	sub	ESP,000000008h
	push	EBX 
	push	ESI 
	push	EDI 
;{

;{48}:mtx= new Mathematics::Experiments::MatrixSuccesion();
	push	000000001h
	call	 System_Memory_New
	test	EAX,EAX
	jz	 $L000570
	mov	ESI,EAX
	jmp	 $L000571
$L000570:
	xor	ESI,ESI
$L000571:
	mov	dword ptr [EBP-0004h],ESI 
	mov	ECX,ESI
	call	 Mathematics_Experiments_MatrixSuccesion
	mov	EAX,ESI 

;do
$L000572:
;{

;{50}:Console::ClearScreen();
	call	 Console_ClearScreen

;{51}:Console::WriteLn("The Matrix Succesion up to 16 matrices (Mathematics by Experiments Pag. 333).\n");
	lea	EAX,OFFSET $S000542
	push	000000000h
	push	EAX 
	call	 Console_WriteString
	call	 Console_WriteCrLf 

;{52}:Console::Write("Please, enter a number between 1 and 16: ");
	lea	EAX,OFFSET $S000543
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{53}:m= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0008h],EAX

;{54}:if(m <= 16)
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000010h
	pop	EDX
	cmp	EDX,EAX
	setle	AL
	test	AL,AL
	jz	OFFSET $L000575

;{55}:mtx.ShowSuccesion(m);
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	ECX,dword ptr [EBP-4]
	call	 Mathematics_Experiments_MatrixSuccesion_ShowSuccesion
$L000575:

;{56}:Console::Write("\nContinue? 1 = Yes, Otherwise = No:");
	lea	EAX,OFFSET $S000546
	push	000000000h
	push	EAX 
	call	 Console_WriteString

;{57}:m= Console::ReadInteger();
	call	 Console_ReadInteger
	mov	dword ptr [EBP-0008h],EAX
;}
$L000573:

;{57}:while(m == 1)
	mov	EAX,dword ptr [EBP-0008h]
	push	EAX
	mov	EAX,000000001h
	pop	EDX
	cmp	EDX,EAX
	setz	AL
	test	AL,AL
	jne	OFFSET $L000572
$L000574:

;{60}:destroy mtx;
	mov	EAX,dword ptr [EBP-4]
	push	EAX
	call	 System_Memory_Destroy
;}
$L000538:

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	retn	000000008h
Mathematics_Experiments_Application_main ENDP

__System_Hpp_Runtime_Init PROC

	push	EBP
	mov	EBP,ESP
	push	ECX 
	push	EBX 
	push	ESI 
	push	EDI 
	call	 GetVersion
	mov	 __osver,EAX ;os version
	mov	EAX, __osver 
	shr	EAX,000000008h
	and	EAX,0000000FFh
	mov	 __winminor,EAX ;windows minor
	mov	ECX, __osver 
	and	ECX,0000000FFh 
	mov	 __winmajor,ECX ;windows major
	mov	EDX,dword ptr __winmajor 
	shl	EDX,000000008h
	add	EDX,dword ptr __winminor
	mov	dword ptr __winver,EDX ;windows version
	mov	EAX, __osver 
	shr	EAX,000000010h 
	and	EAX,00000FFFFh 
	mov	 __osver,EAX 
	lea	EBX,dword ptr ___argc
	push	EBX
	call	 System_GetCommandLineArgv 
	mov	dword ptr ___argv,EAX 
	push	EAX 
	mov	ECX,dword ptr ___argc 
	push	ECX 
	call	 Mathematics_Experiments_Application_main ;user entry point (stdcall calling convention)
	push	EAX 
	mov	EAX,dword ptr ___argv 
	push	EAX 
	call	 System_Memory_GetProcessHeap 
	push	EAX 
	call	 System_Memory_Free 
	call	 System_Exit 

	pop	EDI
	pop	ESI 
	pop	EBX 
	mov	ESP,EBP
	pop	EBP 
	ret	
__System_Hpp_Runtime_Init ENDP

.DATA ;data segment
File_INVALID_HANDLE_VALUE	=	0FFFFFFFFh
File_INVALID_SET_FILE_POINTER	=	0FFFFFFFFh

$S000535 		BYTE 	",",0Ah," ",0
$S000534 		BYTE 	",",09h,0
$S000543 		BYTE 	"Please, enter a number between 1 and 16: ",0
$S000542 		BYTE 	"The Matrix Succesion up to 16 matrices (Mathematics by Experiments Pag. 333).",0Ah,0
$S000546 		BYTE 	0Ah,"Continue? 1 = Yes, Otherwise = No:",0
$S000533 		BYTE 	0Ah,"[",0

__osver 		DWORD 	0;Windows OS version
__winminor 		DWORD 	0;Windows minor version
__winmajor 		DWORD 	0;Windows major version
__winver 		DWORD 	0;Windows version
__computer 		BYTE 	000000020h DUP(?);Computer name
___argv 		DWORD 	0;Array of argument values
___argc 		DWORD 	0;Argument count

END __System_Hpp_Runtime_Init

